
# schedule

进程调度是操作系统最重要的内容之一, 也是最不好理解和调试的部分之一, 尤其在多线程多进程多处理器的情况下. 本文试图系统的介绍整个过程

## 什么是调度?

操作系统的作用之一就是系统资源管理器.CPU作为计算机系统中最重要的资源, 所有进程的运行都需要CPU, **对CPU进行时间分割管理的具体做法就叫做进程调度**.

那么调度的是什么呢? 我们知道**进程**是**资源分配**的单位,**线程**是**执行**的单位.早期的时候没有多线程, 此时进程调度调度的是进程.但是当有了多线程之后,线程变成了执行的单位,进程不再是执行的单位,进程调度调度的就是线程了.

> 不过由于历史原因,大家都习惯叫进程调度,所以现在这个领域的名称还是叫进程调度.后文中说到调度进程的地方都是调度的线程,由于习惯问题,我们还说调度进程不说调度线程,请大家要注意.

调度可以有两种方式:

- 一种是**直接调度线程**,不考虑它们所属的进程,这种方式叫做直接调度或者一级调度;
- 另一种是先调度进程,再**在进程内部调度线程**,这种方式叫做间接调度或者二级调度.

POSIX规定,操作系统可以选择这两种方式中的任何一种都行.**Linux选择的是一级调度**,主要是为了提高进程的并发性,充分利用多CPU多核的优势.如果使用二级调度的话,看似每个进程之间都公平了,但是有些进程的计算量比较大,就无法通过多开线程提高自己的性能,这样对系统整体的性能是有害的,也不利用发挥计算机多CPU的优势.一级调度看似对有些进程不公平,但是计算量小的进程少开线程,计算量大的进程多开线程,相对还是很公平的.

> 尽管一级调度可能导致某些进程对CPU资源的过度占用,但Linux引入了cgroups(控制组)来管理和限制进程组的资源使用,从而解决了这个问题, 详见 [cgroup](./cgroup.md)

## 为什么要调度?

在讨论为什么要调度之前, 我们不妨设想一下没有调度会怎么样呢?

最早的计算机是没有调度的,程序只能一个一个地运行,一个进程死亡(结束)之后才能去运行下一个进程.这里面首先存在的问题就是我们**没法同时运行多个进程**.其次, 就算我们不需要同时运行多个进程,程序在运行的过程中如果要**等IO,CPU就只能空转**,这也十分浪费CPU资源.

于是最早的多任务: **协作式多任务**诞生了,**当程序因为等待IO而阻塞时就会去调度执行其它的进程**.但是协作式多任务存在着很大的问题,就是每个进程运行的时间片长短是不确定的,而且是很偶然很随机的.如果一个进程它**一直在做运算而不进行IO操作**,那么它就会**一直霸占CPU**.针对这个问题,当时想出的方法是道德解决方案.内核向进程提供系统调用 `[sched_yield](https://linux.die.net/man/2/sched_yield)`,它会使进程主动放弃CPU让其它进程来执行.然后要求所有的程序员在程序中合适的地方尽量多地加入 `sched_yield` 调用.这个方法在当时是管用的,因为当时计算机的使用者(同时也是程序员)仅限于少数科研机构和政府机关的部分人员,一台电脑的共同使用者都认识,面子上还得过得去.

后来随着计算机的普及,以及计算机的使用者和程序员这两个角色的分离,主要靠道德约束的协作式多任务已经行不通了,我们需要强制性多任务,也就是**抢占式多任务**.抢占式多任务使得**每个进程都可以相对公平地平分CPU时间**,如果一个进程运行了过长的时间就会被强制性地调度出去,不管这个进程是否愿意.有了抢占式多任务,我们在宏观上不仅可以同时运行多个进程,而且它们会一起齐头并进地往前运行,不会出现某个进程被饿死的情况,这样我们使用电脑的体验就非常完美了.抢占式多任务和协作式多任务不是对立的,它们是相互独立的,可以同时存在于系统中.

抢占又分为用户抢占和内核抢占.由于抢占对进程来说是异步的,进程被抢占时不一定运行在什么地方,有可能运行在用户空间,也有可能运行在内核空间(进程通过系统调用进入内核空间).如果抢占点是在用户空间,那么抢占就是安全的; 如果在内核空间就不一定安全, 因为对于用户空间来说,如果抢占会导致线程同步问题,那么用户空间有责任使用线程同步机制来保护临界区,只要用户空间做好同步就不会出问题.如果内核也做好了同步措施,内核抢占也不会出问题,但是内核最初的设计就没有考虑内核抢占问题,所以刚开始的时候内核是不能抢占的.后来内核开发者对内核进行了完善,把内核所有的临界区都加上了同步措施,然后内核就是可抢占的了.

> 内核能抢占了不代表内核一定会抢占,内核会不会抢占由config选项控制(`[CONFIG_PREEMPT](https://cateee.net/lkddb/web-lkddb/PREEMPT.html)`),可以开启也可以关闭,因为内核抢占还会影响系统的响应性和性能.
> 
> 开启内核抢占会提高系统的响应性但是会降低一点性能,关闭内核抢占会降低系统的响应性但是会提高一点性能.因此把内核抢占做成配置项,可以让大家灵活配置.
> 
> 服务器系统一般不需要与用户交互,所以会关闭内核抢占来提高性能,桌面系统会开启内核抢占来提高系统的响应性,来增加用户体验.

因此进程调度的目的就在于实现多任务, 让各个进程相对公平的占有 CPU以提高电脑的使用体验.

## 参考

- [深入理解Linux进程调度](https://mp.weixin.qq.com/s?__biz=Mzg2OTc0ODAzMw==&mid=2247506713&idx=1&sn=38ca5f3af28d741b46e0197a5decd0a2&chksm=ce9ac737f9ed4e21f8a39efd85be7390863ab13faa9bafc1f031f1adef8b0c2b561f04302b20&scene=178&cur_album_id=2519398872503353344#rd)
- [Linux进程调度器的设计--Linux进程的管理与调度(十七)](https://blog.csdn.net/gatieme/article/details/51702662)
- [Linux内核学习笔记(5)-- 进程调度概述](https://www.cnblogs.com/tongye/p/9575602.html)
- [进程调度](https://blog.csdn.net/qq_38847853/article/details/80554515)
- [yeefea linux_kernel_dev4](https://yeefea.com/os/linux_kernel_dev4/)
- [linux内核分析 CFS(完全公平调度算法)](https://www.cnblogs.com/tianguiyu/articles/6091378.html)
- [进程管理](https://kernel.blog.csdn.net/article/details/51456569)
- [万字长文,锤它!揭秘Linux进程调度器](https://www.51cto.com/article/701537.html)
- [Linux CFS 调度器:原理、设计与内核实现](https://arthurchiao.art/blog/linux-cfs-design-and-implementation-zh/)
- [深入理解Linux内核进程的管理与调度(全知乎最详细)](https://zhuanlan.zhihu.com/p/472955572)
- [O(1) scheduler](https://en.wikipedia.org/wiki/O(1)_scheduler)
- [linux 进程优先级及调度](https://www.cnblogs.com/abels0025/p/11430740.html)