
# mm_struct

## Linux 虚拟内存系统

相信你一定已经多次看到下面这张图了

![20230329011345](https://raw.githubusercontent.com/learner-lu/picbed/master/20230329011345.png)

整个虚拟内存空间分为上下两部分, 最高地址是内核虚拟内存, 下面是进程的虚拟内存; 内核虚拟内存包含内核的代码和全局数据结构

Linux 将一组连续的虚拟页面(大小等同于 DRAM 的总理)映射到相应的一组连续的物理页面, 这就为内核提供了一种变量你的方法来访问物理内存中任何特定的位置. 这就为内核提供了一种便利的方法来访问物理内存中的特定位置; 换句话说, 在虚拟地址空间中如果要访问页表, 页表保存在内核虚拟内存中, 始终处于一个相对固定的虚拟地址位置

![20230329111219](https://raw.githubusercontent.com/learner-lu/picbed/master/20230329111219.png)

上图记录了 Linux 虚拟内存的相关数据结构, 内核为系统每个继承维护一个单独的任务结构 task_struct, 其中 task_struct 中的元素包含指向内核运行该进程所需的所有信息(比如 PID 指向用户栈的指针 可执行目标文件名 程序计数器等等)

task_struct 中的一个元素指向 mm_struct, 它描述了虚拟内存的当前状态, 其中比较重要的是 pgd mmap 字段, pgd 指向一级页表的基地址, 当内核运行这个进程的时候就将 pgd 放入 PTBR; mmap 指向一个 vm_area_structs 的链表, 每个 vm_area_structs 都描述了当前虚拟地址空间的一个区域, 你可以在上图中看到每一个 vm_area_struct 都指向虚拟内存空间中的一段地址, 其中

- vm_start: 区域起始
- vm_end: 区域结束
- vm_prot: 区域内所有页的读写许可权限
- vm_flags: 区域内页面的一个标记位(与其他进程共享还是私有的)
- vm_next: 指向下一个 vm_area_struct 结构

> 注意下面是低地址, 上面是高地址, 所以 vm_start 指向下面
>
> 相关的元素会在 mmap 函数中再次看到

![20230329112426](https://raw.githubusercontent.com/learner-lu/picbed/master/20230329112426.png)

当 MMU 试图翻译某个虚拟地址 A 但是发现缺页了, 这时候可能会有如上三种情况

1. 虚拟地址 A 不合法, A 不在任何一个 vm_area_struct 区域之内, 缺页处理程序触发一个段错误
2. 虚拟地址 A 合法, 但 A 的内存访问不合法, 比如进程的只读区域中进行写操作(修改 const 变量), 试图从内核虚拟内存中读取字, 缺页处理程序会触发一个段错误
3. 虚拟地址 A 合法, 那么就选择一个牺牲页, 如果牺牲页被修改过则将其交换出去, 将新的页面换入并更新页表. 缺页处理程序返回之后 CPU 重新启动引起缺页的指令

> 这里的第一点要说明一下, 因为一个进程可以创建任意数量的新虚拟内存区域, 所以顺序搜索区域结构的链表花销会很大, 因此在实际中 Linux 在链表中构建一个一棵树并在这个树上进行查找

## 内存映射

Linux 通过将一个虚拟内存区域于一个磁盘上的对象关联起来, 以初始化这个虚拟内存区域的内容, 这个过程被称为内存映射

内存映射的概念来源于一个聪明的发现, 如果虚拟内存系统可集成到传统文件系统当中, 那么就能提供一种简单而高效的把程序和数据加载到内存中的方法. 每个运行着 Linux shell程序的bash进程都有相同的代码区域, 每个C程序都需要来自标准C库的诸如 printf 这样的函数, 如果每个进程内都在物理内存中保存相同的代码副本, 那就是极端的浪费了. 幸运的是内存映射给我们提供了一种清晰的机制, 用来控制多个进程如何共享对象

内存映射的对象有两种

- Linux 文件系统中的普通文件: 我们可以创建一块虚拟内存区域用于映射, 包含多个虚拟内存页. 在内存映射的环节将这些虚拟页与文件区的片进行一个对应. 值得注意的是这些虚拟页实际上并没有交换到物理内存中, 直到 CPU 第一次引用到这样一个区域内的虚拟页面才会被通过缺页中断换入物理内存
- 匿名文件

![20230329133024](https://raw.githubusercontent.com/learner-lu/picbed/master/20230329133024.png)

一旦一个虚拟页面被初始化了, 他就在一个由内核维护的专门交换文件之间换来换去, 交换文件也叫做交换空间(swap area). 在任何时刻, **交换空间都限制着当前运行中的进程能够分配的虚拟页面的总数**

一个对象可以被映射到虚拟内存的一个区域, 要么作为 **共享对象**, 要么作为 **私有对象**

- 对于共享对象: 该虚拟内存区域为共享区域, 这个进程对共享对象的任何写操作, 对于其他使用共享对象的进程也是可见的, 这些变化也会反映到磁盘上的原始对象
- 对于私有对象: 该虚拟内存区域为私有区域, 对于其他进程来说是不可见的, 并且进程对私有对象的写操作并不会反映到磁盘上的对象

![20230329133538](https://raw.githubusercontent.com/learner-lu/picbed/master/20230329133538.png)

上图中假设进程 1 将一个共享对象映射到它的虚拟内存的一个区域中, CPU 引用这个页面之后会在物理内存中创建一份副本

![20230329133314](https://raw.githubusercontent.com/learner-lu/picbed/master/20230329133314.png)

当进程 2 页将同一个共享对象映射到虚拟内存的时候, 由于每个对象都有唯一的一个文件名, 内核可以迅速的判断进程 1 已经影射了这个对象, 并且可以使进程 2 的页表条目指向相应的物理页面. 关键点在于即使对象被映射到了多个共享区域, 物理内存中也只需要存放共享对象的一个副本

当进程 1 修改其虚拟页面的数据的时候, 这个修改会同步到物理内存, 磁盘, 物理内存的修改会影响到其他引用共享对象的进程

![20230329134211](https://raw.githubusercontent.com/learner-lu/picbed/master/20230329134211.png)

---

对于私有对象来说, 采用一种十分巧妙的写时复制(copy on write)的技术, 其生命周期的方式基本上与共享对象一样, 在物理内存中只保存私有对象的一份副本

对于每个映射私有对象的进程, 相应私有区域的页表条目都被标记为只读, 并且区域结构被标记为 **私有的写时复制**, 只有没有进程试图写自己的私有区域他们就可以继续共享物理内存中的对象的一份副本, 但是只要有一个进程试图写私有区域的某个页面, 那么这个写操作就会触发一个保护故障

![20230329134937](https://raw.githubusercontent.com/learner-lu/picbed/master/20230329134937.png)

当故障处理程序注意到保护异常是由于进程试图写 "私有的写时复制" 区域中的一个页面的副本, 他就会在物理内存中创建这个页面的一个新副本, 更新页表条目指向这个新的副本, 然后修改这个页面的可写权限, 如上图所示

故障处理程序返回的时候 CPU 重新执行写操作, 现在在新的页面进行写操作就可以进行正常执行了

我们可以看到通过延迟四有对象中的副本直到最后可能的时刻, 写时复制最充分的使用了稀有的物理内存

#### fork

当 fork 函数被当前进程调用的时候, 内核为新进程创建各种数据结构, 并分配给他一个唯一的PID, 为了给这个新进程创建虚拟内存, 内核复制当前进程的 mm_struct, 区域结构 页表的原样副本, 将两个进程的每个页面都标记为 **只读**, 将两个进程中的每个区域结构都标记为 **私有的写时复制**

当fork的新进程中返回时, 新进程现在的虚拟内存和调用fork时存在的虚拟内存相同. 当这两个进程中的任何一个后来进行写操作时, 写时复制机制就会创建新页面, 也就为每个进程都保持了私有地址空间的抽象概念

当新进程现在的虚拟内存和调用fork时存在的虚拟内存相同时,这意味着**新进程可以立即开始执行父进程的代码,不需要额外的内存开销和数据拷贝**.这是因为在fork函数被调用时,操作系统会通过写时复制技术为新进程创建一个独立的虚拟内存空间,并将父进程的内存映射信息复制到新的虚拟内存空间中,但是并没有为新进程实际分配物理内存空间,**只有在新进程试图修改内存内容时,才会为新进程分配独立的物理内存空间**.

因此,在新进程返回之前,新进程和父进程共享同一份虚拟内存空间,这可以保证子进程在执行过程中,与父进程使用同样的代码和数据,从而可以有效地节省内存使用和提高程序执行的效率.另外,由于写时复制技术的存在,子进程和父进程之间的内存空间是互相独立的,这意味着它们之间的数据操作不会互相影响

#### execve

```c
execve("a.out",NULL,NULL);
```

execve 函数在当前进程中加载并运行包含在可执行目标文件中的程序, 用 a.out 替换当前程序

加载并运行 a.out 需要如下几个步骤

1. 删除已存在的用户区域, 删除当前进程的用户部分已存在的区域结构
2. 映射私有区域, 将 a.out 的 data bss text映射到对应的位置
3. 映射共享区域, 如果有 a.out 程序与共享对象的链接, 比如 libc.so, 将共享对象映射到共享区域中
4. 设置程序计数器, 将 PC 指向当前代码区域的入口