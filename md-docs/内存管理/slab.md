
# slab

在Linux中,伙伴分配器(buddy allocator)是以页为单位管理和分配内存.但在内核中的需求却以字节为单位(在内核中面临频繁的结构体内存分配问题).假如我们需要动态申请一个内核结构体(占 20 字节),若仍然分配一页内存,这将严重浪费内存

slab 分配器**专为小内存分配而生**, 基于伙伴分配器的大内存进一步细分成小内存分配.换句话说,slab 分配器仍然从 Buddy 分配器中申请内存,之后自己对申请来的内存细分管理.

> slab 由Sun公司的一个雇员Jeff Bonwick在Solaris 2.4中设计并实现, 由于他公开了其方法,因而后来被Linux所借鉴,用于实现内核中更小粒度的内存分配. 

除了提供小内存外,slab 分配器的第二个任务是**维护常用对象的缓存**.对于内核中使用的许多结构,初始化对象所需的时间可等于或超过为其分配空间的成本.当创建一个新的slab 时,许多对象将被打包到其中并使用构造函数(如果有)进行初始化.释放对象后,它会保持其初始化状态,这样可以快速分配对象

SLAB分配器的最后一项任务是**提高CPU硬件缓存的利用率**. 如果将对象包装到SLAB中后仍有剩余空间,则将剩余空间用于为SLAB着色. SLAB着色是一种尝试使不同SLAB中的对象使用CPU硬件缓存中不同行的方案. 通过将对象放置在SLAB中的不同起始偏移处,对象可能会在CPU缓存中使用不同的行,从而有助于确保来自同一SLAB缓存的对象不太可能相互刷新. 通过这种方案,原本被浪费掉的空间可以实现一项新功能

> 除了 SLAB, 还有 SLUB SLAB 两个相似的名字, 其中SLUB是SLAB的改进版本, SLOB是用于嵌入式等内存容量不大的场景下的对象分配算法

1. 解决buddy按照页的颗粒度分配小内存的碎片问题
2. 缓存部分常用的数据结构(包括但不限于inode、dir_entry、task_struct等),减少操作系统分配、回收对象时调整内存的时间开销
3. 通过着色更好地利用cpu硬件的高速缓存cache,允许不同缓存中的对象占用相同的缓存行,从而提高缓存的利用率并获得更好的性能

## 参考

- [linux源码解读(九):内存管理_buddy和slab](https://www.cnblogs.com/theseventhson/p/15703182.html)
- [Linux 内核 | 内存管理_Slab 分配器](https://www.dingmos.com/index.php/archives/23/)