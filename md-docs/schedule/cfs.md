
# cfs

好的,我来系统地解释一下 **CFS(Completely Fair Scheduler,完全公平调度器)** _ 这是 Linux 默认的进程调度器,从 2.6.23 内核开始引入,用于调度 **普通进程(非实时进程)**.

---

## 🔹 1. 设计目标

传统调度器(O(1) 调度器)在面对大量进程时,容易出现 **不公平** 或 **交互延迟高** 的问题。
CFS 的目标是:

* **尽可能公平地分配 CPU 时间**(每个进程按权重获得相应的 CPU 时间).
* 保证 **交互性**(响应用户输入的进程能更快得到调度).
* **简单可扩展**,能处理成百上千个进程。

---

## 🔹 2. 核心思想

CFS 不再使用时间片(timeslice)+ 优先级队列,而是基于一个 **理想的"完全公平队列"模型**:

* 理想情况:如果有 N 个相同权重的进程,它们应该 **平均分配 CPU 时间**,即每个进程轮流执行,且执行时间相等。
* 现实中:CFS 使用一个关键指标 _ **虚拟运行时间 (vruntime)**,来衡量进程的"公平性".

---

## 🔹 3. 关键概念

1. **虚拟运行时间 (vruntime)**

   * 每个进程都有一个 `vruntime`,表示它消耗的 CPU 时间(按权重归一化).
   * 运行时间越多,`vruntime` 越大。
   * 权重高(nice 值小)的进程增加 `vruntime` 的速度更慢,相当于它能多占 CPU.

   数学上:

   ```
   vruntime += 实际运行时间 × (NICE_0_LOAD / 进程权重)
   ```

2. **红黑树 (rb-tree)**

   * 所有可运行进程按 `vruntime` 排序,存放在一棵红黑树中。
   * 树最左边的节点就是 `vruntime` 最小的进程(即最"亏欠"CPU 时间的进程).
   * CFS 总是调度这棵树中最左边的进程。

3. **调度周期 (scheduling period)**

   * 内核会尝试让所有可运行进程在一个调度周期内都至少运行一次。
   * 调度周期会随运行队列长度调整,保证公平性。

---

## 🔹 4. 调度过程(简化版)

1. 从红黑树中取出 `vruntime` 最小的进程(最左节点).
2. 运行该进程一小段时间。
3. 更新它的 `vruntime`(越高说明它"用得越多").
4. 重新插入红黑树合适的位置。
5. 下一次调度时,继续取 `vruntime` 最小的进程。

这样一来:

* 所有进程最终的 `vruntime` 会尽量保持接近。
* 进程获得的 CPU 时间接近它应得的"公平份额".

---

## 🔹 5. CFS 的优点

* 公平:保证每个进程按照权重公平分配 CPU.
* 可扩展:红黑树操作是 O(logN),适合大规模进程调度。
* 交互性好:I/O 密集型进程会频繁睡眠,醒来时 `vruntime` 比较小,因此能更快被调度(响应性更好).

---

## 🔹 6. CFS 相关参数

* `sched_latency_ns`:调度周期(所有进程应在此周期内都执行一次).
* `sched_min_granularity_ns`:最小时间片(防止进程切换过于频繁).
* `sched_wakeup_granularity_ns`:唤醒粒度,避免频繁抢占。

可以在 `/proc/sys/kernel/` 下查看或通过 `sysctl` 调整。

---

## 🔹 7. 总结

CFS 就像是给每个进程发放一个 **账本 (vruntime)**,谁"花的少"谁就优先获得 CPU;谁"花的多"就暂时靠后。
这种方式既保证了公平性,又能让交互型任务更快得到响应。

---

要不要我帮你画一个 **红黑树调度示意图**(几个进程的 vruntime 变化过程),让你更直观地理解 CFS 是怎么选择下一个进程的?
