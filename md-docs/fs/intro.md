
# intro

在Linux系统中,磁盘设备不仅仅是一个简单的字符设备,它的操作远比基本的读写更加复杂. 磁盘是所有程序共享的, 如果单纯的将这一大片地址空间丢给应用程序, 那么它们之间的数据访问和管理将是噩梦. 因此需要以一种有序的方式访问磁盘上的数据.如果仅仅由设备驱动程序将磁盘抽象为一个可读可写的字节序列,这种抽象是不够的.因为**这样的抽象没有考虑到磁盘的共享特性和访问模式**,可能会导致应用程序之间的数据访问冲突和效率低下.

> 设备驱动程序详见 [device/driver](../device/driver.md)

Linux系统通过**文件系统**提供了一个更高级别的抽象来解决这个问题.文件系统管理着磁盘上的数据存储和检索,它提供了一种结构化的方式来组织数据,使得应用程序可以通过文件和目录的层次结构来访问存储在磁盘上的信息.这样,应用程序不需要直接与磁盘交互,而是通过文件系统进行操作.

文件系统还负责处理数据的缓存、权限控制、数据一致性和其他管理任务.它为应用程序提供了一个统一的接口,无论底层的物理存储设备是什么,应用程序都以相同的方式进行数据存取.这种设计不仅简化了应用程序的开发,也提高了数据访问的效率和安全性.

总之,Linux系统中的磁盘设备驱动程序不仅仅是实现了基本的读写操作,它还与文件系统紧密协作,提供了一种高级的数据访问抽象,使得应用程序能够有效、有序地共享和访问磁盘资源.这种设计使得磁盘操作更加复杂,但同时也更加强大和灵活.

## 文件系统层

我们的磁盘 (存储设备) 有几个很重要的访问特性

1. 以数据块 (block) 为单位访问
   
   磁盘不支持随机访问,或者说随机访问的性能不如顺序访问.这是因为磁盘内部的物理特性决定了数据的读取和写入通常是按照某种顺序进行的,例如,磁盘上的磁头需要移动到正确的磁道上才能访问特定的数据块.因此,连续的数据传输通常比随机访问单个数据块更加高效

   >  最佳的传输模式与设备相关 (HDD v.s. SSD)

2. 大吞吐量
   使用 DMA 传送数据
3. **应用程序不直接访问**
  
   访问者通常是文件系统 (维护磁盘上的数据结构), 比如打开/写入文件 `/tmp/a.txt`
   
   且系统中存在大量并发的访问 (操作系统中的进程都要访问文件系统)

Linux操作系统中实现了一个称为**block IO层**的结构,这一层在多CPU环境下工作,负责处理来自上层应用程序和文件系统的磁盘访问请求.在这个层面上,我们可以将其理解为一个中间层,**它接收来自上层的请求并将其转换为对磁盘的块级操作**.

![20240408160414](https://raw.githubusercontent.com/learner-lu/picbed/master/20240408160414.png)

当你想要向磁盘写入数据时,例如写入一系列的数据块(1, 2, 3, ..., 9),你的请求首先会被提交给block IO层.在这一层中,存在一个队列,它负责管理和调度所有的读写请求.block IO层的API提供了基本的读块和写块操作,同时也支持确保所有写入操作都已持久化到存储设备的功能,这通常是通过fsync系统调用实现的.

> ```bash
> man 2 fsync
> ```

fsync是一个同步操作,当你认为某些数据非常重要,需要立即持久化到存储设备时,你可以使用fsync来**确保所有待写入的数据都被安全地存储**.例如,在拔出U盘之前,你可以使用fsync来确保所有缓存中的数据都被写入到U盘中.

在Linux中,除了IO调度的复杂性,对于上层应用程序和文件系统来说,它们不需要关心底层的实现细节.文件系统层和虚拟文件系统(VFS)将不同类型的请求(如读取数据块、写入数据块等)封装并提交给block IO层的队列.最终,这些请求会通过总线和磁盘接口传递给磁盘驱动程序,由驱动程序完成实际的磁盘读取和写入操作.

## 文件系统

磁盘中存储几乎所有的数据, 但是字节序列并不是磁盘的好抽象, 因此文件系统的设计目标主要有两个:

- 提供合理的 API 使多个应用程序能**共享数据**
- 提供一定的**隔离**,使恶意/出错程序的伤害不能任意扩大

文件系统对磁盘存储进行了虚拟化.它将大块的物理磁盘空间分割成许多较小的、可扩展的**虚拟磁盘**.磁盘 (I/O 设备) 可以看做是一个可以读/写的字节序列, 而每个虚拟磁盘也是一个可读写的字节序列,可以视为一个**文件**.这些文件可以根据需要动态地调整大小,例如,可以从4KB扩展到16KB,以适应数据存储的需求变化.

操作系统中的文件系统管理着众多的文件,每个文件都是一个独立的字节序列,即一个虚拟磁盘.用户和应用程序可以通过文件系统对这些文件进行增删改查等操作.为了便于管理和访问,需要文件系统提供**命名管理**.每个文件都有一个唯一的名称,如"a.txt"或"bin/ls",用户可以通过这些名称来访问和管理文件, 还要给他提供文件的检索/遍历的这些功能; 文件系统还需要提供**数据管理**, 以便随机读写和调整文件大小

> 文件偏移量管理

## 目录树

文件夹,通常被称为目录,是文件系统中用于组织和管理文件的一种重要结构.它为用户和应用程序提供了一种直观的方式来分类和访问文件,使得在庞大的文件集合中寻找特定文件变得简单高效.

> 想象一下,如果你的所有课程资料、作业、项目等都杂乱无章地堆放在一起,想要找到某一特定课程的大作业,无疑是一项艰巨的任务.这就像是在没有分类的图书馆中寻找一本特定的书一样困难.因此,文件夹的概念应运而生,它允许我们将相关的文件组织在一起,形成一个有层次的结构,从而提高查找和管理的效率.

文件夹的工作原理类似于我们日常生活中的分类方法.例如,你可能会将不同学科的资料分别存放在不同的文件夹中,每个学科的文件夹下又可以细分为不同的课程或项目.这样的树状结构不仅使得文件管理变得有序,而且也符合我们大脑处理信息的习惯.我们倾向于将信息按照类别和关联性进行组织.

在操作系统中,文件系统的目录结构也是基于类似的原理.例如,在Windows操作系统中,你可能会看到"Program Files"、"Windows"、"Users"等顶层目录,这些目录下又包含了更具体的子目录和文件.这样的结构使得用户可以快速地定位到特定的应用程序、系统文件或个人文档. Windows 下每个设备 (驱动器) 是一棵树, C:/ D:/, U盘分配给新的盘符

Linux操作系统采用了一种更为统一的文件系统结构,整个系统中只有一个根目录(`/`).这种设计简化了文件系统的层次结构,使得所有的文件和目录都在这一个统一的框架下进行管理.当然,这种设计也带来了一些操作上的挑战,比如**如何处理外部存储设备**

Linux通过"**挂载**"(mounting)的概念来解决这个问题, 目录树的灵活性和强大的挂载机制是其文件系统管理的核心特点.即将外部存储设备"挂载"到文件系统的某个目录下,使其成为文件系统的一部分,从而可以像访问本地文件一样访问这些外部存储设备上的文件. 通过挂载,可以将几乎任何类型的存储设备或文件系统添加到目录树中的任何位置,从而实现对文件的高效组织和访问

我们可以将一个磁盘文件挂载到一个目录下, 也可以将一个设备挂载到一个目录

在Linux操作系统中,`mount`命令是用来将一个文件系统挂载到目录树中的特定位置的操作.这个过程是通过操作系统的文件系统管理层来实现的,而不是简单地"hack"目录API.以下是`mount`操作的实现逻辑:

1. **确定挂载点**:首先,需要确定文件系统将要挂载到的目录位置,即挂载点.这个位置可以是根目录`/`,也可以是文件系统中的任何其他目录.

2. **路径解析**:当一个应用程序或用户尝试访问一个文件时,操作系统会通过路径解析来确定文件的确切位置.例如,用户可能会尝试打开`/home/username/ABC/JYY/A.txt`这样的路径.

3. **挂载表查询**:在路径解析过程中,操作系统会参考挂载表.挂载表是操作系统维护的一个数据结构,记录了哪些文件系统被挂载到了哪些目录点.例如,使用`mount -l`命令可以查看当前系统的挂载表.

4. **文件系统切换**:如果解析到的路径指向了一个挂载点,操作系统会根据挂载表中的信息,将对该路径的访问请求切换到相应的文件系统.这意味着,对于同一个目录节点,操作系统会根据挂载表中的信息,重新进行路径解析,但这次是在挂载的文件系统上下文中.

5. **统一的目录解析代码**:Linux操作系统中,无论是挂载了多少个不同类型的文件系统,如NTFS、ext4、FAT32等,操作系统都有一套统一的目录解析代码来处理这些请求.这套代码能够识别挂载点,并根据挂载表中的信息,正确地将请求路由到相应的文件系统.

> 更多有关 mount 的讨论见 [fs/mount](./mount.md)

## 设计

相比于内存 RAM 的读写设计, 磁盘没有办法做到 1 bit 的修改. 其中一个主要的挑战是**读写放大**.例如,当用户程序仅需要修改一个文件中的一小部分数据时, 文件系统仍然需要将一整个数据块读出, 修改后再将其写入.

然而,我们也有一些有利因素.如果我们从整个操作系统的角度来考虑,而不是仅仅关注单个应用程序的单次读写操作,我们会发现**许多程序会持续地访问大量文件**.例如,浏览器在启动时会读取多个文件,而视频编辑软件在运行时也会加载许多动态链接库和数据.通过合理地组织这些数据,我们可以利用数据**局部性**原理,优化文件的存储和访问模式.这意味着,如果我们将经常一起访问的数据放置在相邻的位置,那么当一个数据被读取时,其相邻的数据也可能很快被再次访问,从而减少读写放大的影响.

此外,缓存技术是缓解读写放大的有效手段.文件系统可以将频繁访问的数据保存在内存缓存中,这样当再次访问这些数据时,就可以直接从内存中读取,而不是从磁盘.对于写操作,文件系统可以将数据先写入内存缓存,然后在合适的时机批量写入磁盘.这种方法可以将多次磁盘写入合并为一次,减少了对磁盘的I/O操作,从而有效缓解读写放大问题.

这些策略在计算机系统的基础课程中已有介绍,它们是提高计算机性能的重要技术.通过这些方法,文件系统可以更高效地管理数据,提供更好的用户体验.因此,在设计文件系统时,我们需要综合考虑这些因素,以实现高效、稳定的数据存储和访问.

## 参考

- [设备驱动程序与文件系统 (Linux 设备驱动;目录管理 API) [南京大学2023操作系统-P27] (蒋炎岩)](https://www.bilibili.com/video/BV1m24y1A7Fi/)
- [FAT 和 UNIX 文件系统 (磁盘上的数据结构) [南京大学2023操作系统-P28] (蒋炎岩)](https://www.bilibili.com/video/BV1xN411C74V/)