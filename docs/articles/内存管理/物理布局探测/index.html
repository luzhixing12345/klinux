<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/prism.css /><link rel='stylesheet' href=../../../css/index.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/klinux.git" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">物理布局探测</a><ul><li><a href="#h2-1">获取设备总内存</a></li></ul><ul><li><a href="#h2-2">memblock</a></li></ul><ul><li><a href="#h2-3">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">物理布局探测</h1><p>内存管理是 Linux 非常重要也非常复杂的一个环节, 本节我们从最基本的物理内存布局探测, 到 memblock NUMA slab 等复杂的内存管理方案做一些深入的分析</p><p>对于一个操作系统, 在启动之初有两个非常关键的问题</p><ul><li>操作系统怎样获取设备总内存大小?</li></ul><ul><li>设备的所有内存,操作系统都可以使用吗?</li></ul><h2 id="h2-1">获取设备总内存</h2><p><b>内存总大小等信息作为设备的关键信息,应该在硬件启动初期就由CPU获得并存储,操作系统只需要通过CPU的相关协定读取即可,这个协定就是BIOS中断</b></p><p>在x86芯片中,探测物理内存布局用的BIOS中断向量是0x15,<b>根据ax寄存器值的不同,有三种常见的方式:0xe820,0x801和0x88.</b></p><pre><code class="language-c">// arch/x86/boot/main.c
void main() {
    // ...
    /* Detect memory layout */
    detect_memory();
    // ...
}</code></pre><p>detect_memory 中依次执行三个 BIOS 中断向 CPU 尝试获取物理内存布局, 这三个函数内部通过 <code>boot_params</code> 将内存的信息带出来</p><blockquote><p>boot_params 由 boot.h 引入, <code>extern struct boot_params boot_params</code></p><p>struct boot_params 定义很长, 位于 arch/x86/include/uapi/asm/bootparam.h</p></blockquote><pre><code class="language-c">// arch/x86/boot/memory.c
void detect_memory(void) {
    detect_memory_e820(); /* 使用e820 BIOS中断获取物理内存布局 */
    detect_memory_e801(); /* 使用e801 BIOS中断获取物理内存布局 */
    detect_memory_88(); /* 使用88 BIOS中断获取物理内存布局 */
}</code></pre><p>其中 e820 需要设置 AX 向量号为 <code>0xe820</code>,</p><pre><code class="language-c">// arch/x86/boot/memory.c
#define SMAP    0x534d4150  /* ASCII "SMAP" */

// Input:
// AX = E820h
// EAX = 0000E820h
// EDX = 534D4150h ('SMAP')
// EBX = continuation value or 00000000h to start at beginning of map
// ECX = size of buffer for result, in bytes (should be &gt;= 20 bytes)
// ES:DI -&gt; buffer for result (see #00581)
// int 0x15
static void detect_memory_e820(void)
{
    int count = 0;
    struct biosregs ireg, oreg;
    struct boot_e820_entry *desc = boot_params.e820_table;
    static struct boot_e820_entry buf; /* static so it is zeroed */
    initregs(&ireg);
    ireg.ax  = 0xe820;
    ireg.cx  = sizeof(buf);
    ireg.edx = SMAP;
    ireg.di  = (size_t)&buf;
    /*
     * Note: at least one BIOS is known which assumes that the
     * buffer pointed to by one e820 call is the same one as
     * the previous call, and only changes modified fields.  Therefore,
     * we use a temporary buffer and copy the results entry by entry.
     *
     * This routine deliberately does not try to account for
     * ACPI 3+ extended attributes.  This is because there are
     * BIOSes in the field which report zero for the valid bit for
     * all ranges, and we don't currently make any use of the
     * other attribute bits.  Revisit this if we see the extended
     * attribute bits deployed in a meaningful way in the future.
     */
    // Ouput:
    // CF clear if successful
    // EAX = 534D4150h ('SMAP')
    // ES:DI buffer filled
    // EBX = next offset from which to copy or 00000000h if all done
    // ECX = actual length returned in bytes
    // CF set on error
    // AH = error code (86h) (see #00496 at INT 15/AH=80h)
    do {
        intcall(0x15, &ireg, &oreg);
        ireg.ebx = oreg.ebx; /* for next iteration... */
        /* BIOSes which terminate the chain with CF = 1 as opposed
           to %ebx = 0 don't always report the SMAP signature on
           the final, failing, probe. */
        if (oreg.eflags & X86_EFLAGS_CF)
            break;
        /* Some BIOSes stop returning SMAP in the middle of
           the search loop.  We don't know exactly how the BIOS
           screwed up the map at that point, we might have a
           partial map, the full map, or complete garbage, so
           just return failure. */
        if (oreg.eax != SMAP) {
            count = 0;
            break;
        }
        *desc++ = buf;
        count++;
    } while (ireg.ebx && count &lt; ARRAY_SIZE(boot_params.e820_table));
    boot_params.e820_entries = count;
}

static void detect_memory_e801(void)
{
    struct biosregs ireg, oreg;
    initregs(&ireg);
    ireg.ax = 0xe801;
    intcall(0x15, &ireg, &oreg);
    if (oreg.eflags & X86_EFLAGS_CF)
        return;
    /* Do we really need to do this? */
    if (oreg.cx || oreg.dx) {
        oreg.ax = oreg.cx;
        oreg.bx = oreg.dx;
    }
    if (oreg.ax &gt; 15*1024) {
        return; /* Bogus! */
    } else if (oreg.ax == 15*1024) {
        boot_params.alt_mem_k = (oreg.bx &lt;&lt; 6) + oreg.ax;
    } else {
        /*
         * This ignores memory above 16MB if we have a memory
         * hole there.  If someone actually finds a machine
         * with a memory hole at 16MB and no support for
         * 0E820h they should probably generate a fake e820
         * map.
         */
        boot_params.alt_mem_k = oreg.ax;
    }
}

static void detect_memory_88(void)
{
    struct biosregs ireg, oreg;
    initregs(&ireg);
    ireg.ah = 0x88;
    intcall(0x15, &ireg, &oreg);
    boot_params.screen_info.ext_mem_k = oreg.ax;
}</code></pre><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230628161738.png" alt="20230628161738"></p><ul><li>操作系统怎样获取设备总内存大小?<p>答:通过BIOS 0x15中断,常见有E820,E801和E88子中断号.</p></li></ul><ul><li>设备的所有内存,操作系统都可以使用吗?<p>答:不是的,只有内存类型为usable的才能被操作系统所使用.</p></li></ul><h2 id="h2-2">memblock</h2><p>memblock 子系统主要用于引导过程中的物理内存管理,特别是在早期的启动阶段,当内核尚未完全初始化和建立内存管理器时.一旦内核初始化完成,memblock 子系统的功能通常会被更高级的内存管理机制所取代,如 buddy allocator(伙伴系统)或 slab allocator(SLAB 系统)</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230628182631.png" alt="20230628182631"></p><p>memblock 的功能主要包括</p><ul><li>内存块的描述:memblock 维护了一个物理内存块的列表,每个内存块由起始地址和大小来描述.通过这些描述信息,内核可以了解系统中可用的物理内存块的位置和大小.</li></ul><ul><li>内存块的分配和释放:memblock 提供了函数来动态分配和释放物理内存块.内核可以使用这些函数来管理物理内存资源,例如在启动过程中分配页表,初始化内核堆栈等.</li></ul><ul><li>物理内存的管理:memblock 子系统还提供了一些函数来管理物理内存的属性和映射关系,例如设置内存块的属性(例如可读写,可执行等),查询内存块是否被保留等.</li></ul><pre><code class="language-c">/**
 * struct memblock - memblock allocator metadata
 * @bottom_up: is bottom up direction? 用于判断记录的内存是否从底部往顶部增长
 * @current_limit: physical address of the current allocation limit 当前内存管理器管理的物理地址上限
 * @memory: usable memory regions 操作系统可用内存,即E820探测物理布局时,flags为usable的内存区域
 * @reserved: reserved memory regions 在boot阶段保留的内存,包括E820探测物理布局时,flags为reserved的内存区域,boot阶段分配出去的内存区域
 */
struct memblock {
    bool bottom_up;  /* is bottom up direction? */
    phys_addr_t current_limit;
    struct memblock_type memory;
    struct memblock_type reserved;
};</code></pre><pre><code class="language-c">/**
 * struct memblock_type - collection of memory regions of certain type
 * @cnt: number of regions 记录的内存区域(memblock_region)的数量
 * @max: size of the allocated array 最多能使用的内存区域数,当预留的内存区域不足时,管理器会扩展
 * @total_size: size of all regions 所有内存区域的内存之和
 * @regions: array of regions 内存区域数组,每一项代表usable或保留的内存区域
 * @name: the memory type symbolic name 内存管理器类型的名称,例如"memory","reserved"等
 */
struct memblock_type {
    unsigned long cnt;
    unsigned long max;
    phys_addr_t total_size;
    struct memblock_region *regions;
    char *name;
};</code></pre><pre><code class="language-c">/**
 * struct memblock_region - represents a memory region
 * @base: base address of the region 内存区域的起始地址,类型为u64或u32,表示64位/32位架构的支持最大地址长度
 * @size: size of the region 内存区域的大小
 * @flags: memory region attributes 内存区域的类型表示,有四种类型:MEMBLOCK_NONE(普通内存),MEMBLOCK_HOTPLUG(可热拔插内存),MEMBLOCK_MIRROR(镜像内存),MEMBLOCK_NOMAP(非内核直接映射内存),相同类型的相邻内存,条件合适时可以被合并
 * @nid: NUMA node id 暂时略去与NUMA相关的内容
 */
struct memblock_region {
    phys_addr_t base;
    phys_addr_t size;
    enum memblock_flags flags;
#ifdef CONFIG_NUMA
    int nid;
#endif
};


/**
 * enum memblock_flags - definition of memory region attributes
 * @MEMBLOCK_NONE: no special request
 * @MEMBLOCK_HOTPLUG: memory region indicated in the firmware-provided memory
 * map during early boot as hot(un)pluggable system RAM (e.g., memory range
 * that might get hotunplugged later). With "movable_node" set on the kernel
 * commandline, try keeping this memory region hotunpluggable. Does not apply
 * to memblocks added ("hotplugged") after early boot.
 * @MEMBLOCK_MIRROR: mirrored region
 * @MEMBLOCK_NOMAP: don't add to kernel direct mapping and treat as
 * reserved in the memory map; refer to memblock_mark_nomap() description
 * for further details
 * @MEMBLOCK_DRIVER_MANAGED: memory region that is always detected and added
 * via a driver, and never indicated in the firmware-provided memory map as
 * system RAM. This corresponds to IORESOURCE_SYSRAM_DRIVER_MANAGED in the
 * kernel resource tree.
 */
enum memblock_flags {
    MEMBLOCK_NONE       = 0x0,  /* No special request */
    MEMBLOCK_HOTPLUG    = 0x1,  /* hotpluggable region */
    MEMBLOCK_MIRROR     = 0x2,  /* mirrored region */
    MEMBLOCK_NOMAP      = 0x4,  /* don't add to kernel direct mapping */
    MEMBLOCK_DRIVER_MANAGED = 0x8,  /* always detected via a driver */
};</code></pre><h2 id="h2-3">参考</h2><ul><li><a href="https://www.zhihu.com/column/c_1444822980567805952" target="_blank">深入理解Linux内存管理 专栏</a></li></ul><ul><li><a href="https://www.zhihu.com/column/c_1543333099974721536" target="_blank">Linux内存管理 专栏</a></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../linux011/README" >linux011</a><ul><li><a href="../../linux011/README" >README</a></li></ul><ul><li><a href="../../linux011/基础知识概览" >基础知识概览</a></li></ul><ul><li><a href="../../linux011/init" >init</a></li></ul><ul><li><a href="../../linux011/kernel" >kernel</a></li></ul><ul><li><a href="../../linux011/mm" >mm</a></li></ul></li></ul><ul><li><a href="../../内存管理/物理布局探测" >内存管理</a><ul><li><a href="../../内存管理/物理布局探测" >物理布局探测</a></li></ul><ul><li><a href="../../内存管理/NUMA" >NUMA</a></li></ul><ul><li><a href="../../内存管理/namespace" >namespace</a></li></ul></li></ul><ul><li><a href="../../快速开始/编译内核" >快速开始</a><ul><li><a href="../../快速开始/编译内核" >编译内核</a></li></ul><ul><li><a href="../../快速开始/调试内核" >调试内核</a></li></ul><ul><li><a href="../../快速开始/邮件订阅" >邮件订阅</a></li></ul><ul><li><a href="../../快速开始/linux目录结构" >linux目录结构</a></li></ul><ul><li><a href="../../快速开始/lfs" >lfs</a></li></ul></li></ul><ul><li><a href="../../arch/ACPI" >arch</a><ul><li><a href="../../arch/ACPI" >ACPI</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../linux011/mm","../../内存管理/NUMA","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/prism.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/check_box.js"></script>
</body>

</html>