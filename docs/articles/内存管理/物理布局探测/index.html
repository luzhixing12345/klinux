<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/json.css /><link rel='stylesheet' href=../../../css/c.css /><link rel='stylesheet' href=../../../css/shell.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/klinux.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">物理布局探测</a><ul><li><a href="#h2-1">获取设备总内存</a></li></ul><ul><li><a href="#h2-2">memblock</a></li></ul><ul><li><a href="#h2-3">总结</a></li></ul><ul><li><a href="#h2-4">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">物理布局探测</h1><p>内存管理是 Linux 非常重要也非常复杂的一个环节, 本节我们从最基本的物理内存布局探测, 到 memblock NUMA slab 等复杂的内存管理方案做一些深入的分析</p><p>对于一个操作系统, 在启动之初有两个非常关键的问题</p><ul><li>操作系统怎样获取设备总内存大小?</li></ul><ul><li>设备的所有内存,操作系统都可以使用吗?</li></ul><h2 id="h2-1">获取设备总内存</h2><p><b>内存总大小等信息作为设备的关键信息,应该在硬件启动初期就由CPU获得并存储,操作系统只需要通过CPU的相关协定读取即可,这个协定就是BIOS中断</b></p><p>在x86芯片中,探测物理内存布局用的BIOS中断向量是0x15,<b>根据ax寄存器值的不同,有三种常见的方式:0xe820,0x801和0x88.</b></p><pre class="language-c"><code><span class="Token COMMENT">// arch/x86/boot/main.c</span><span class="Token LF">
</span><span class="TypeSpecifier FunctionReturnType BaseType Keyword Token VOID">void</span><span class="TypeSpecifier FunctionReturnType BaseType Keyword Token SPACE"> </span><span class="Identifier FunctionName DirectDeclaractor Token ID">main</span><span class="DirectDeclaractor Declarator Token brace-depth-0 LPAREN">(</span><span class="DirectDeclaractor Declarator Token brace-depth-0 RPAREN">)</span><span class="DirectDeclaractor Declarator Token SPACE"> </span><span class="brace-depth-0 Function Token CompoundStatement LCURLY_BRACE">{</span><span class="Function Token CompoundStatement LF">
</span><span class="Function Token CompoundStatement SPACE">    </span><span class="Function Token CompoundStatement COMMENT">// ...</span><span class="Function Token CompoundStatement LF">
</span><span class="Function Token CompoundStatement SPACE">    </span><span class="Function Token CompoundStatement COMMENT">/* Detect memory layout */</span><span class="Function Token CompoundStatement LF">
</span><span class="Function Token CompoundStatement SPACE">    </span><span class="Identifier FunctionCall PrimaryExpression Token ID">detect_memory</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token LPAREN">(</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="ExpressionStatement Token COMMENT">// ...</span><span class="ExpressionStatement Token LF">
</span><span class="brace-depth-0 Function Token CompoundStatement RCURLY_BRACE">}</span></code></pre><p>detect_memory 中依次执行三个 BIOS 中断向 CPU 尝试获取物理内存布局, 这三个函数内部通过 <code>boot_params</code> 将内存的信息带出来</p><blockquote><p>boot_params 由 boot.h 引入, <code>extern struct boot_params boot_params</code></p><p>struct boot_params 定义很长, 位于 arch/x86/include/uapi/asm/bootparam.h</p></blockquote><pre class="language-c"><code><span class="Token COMMENT">// arch/x86/boot/memory.c</span><span class="Token LF">
</span><span class="TypeSpecifier FunctionReturnType BaseType Keyword Token VOID">void</span><span class="TypeSpecifier FunctionReturnType BaseType Keyword Token SPACE"> </span><span class="Identifier FunctionName DirectDeclaractor Token ID">detect_memory</span><span class="DirectDeclaractor Declarator Token brace-depth-0 LPAREN">(</span><span class="BaseType Keyword TypeSpecifier Token VOID">void</span><span class="DirectDeclaractor Declarator Token brace-depth-0 RPAREN">)</span><span class="DirectDeclaractor Declarator Token SPACE"> </span><span class="brace-depth-0 Function Token CompoundStatement LCURLY_BRACE">{</span><span class="Function Token CompoundStatement LF">
</span><span class="Function Token CompoundStatement SPACE">    </span><span class="Identifier FunctionCall PrimaryExpression Token ID">detect_memory_e820</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token LPAREN">(</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token SPACE"> </span><span class="ExpressionStatement Token COMMENT">/* 使用e820 BIOS中断获取物理内存布局 */</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="Identifier FunctionCall PrimaryExpression Token ID">detect_memory_e801</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token LPAREN">(</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token SPACE"> </span><span class="ExpressionStatement Token COMMENT">/* 使用e801 BIOS中断获取物理内存布局 */</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="Identifier FunctionCall PrimaryExpression Token ID">detect_memory_88</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token LPAREN">(</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token SPACE"> </span><span class="ExpressionStatement Token COMMENT">/* 使用88 BIOS中断获取物理内存布局 */</span><span class="ExpressionStatement Token LF">
</span><span class="brace-depth-0 Function Token CompoundStatement RCURLY_BRACE">}</span></code></pre><p>其中 e820 需要设置 AX 向量号为 <code>0xe820</code>,</p><pre class="language-c"><code><span class="Token COMMENT">// arch/x86/boot/memory.c</span><span class="Token LF">
</span><span class="Token HASH">#</span><span class="ControlLine Keyword Preprocess Token DEFINE">define</span><span class="ControlLine Keyword Preprocess Token SPACE"> </span><span class="Identifier ControlLine MacroDefine Token ID">SMAP</span><span class="PPtoken Token SPACE">    </span><span class="PPtoken Token NUMBER">0x534d4150</span><span class="PPtoken Token SPACE">  </span><span class="PPtoken Token COMMENT">/* ASCII &quot;SMAP&quot; */</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token COMMENT">// Input:</span><span class="Token LF">
</span><span class="Token COMMENT">// AX = E820h</span><span class="Token LF">
</span><span class="Token COMMENT">// EAX = 0000E820h</span><span class="Token LF">
</span><span class="Token COMMENT">// EDX = 534D4150h (&#x27;SMAP&#x27;)</span><span class="Token LF">
</span><span class="Token COMMENT">// EBX = continuation value or 00000000h to start at beginning of map</span><span class="Token LF">
</span><span class="Token COMMENT">// ECX = size of buffer for result, in bytes (should be &gt;= 20 bytes)</span><span class="Token LF">
</span><span class="Token COMMENT">// ES:DI -&gt; buffer for result (see #00581)</span><span class="Token LF">
</span><span class="Token COMMENT">// int 0x15</span><span class="Token LF">
</span><span class="FunctionReturnType Keyword StorageType Token STATIC">static</span><span class="FunctionReturnType Keyword StorageType Token SPACE"> </span><span class="TypeSpecifier FunctionReturnType BaseType Keyword Token VOID">void</span><span class="TypeSpecifier FunctionReturnType BaseType Keyword Token SPACE"> </span><span class="Identifier FunctionName DirectDeclaractor Token ID">detect_memory_e820</span><span class="DirectDeclaractor Declarator Token brace-depth-0 LPAREN">(</span><span class="BaseType Keyword TypeSpecifier Token VOID">void</span><span class="DirectDeclaractor Declarator Token brace-depth-0 RPAREN">)</span><span class="DirectDeclaractor Declarator Token LF">
</span><span class="brace-depth-0 Function Token CompoundStatement LCURLY_BRACE">{</span><span class="Function Token CompoundStatement LF">
</span><span class="Function Token CompoundStatement SPACE">    </span><span class="BaseType Keyword TypeSpecifier Token INT">int</span><span class="BaseType Keyword TypeSpecifier Token SPACE"> </span><span class="Identifier DirectDeclaractor Token ID">count</span><span class="Identifier DirectDeclaractor Token SPACE"> </span><span class="InitDeclarator Token ASSIGN">=</span><span class="InitDeclarator Token SPACE"> </span><span class="PrimaryExpression Token Constant NUMBER">0</span><span class="Declaration Token SEMI">;</span><span class="Declaration Token LF">
</span><span class="Declaration Token SPACE">    </span><span class="TypeSpecifier Keyword StructureType Structure Token STRUCT">struct</span><span class="TypeSpecifier Keyword StructureType Structure Token SPACE"> </span><span class="Identifier TypeSpecifier StructureClass Structure Token ID">biosregs</span><span class="Identifier TypeSpecifier StructureClass Structure Token SPACE"> </span><span class="Identifier DirectDeclaractor Token ID">ireg</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Identifier DirectDeclaractor Token ID">oreg</span><span class="Declaration Token SEMI">;</span><span class="Declaration Token LF">
</span><span class="Declaration Token SPACE">    </span><span class="TypeSpecifier Keyword StructureType Structure Token STRUCT">struct</span><span class="TypeSpecifier Keyword StructureType Structure Token SPACE"> </span><span class="Identifier TypeSpecifier StructureClass Structure Token ID">boot_e820_entry</span><span class="Identifier TypeSpecifier StructureClass Structure Token SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Identifier DirectDeclaractor Token ID">desc</span><span class="Identifier DirectDeclaractor Token SPACE"> </span><span class="InitDeclarator Token ASSIGN">=</span><span class="InitDeclarator Token SPACE"> </span><span class="Identifier PrimaryExpression Token ID">boot_params</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">e820_table</span><span class="Declaration Token SEMI">;</span><span class="Declaration Token LF">
</span><span class="Declaration Token SPACE">    </span><span class="Keyword StorageType Token STATIC">static</span><span class="Keyword StorageType Token SPACE"> </span><span class="TypeSpecifier Keyword StructureType Structure Token STRUCT">struct</span><span class="TypeSpecifier Keyword StructureType Structure Token SPACE"> </span><span class="Identifier TypeSpecifier StructureClass Structure Token ID">boot_e820_entry</span><span class="Identifier TypeSpecifier StructureClass Structure Token SPACE"> </span><span class="Identifier DirectDeclaractor Token ID">buf</span><span class="Declaration Token SEMI">;</span><span class="Declaration Token SPACE"> </span><span class="Declaration Token COMMENT">/* static so it is zeroed */</span><span class="Declaration Token LF">
</span><span class="Declaration Token SPACE">    </span><span class="Identifier FunctionCall PrimaryExpression Token ID">initregs</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token LPAREN">(</span><span class="UnaryOp UnaryExpression Token AMPERSAND">&amp;</span><span class="Identifier PrimaryExpression Token ID">ireg</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="Identifier PrimaryExpression Token ID">ireg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">ax</span><span class="Identifier Token SPACE">  </span><span class="AssignmentExpression AssignOp Token ASSIGN">=</span><span class="AssignmentExpression AssignOp Token SPACE"> </span><span class="PrimaryExpression Token Constant NUMBER">0xe820</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="Identifier PrimaryExpression Token ID">ireg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">cx</span><span class="Identifier Token SPACE">  </span><span class="AssignmentExpression AssignOp Token ASSIGN">=</span><span class="AssignmentExpression AssignOp Token SPACE"> </span><span class="Keyword UnaryExpression Token SIZEOF">sizeof</span><span class="CastExpression brace-depth-1 UnaryExpression Token LPAREN">(</span><span class="Identifier PrimaryExpression Token ID">buf</span><span class="CastExpression brace-depth-1 UnaryExpression Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="Identifier PrimaryExpression Token ID">ireg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">edx</span><span class="Identifier Token SPACE"> </span><span class="AssignmentExpression AssignOp Token ASSIGN">=</span><span class="AssignmentExpression AssignOp Token SPACE"> </span><span class="Identifier MacroDefine PrimaryExpression Token ID">SMAP</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="Identifier PrimaryExpression Token ID">ireg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">di</span><span class="Identifier Token SPACE">  </span><span class="AssignmentExpression AssignOp Token ASSIGN">=</span><span class="AssignmentExpression AssignOp Token SPACE"> </span><span class="brace-depth-1 PrimaryExpression PostfixExpression Token LPAREN">(</span><span class="Identifier PrimaryExpression Token ID">size_t</span><span class="brace-depth-1 PrimaryExpression PostfixExpression Token RPAREN">)</span><span class="ConditionalExpression Token BinaryOp AMPERSAND">&amp;</span><span class="Identifier PrimaryExpression Token ID">buf</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="ExpressionStatement Token COMMENT">/*
     * Note: at least one BIOS is known which assumes that the
     * buffer pointed to by one e820 call is the same one as
     * the previous call, and only changes modified fields.  Therefore,
     * we use a temporary buffer and copy the results entry by entry.
     *
     * This routine deliberately does not try to account for
     * ACPI 3+ extended attributes.  This is because there are
     * BIOSes in the field which report zero for the valid bit for
     * all ranges, and we don&#x27;t currently make any use of the
     * other attribute bits.  Revisit this if we see the extended
     * attribute bits deployed in a meaningful way in the future.
     */</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="ExpressionStatement Token COMMENT">// Ouput:</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="ExpressionStatement Token COMMENT">// CF clear if successful</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="ExpressionStatement Token COMMENT">// EAX = 534D4150h (&#x27;SMAP&#x27;)</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="ExpressionStatement Token COMMENT">// ES:DI buffer filled</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="ExpressionStatement Token COMMENT">// EBX = next offset from which to copy or 00000000h if all done</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="ExpressionStatement Token COMMENT">// ECX = actual length returned in bytes</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="ExpressionStatement Token COMMENT">// CF set on error</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="ExpressionStatement Token COMMENT">// AH = error code (86h) (see #00496 at INT 15/AH=80h)</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="Keyword IterationStatement Token DO">do</span><span class="Keyword IterationStatement Token SPACE"> </span><span class="brace-depth-1 IterationStatement Token CompoundStatement LCURLY_BRACE">{</span><span class="IterationStatement Token CompoundStatement LF">
</span><span class="IterationStatement Token CompoundStatement SPACE">        </span><span class="Identifier FunctionCall PrimaryExpression Token ID">intcall</span><span class="brace-depth-2 UnaryExpression PostfixExpression Token LPAREN">(</span><span class="PrimaryExpression Token Constant NUMBER">0x15</span><span class="UnaryExpression PostfixExpression Token COMMA">,</span><span class="UnaryExpression PostfixExpression Token SPACE"> </span><span class="UnaryOp UnaryExpression Token AMPERSAND">&amp;</span><span class="Identifier PrimaryExpression Token ID">ireg</span><span class="UnaryExpression PostfixExpression Token COMMA">,</span><span class="UnaryExpression PostfixExpression Token SPACE"> </span><span class="UnaryOp UnaryExpression Token AMPERSAND">&amp;</span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="brace-depth-2 UnaryExpression PostfixExpression Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">        </span><span class="Identifier PrimaryExpression Token ID">ireg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">ebx</span><span class="Identifier Token SPACE"> </span><span class="AssignmentExpression AssignOp Token ASSIGN">=</span><span class="AssignmentExpression AssignOp Token SPACE"> </span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">ebx</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token SPACE"> </span><span class="ExpressionStatement Token COMMENT">/* for next iteration... */</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">        </span><span class="ExpressionStatement Token COMMENT">/* BIOSes which terminate the chain with CF = 1 as opposed
           to %ebx = 0 don&#x27;t always report the SMAP signature on
           the final, failing, probe. */</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">        </span><span class="Keyword SelectionStatement Token IF">if</span><span class="Keyword SelectionStatement Token SPACE"> </span><span class="brace-depth-2 SelectionStatement Token LPAREN">(</span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">eflags</span><span class="Identifier Token SPACE"> </span><span class="ConditionalExpression Token BinaryOp AMPERSAND">&amp;</span><span class="ConditionalExpression Token BinaryOp SPACE"> </span><span class="Identifier MacroDefine PrimaryExpression Token ID">X86_EFLAGS_CF</span><span class="brace-depth-2 SelectionStatement Token RPAREN">)</span><span class="SelectionStatement Token LF">
</span><span class="SelectionStatement Token SPACE">            </span><span class="Keyword JumpStatement Token BREAK">break</span><span class="JumpStatement SelectionStatement Token SEMI">;</span><span class="JumpStatement SelectionStatement Token LF">
</span><span class="JumpStatement SelectionStatement Token SPACE">        </span><span class="JumpStatement SelectionStatement Token COMMENT">/* Some BIOSes stop returning SMAP in the middle of
           the search loop.  We don&#x27;t know exactly how the BIOS
           screwed up the map at that point, we might have a
           partial map, the full map, or complete garbage, so
           just return failure. */</span><span class="JumpStatement SelectionStatement Token LF">
</span><span class="JumpStatement SelectionStatement Token SPACE">        </span><span class="Keyword SelectionStatement Token IF">if</span><span class="Keyword SelectionStatement Token SPACE"> </span><span class="brace-depth-2 SelectionStatement Token LPAREN">(</span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">eax</span><span class="Identifier Token SPACE"> </span><span class="ConditionalExpression Token BinaryOp NE">!=</span><span class="ConditionalExpression Token BinaryOp SPACE"> </span><span class="Identifier MacroDefine PrimaryExpression Token ID">SMAP</span><span class="brace-depth-2 SelectionStatement Token RPAREN">)</span><span class="SelectionStatement Token SPACE"> </span><span class="brace-depth-2 SelectionStatement Token CompoundStatement LCURLY_BRACE">{</span><span class="SelectionStatement Token CompoundStatement LF">
</span><span class="SelectionStatement Token CompoundStatement SPACE">            </span><span class="Identifier PrimaryExpression Token ID">count</span><span class="Identifier PrimaryExpression Token SPACE"> </span><span class="AssignmentExpression AssignOp Token ASSIGN">=</span><span class="AssignmentExpression AssignOp Token SPACE"> </span><span class="PrimaryExpression Token Constant NUMBER">0</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">            </span><span class="Keyword JumpStatement Token BREAK">break</span><span class="JumpStatement Token SEMI">;</span><span class="JumpStatement Token LF">
</span><span class="JumpStatement Token SPACE">        </span><span class="brace-depth-2 SelectionStatement Token CompoundStatement RCURLY_BRACE">}</span><span class="SelectionStatement Token CompoundStatement LF">
</span><span class="SelectionStatement Token CompoundStatement SPACE">        </span><span class="UnaryOp UnaryExpression Token POINTER">*</span><span class="Identifier PrimaryExpression Token ID">desc</span><span class="UnaryExpression PostfixExpression Token INC">++</span><span class="UnaryExpression PostfixExpression Token SPACE"> </span><span class="AssignmentExpression AssignOp Token ASSIGN">=</span><span class="AssignmentExpression AssignOp Token SPACE"> </span><span class="Identifier PrimaryExpression Token ID">buf</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">        </span><span class="Identifier PrimaryExpression Token ID">count</span><span class="UnaryExpression PostfixExpression Token INC">++</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="brace-depth-1 IterationStatement Token CompoundStatement RCURLY_BRACE">}</span><span class="IterationStatement Token CompoundStatement SPACE"> </span><span class="Keyword IterationStatement Token WHILE">while</span><span class="Keyword IterationStatement Token SPACE"> </span><span class="brace-depth-1 IterationStatement Token LPAREN">(</span><span class="Identifier PrimaryExpression Token ID">ireg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">ebx</span><span class="Identifier Token SPACE"> </span><span class="ConditionalExpression Token BinaryOp AND">&amp;&amp;</span><span class="ConditionalExpression Token BinaryOp SPACE"> </span><span class="Identifier PrimaryExpression Token ID">count</span><span class="Identifier PrimaryExpression Token SPACE"> </span><span class="Token BinaryOp LT">&lt;</span><span class="Token BinaryOp SPACE"> </span><span class="Identifier PrimaryExpression MacroDefine FunctionCall Token ID">ARRAY_SIZE</span><span class="brace-depth-2 UnaryExpression PostfixExpression Token LPAREN">(</span><span class="Identifier PrimaryExpression Token ID">boot_params</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">e820_table</span><span class="brace-depth-2 UnaryExpression PostfixExpression Token RPAREN">)</span><span class="brace-depth-1 IterationStatement Token RPAREN">)</span><span class="IterationStatement Token SEMI">;</span><span class="IterationStatement Token LF">
</span><span class="IterationStatement Token SPACE">    </span><span class="Identifier PrimaryExpression Token ID">boot_params</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">e820_entries</span><span class="Identifier Token SPACE"> </span><span class="AssignmentExpression AssignOp Token ASSIGN">=</span><span class="AssignmentExpression AssignOp Token SPACE"> </span><span class="Identifier PrimaryExpression Token ID">count</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="brace-depth-0 Function Token CompoundStatement RCURLY_BRACE">}</span><span class="Function Token CompoundStatement LF">
</span><span class="Function Token CompoundStatement LF">
</span><span class="FunctionReturnType Keyword StorageType Token STATIC">static</span><span class="FunctionReturnType Keyword StorageType Token SPACE"> </span><span class="TypeSpecifier FunctionReturnType BaseType Keyword Token VOID">void</span><span class="TypeSpecifier FunctionReturnType BaseType Keyword Token SPACE"> </span><span class="Identifier FunctionName DirectDeclaractor Token ID">detect_memory_e801</span><span class="DirectDeclaractor Declarator Token brace-depth-0 LPAREN">(</span><span class="BaseType Keyword TypeSpecifier Token VOID">void</span><span class="DirectDeclaractor Declarator Token brace-depth-0 RPAREN">)</span><span class="DirectDeclaractor Declarator Token LF">
</span><span class="brace-depth-0 Function Token CompoundStatement LCURLY_BRACE">{</span><span class="Function Token CompoundStatement LF">
</span><span class="Function Token CompoundStatement SPACE">    </span><span class="TypeSpecifier Keyword StructureType Structure Token STRUCT">struct</span><span class="TypeSpecifier Keyword StructureType Structure Token SPACE"> </span><span class="Identifier TypeSpecifier StructureClass Structure Token ID">biosregs</span><span class="Identifier TypeSpecifier StructureClass Structure Token SPACE"> </span><span class="Identifier DirectDeclaractor Token ID">ireg</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Identifier DirectDeclaractor Token ID">oreg</span><span class="Declaration Token SEMI">;</span><span class="Declaration Token LF">
</span><span class="Declaration Token SPACE">    </span><span class="Identifier FunctionCall PrimaryExpression Token ID">initregs</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token LPAREN">(</span><span class="UnaryOp UnaryExpression Token AMPERSAND">&amp;</span><span class="Identifier PrimaryExpression Token ID">ireg</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="Identifier PrimaryExpression Token ID">ireg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">ax</span><span class="Identifier Token SPACE"> </span><span class="AssignmentExpression AssignOp Token ASSIGN">=</span><span class="AssignmentExpression AssignOp Token SPACE"> </span><span class="PrimaryExpression Token Constant NUMBER">0xe801</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="Identifier FunctionCall PrimaryExpression Token ID">intcall</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token LPAREN">(</span><span class="PrimaryExpression Token Constant NUMBER">0x15</span><span class="UnaryExpression PostfixExpression Token COMMA">,</span><span class="UnaryExpression PostfixExpression Token SPACE"> </span><span class="UnaryOp UnaryExpression Token AMPERSAND">&amp;</span><span class="Identifier PrimaryExpression Token ID">ireg</span><span class="UnaryExpression PostfixExpression Token COMMA">,</span><span class="UnaryExpression PostfixExpression Token SPACE"> </span><span class="UnaryOp UnaryExpression Token AMPERSAND">&amp;</span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="Keyword SelectionStatement Token IF">if</span><span class="Keyword SelectionStatement Token SPACE"> </span><span class="brace-depth-1 SelectionStatement Token LPAREN">(</span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">eflags</span><span class="Identifier Token SPACE"> </span><span class="ConditionalExpression Token BinaryOp AMPERSAND">&amp;</span><span class="ConditionalExpression Token BinaryOp SPACE"> </span><span class="Identifier MacroDefine PrimaryExpression Token ID">X86_EFLAGS_CF</span><span class="brace-depth-1 SelectionStatement Token RPAREN">)</span><span class="SelectionStatement Token LF">
</span><span class="SelectionStatement Token SPACE">        </span><span class="Keyword JumpStatement Token RETURN">return</span><span class="JumpStatement SelectionStatement Token SEMI">;</span><span class="JumpStatement SelectionStatement Token LF">
</span><span class="JumpStatement SelectionStatement Token SPACE">    </span><span class="JumpStatement SelectionStatement Token COMMENT">/* Do we really need to do this? */</span><span class="JumpStatement SelectionStatement Token LF">
</span><span class="JumpStatement SelectionStatement Token SPACE">    </span><span class="Keyword SelectionStatement Token IF">if</span><span class="Keyword SelectionStatement Token SPACE"> </span><span class="brace-depth-1 SelectionStatement Token LPAREN">(</span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">cx</span><span class="Identifier Token SPACE"> </span><span class="ConditionalExpression Token BinaryOp OR">||</span><span class="ConditionalExpression Token BinaryOp SPACE"> </span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">dx</span><span class="brace-depth-1 SelectionStatement Token RPAREN">)</span><span class="SelectionStatement Token SPACE"> </span><span class="brace-depth-1 SelectionStatement Token CompoundStatement LCURLY_BRACE">{</span><span class="SelectionStatement Token CompoundStatement LF">
</span><span class="SelectionStatement Token CompoundStatement SPACE">        </span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">ax</span><span class="Identifier Token SPACE"> </span><span class="AssignmentExpression AssignOp Token ASSIGN">=</span><span class="AssignmentExpression AssignOp Token SPACE"> </span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">cx</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">        </span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">bx</span><span class="Identifier Token SPACE"> </span><span class="AssignmentExpression AssignOp Token ASSIGN">=</span><span class="AssignmentExpression AssignOp Token SPACE"> </span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">dx</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="brace-depth-1 SelectionStatement Token CompoundStatement RCURLY_BRACE">}</span><span class="SelectionStatement Token CompoundStatement LF">
</span><span class="SelectionStatement Token CompoundStatement SPACE">    </span><span class="Keyword SelectionStatement Token IF">if</span><span class="Keyword SelectionStatement Token SPACE"> </span><span class="brace-depth-1 SelectionStatement Token LPAREN">(</span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">ax</span><span class="Identifier Token SPACE"> </span><span class="ConditionalExpression Token BinaryOp GT">&gt;</span><span class="ConditionalExpression Token BinaryOp SPACE"> </span><span class="PrimaryExpression Token Constant NUMBER">15</span><span class="Token BinaryOp MUL">*</span><span class="PrimaryExpression Token Constant NUMBER">1024</span><span class="brace-depth-1 SelectionStatement Token RPAREN">)</span><span class="SelectionStatement Token SPACE"> </span><span class="brace-depth-1 SelectionStatement Token CompoundStatement LCURLY_BRACE">{</span><span class="SelectionStatement Token CompoundStatement LF">
</span><span class="SelectionStatement Token CompoundStatement SPACE">        </span><span class="Keyword JumpStatement Token RETURN">return</span><span class="JumpStatement Token SEMI">;</span><span class="JumpStatement Token SPACE"> </span><span class="JumpStatement Token COMMENT">/* Bogus! */</span><span class="JumpStatement Token LF">
</span><span class="JumpStatement Token SPACE">    </span><span class="brace-depth-1 SelectionStatement Token CompoundStatement RCURLY_BRACE">}</span><span class="SelectionStatement Token CompoundStatement SPACE"> </span><span class="Keyword SelectionStatement Token ELSE">else</span><span class="Keyword SelectionStatement Token SPACE"> </span><span class="Keyword SelectionStatement Token IF">if</span><span class="Keyword SelectionStatement Token SPACE"> </span><span class="brace-depth-1 SelectionStatement Token LPAREN">(</span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">ax</span><span class="Identifier Token SPACE"> </span><span class="ConditionalExpression Token BinaryOp EQ">==</span><span class="ConditionalExpression Token BinaryOp SPACE"> </span><span class="PrimaryExpression Token Constant NUMBER">15</span><span class="Token BinaryOp MUL">*</span><span class="PrimaryExpression Token Constant NUMBER">1024</span><span class="brace-depth-1 SelectionStatement Token RPAREN">)</span><span class="SelectionStatement Token SPACE"> </span><span class="brace-depth-1 SelectionStatement Token CompoundStatement LCURLY_BRACE">{</span><span class="SelectionStatement Token CompoundStatement LF">
</span><span class="SelectionStatement Token CompoundStatement SPACE">        </span><span class="Identifier PrimaryExpression Token ID">boot_params</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">alt_mem_k</span><span class="Identifier Token SPACE"> </span><span class="AssignmentExpression AssignOp Token ASSIGN">=</span><span class="AssignmentExpression AssignOp Token SPACE"> </span><span class="brace-depth-2 PrimaryExpression PostfixExpression Token LPAREN">(</span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">bx</span><span class="Identifier Token SPACE"> </span><span class="ConditionalExpression Token BinaryOp SHL">&lt;&lt;</span><span class="ConditionalExpression Token BinaryOp SPACE"> </span><span class="PrimaryExpression Token Constant NUMBER">6</span><span class="brace-depth-2 PrimaryExpression PostfixExpression Token RPAREN">)</span><span class="PrimaryExpression PostfixExpression Token SPACE"> </span><span class="ConditionalExpression Token BinaryOp PLUS">+</span><span class="ConditionalExpression Token BinaryOp SPACE"> </span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">ax</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="brace-depth-1 SelectionStatement Token CompoundStatement RCURLY_BRACE">}</span><span class="SelectionStatement Token CompoundStatement SPACE"> </span><span class="Keyword SelectionStatement Token ELSE">else</span><span class="Keyword SelectionStatement Token SPACE"> </span><span class="brace-depth-1 SelectionStatement Token CompoundStatement LCURLY_BRACE">{</span><span class="SelectionStatement Token CompoundStatement LF">
</span><span class="SelectionStatement Token CompoundStatement SPACE">        </span><span class="SelectionStatement Token CompoundStatement COMMENT">/*
         * This ignores memory above 16MB if we have a memory
         * hole there.  If someone actually finds a machine
         * with a memory hole at 16MB and no support for
         * 0E820h they should probably generate a fake e820
         * map.
         */</span><span class="SelectionStatement Token CompoundStatement LF">
</span><span class="SelectionStatement Token CompoundStatement SPACE">        </span><span class="Identifier PrimaryExpression Token ID">boot_params</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">alt_mem_k</span><span class="Identifier Token SPACE"> </span><span class="AssignmentExpression AssignOp Token ASSIGN">=</span><span class="AssignmentExpression AssignOp Token SPACE"> </span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">ax</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="brace-depth-1 SelectionStatement Token CompoundStatement RCURLY_BRACE">}</span><span class="SelectionStatement Token CompoundStatement LF">
</span><span class="brace-depth-0 Function Token CompoundStatement RCURLY_BRACE">}</span><span class="Function Token CompoundStatement LF">
</span><span class="Function Token CompoundStatement LF">
</span><span class="FunctionReturnType Keyword StorageType Token STATIC">static</span><span class="FunctionReturnType Keyword StorageType Token SPACE"> </span><span class="TypeSpecifier FunctionReturnType BaseType Keyword Token VOID">void</span><span class="TypeSpecifier FunctionReturnType BaseType Keyword Token SPACE"> </span><span class="Identifier FunctionName DirectDeclaractor Token ID">detect_memory_88</span><span class="DirectDeclaractor Declarator Token brace-depth-0 LPAREN">(</span><span class="BaseType Keyword TypeSpecifier Token VOID">void</span><span class="DirectDeclaractor Declarator Token brace-depth-0 RPAREN">)</span><span class="DirectDeclaractor Declarator Token LF">
</span><span class="brace-depth-0 Function Token CompoundStatement LCURLY_BRACE">{</span><span class="Function Token CompoundStatement LF">
</span><span class="Function Token CompoundStatement SPACE">    </span><span class="TypeSpecifier Keyword StructureType Structure Token STRUCT">struct</span><span class="TypeSpecifier Keyword StructureType Structure Token SPACE"> </span><span class="Identifier TypeSpecifier StructureClass Structure Token ID">biosregs</span><span class="Identifier TypeSpecifier StructureClass Structure Token SPACE"> </span><span class="Identifier DirectDeclaractor Token ID">ireg</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Identifier DirectDeclaractor Token ID">oreg</span><span class="Declaration Token SEMI">;</span><span class="Declaration Token LF">
</span><span class="Declaration Token SPACE">    </span><span class="Identifier FunctionCall PrimaryExpression Token ID">initregs</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token LPAREN">(</span><span class="UnaryOp UnaryExpression Token AMPERSAND">&amp;</span><span class="Identifier PrimaryExpression Token ID">ireg</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="Identifier PrimaryExpression Token ID">ireg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">ah</span><span class="Identifier Token SPACE"> </span><span class="AssignmentExpression AssignOp Token ASSIGN">=</span><span class="AssignmentExpression AssignOp Token SPACE"> </span><span class="PrimaryExpression Token Constant NUMBER">0x88</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="Identifier FunctionCall PrimaryExpression Token ID">intcall</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token LPAREN">(</span><span class="PrimaryExpression Token Constant NUMBER">0x15</span><span class="UnaryExpression PostfixExpression Token COMMA">,</span><span class="UnaryExpression PostfixExpression Token SPACE"> </span><span class="UnaryOp UnaryExpression Token AMPERSAND">&amp;</span><span class="Identifier PrimaryExpression Token ID">ireg</span><span class="UnaryExpression PostfixExpression Token COMMA">,</span><span class="UnaryExpression PostfixExpression Token SPACE"> </span><span class="UnaryOp UnaryExpression Token AMPERSAND">&amp;</span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="brace-depth-1 UnaryExpression PostfixExpression Token RPAREN">)</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="ExpressionStatement Token SPACE">    </span><span class="Identifier PrimaryExpression Token ID">boot_params</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">screen_info</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">ext_mem_k</span><span class="Identifier Token SPACE"> </span><span class="AssignmentExpression AssignOp Token ASSIGN">=</span><span class="AssignmentExpression AssignOp Token SPACE"> </span><span class="Identifier PrimaryExpression Token ID">oreg</span><span class="UnaryExpression PostfixExpression Token DOT">.</span><span class="Identifier Token ID">ax</span><span class="ExpressionStatement Token SEMI">;</span><span class="ExpressionStatement Token LF">
</span><span class="brace-depth-0 Function Token CompoundStatement RCURLY_BRACE">}</span></code></pre><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230628161738.png" alt="20230628161738"></p><ul><li>操作系统怎样获取设备总内存大小?<p>答:通过BIOS 0x15中断,常见有E820,E801和E88子中断号.</p></li></ul><ul><li>设备的所有内存,操作系统都可以使用吗?<p>答:不是的,只有内存类型为usable的才能被操作系统所使用.</p></li></ul><h2 id="h2-2">memblock</h2><p>memblock 子系统主要用于引导过程中的物理内存管理,特别是在早期的启动阶段,当内核尚未完全初始化和建立内存管理器时.一旦内核初始化完成,memblock 子系统的功能通常会被更高级的内存管理机制所取代,如 buddy allocator(伙伴系统)或 slab allocator(SLAB 系统)</p><p><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230628182631.png" alt="20230628182631"></p><p>memblock 的功能主要包括</p><ul><li>内存块的描述:memblock 维护了一个物理内存块的列表,每个内存块由起始地址和大小来描述.通过这些描述信息,内核可以了解系统中可用的物理内存块的位置和大小.</li></ul><ul><li>内存块的分配和释放:memblock 提供了函数来动态分配和释放物理内存块.内核可以使用这些函数来管理物理内存资源,例如在启动过程中分配页表,初始化内核堆栈等.</li></ul><ul><li>物理内存的管理:memblock 子系统还提供了一些函数来管理物理内存的属性和映射关系,例如设置内存块的属性(例如可读写,可执行等),查询内存块是否被保留等.</li></ul><pre class="language-c"><code><span class="Token COMMENT">/**
 * struct memblock - memblock allocator metadata
 * @bottom_up: is bottom up direction? 用于判断记录的内存是否从底部往顶部增长
 * @current_limit: physical address of the current allocation limit 当前内存管理器管理的物理地址上限
 * @memory: usable memory regions 操作系统可用内存,即E820探测物理布局时,flags为usable的内存区域
 * @reserved: reserved memory regions 在boot阶段保留的内存,包括E820探测物理布局时,flags为reserved的内存区域,boot阶段分配出去的内存区域
 */</span><span class="Token LF">
</span><span class="TypeSpecifier Keyword StructureType Structure Token STRUCT">struct</span><span class="TypeSpecifier Keyword StructureType Structure Token SPACE"> </span><span class="Identifier TypeSpecifier StructureClass Structure Token ID">memblock</span><span class="Identifier TypeSpecifier StructureClass Structure Token SPACE"> </span><span class="Structure Token brace-depth-0 LCURLY_BRACE">{</span><span class="Structure Token LF">
</span><span class="Structure Token SPACE">    </span><span class="BaseType Keyword TypeSpecifier Token BOOL">bool</span><span class="BaseType Keyword TypeSpecifier Token SPACE"> </span><span class="Identifier DirectDeclaractor TypeSpecifier Token ID">bottom_up</span><span class="StructDeclaration Token SEMI">;</span><span class="StructDeclaration Token SPACE">  </span><span class="StructDeclaration Token COMMENT">/* is bottom up direction? */</span><span class="StructDeclaration Token LF">
</span><span class="StructDeclaration Token SPACE">    </span><span class="TypeSpecifier Keyword Token Typedefine TYPEDEF_ID">phys_addr_t</span><span class="TypeSpecifier Keyword Token Typedefine SPACE"> </span><span class="Identifier DirectDeclaractor TypeSpecifier Token ID">current_limit</span><span class="StructDeclaration Token SEMI">;</span><span class="StructDeclaration Token LF">
</span><span class="StructDeclaration Token SPACE">    </span><span class="TypeSpecifier Keyword StructureType Structure Token STRUCT">struct</span><span class="TypeSpecifier Keyword StructureType Structure Token SPACE"> </span><span class="Identifier TypeSpecifier StructureClass Structure Token ID">memblock_type</span><span class="Identifier TypeSpecifier StructureClass Structure Token SPACE"> </span><span class="Identifier DirectDeclaractor TypeSpecifier Token ID">memory</span><span class="StructDeclaration Token SEMI">;</span><span class="StructDeclaration Token LF">
</span><span class="StructDeclaration Token SPACE">    </span><span class="TypeSpecifier Keyword StructureType Structure Token STRUCT">struct</span><span class="TypeSpecifier Keyword StructureType Structure Token SPACE"> </span><span class="Identifier TypeSpecifier StructureClass Structure Token ID">memblock_type</span><span class="Identifier TypeSpecifier StructureClass Structure Token SPACE"> </span><span class="Identifier DirectDeclaractor TypeSpecifier Token ID">reserved</span><span class="StructDeclaration Token SEMI">;</span><span class="StructDeclaration Token LF">
</span><span class="Structure Token brace-depth-0 RCURLY_BRACE">}</span><span class="Declaration Token SEMI">;</span></code></pre><pre class="language-c"><code><span class="Token COMMENT">/**
 * struct memblock_type - collection of memory regions of certain type
 * @cnt: number of regions 记录的内存区域(memblock_region)的数量
 * @max: size of the allocated array 最多能使用的内存区域数,当预留的内存区域不足时,管理器会扩展
 * @total_size: size of all regions 所有内存区域的内存之和
 * @regions: array of regions 内存区域数组,每一项代表usable或保留的内存区域
 * @name: the memory type symbolic name 内存管理器类型的名称,例如&quot;memory&quot;,&quot;reserved&quot;等
 */</span><span class="Token LF">
</span><span class="TypeSpecifier Keyword StructureType Structure Token STRUCT">struct</span><span class="TypeSpecifier Keyword StructureType Structure Token SPACE"> </span><span class="Identifier TypeSpecifier StructureClass Structure Token ID">memblock_type</span><span class="Identifier TypeSpecifier StructureClass Structure Token SPACE"> </span><span class="Structure Token brace-depth-0 LCURLY_BRACE">{</span><span class="Structure Token LF">
</span><span class="Structure Token SPACE">    </span><span class="BaseType Keyword TypeSpecifier Token UNSIGNED">unsigned</span><span class="BaseType Keyword TypeSpecifier Token SPACE"> </span><span class="BaseType Keyword TypeSpecifier Token LONG">long</span><span class="BaseType Keyword TypeSpecifier Token SPACE"> </span><span class="Identifier DirectDeclaractor TypeSpecifier Token ID">cnt</span><span class="StructDeclaration Token SEMI">;</span><span class="StructDeclaration Token LF">
</span><span class="StructDeclaration Token SPACE">    </span><span class="BaseType Keyword TypeSpecifier Token UNSIGNED">unsigned</span><span class="BaseType Keyword TypeSpecifier Token SPACE"> </span><span class="BaseType Keyword TypeSpecifier Token LONG">long</span><span class="BaseType Keyword TypeSpecifier Token SPACE"> </span><span class="Identifier DirectDeclaractor TypeSpecifier Token ID">max</span><span class="StructDeclaration Token SEMI">;</span><span class="StructDeclaration Token LF">
</span><span class="StructDeclaration Token SPACE">    </span><span class="TypeSpecifier Keyword Token Typedefine TYPEDEF_ID">phys_addr_t</span><span class="TypeSpecifier Keyword Token Typedefine SPACE"> </span><span class="Identifier DirectDeclaractor TypeSpecifier Token ID">total_size</span><span class="StructDeclaration Token SEMI">;</span><span class="StructDeclaration Token LF">
</span><span class="StructDeclaration Token SPACE">    </span><span class="TypeSpecifier Keyword StructureType Structure Token STRUCT">struct</span><span class="TypeSpecifier Keyword StructureType Structure Token SPACE"> </span><span class="Identifier TypeSpecifier StructureClass Structure Token ID">memblock_region</span><span class="Identifier TypeSpecifier StructureClass Structure Token SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Identifier DirectDeclaractor TypeSpecifier Token ID">regions</span><span class="StructDeclaration Token SEMI">;</span><span class="StructDeclaration Token LF">
</span><span class="StructDeclaration Token SPACE">    </span><span class="BaseType Keyword TypeSpecifier Token CHAR">char</span><span class="BaseType Keyword TypeSpecifier Token SPACE"> </span><span class="Pointer Declarator Token POINTER">*</span><span class="Identifier DirectDeclaractor TypeSpecifier Token ID">name</span><span class="StructDeclaration Token SEMI">;</span><span class="StructDeclaration Token LF">
</span><span class="Structure Token brace-depth-0 RCURLY_BRACE">}</span><span class="Declaration Token SEMI">;</span></code></pre><pre class="language-c"><code><span class="Token COMMENT">/**
 * struct memblock_region - represents a memory region
 * @base: base address of the region 内存区域的起始地址,类型为u64或u32,表示64位/32位架构的支持最大地址长度
 * @size: size of the region 内存区域的大小
 * @flags: memory region attributes 内存区域的类型表示,有四种类型:MEMBLOCK_NONE(普通内存),MEMBLOCK_HOTPLUG(可热拔插内存),MEMBLOCK_MIRROR(镜像内存),MEMBLOCK_NOMAP(非内核直接映射内存),相同类型的相邻内存,条件合适时可以被合并
 * @nid: NUMA node id 暂时略去与NUMA相关的内容
 */</span><span class="Token LF">
</span><span class="TypeSpecifier Keyword StructureType Structure Token STRUCT">struct</span><span class="TypeSpecifier Keyword StructureType Structure Token SPACE"> </span><span class="Identifier TypeSpecifier StructureClass Structure Token ID">memblock_region</span><span class="Identifier TypeSpecifier StructureClass Structure Token SPACE"> </span><span class="Structure Token brace-depth-0 LCURLY_BRACE">{</span><span class="Structure Token LF">
</span><span class="Structure Token SPACE">    </span><span class="TypeSpecifier Keyword Token Typedefine TYPEDEF_ID">phys_addr_t</span><span class="TypeSpecifier Keyword Token Typedefine SPACE"> </span><span class="Identifier DirectDeclaractor TypeSpecifier Token ID">base</span><span class="StructDeclaration Token SEMI">;</span><span class="StructDeclaration Token LF">
</span><span class="StructDeclaration Token SPACE">    </span><span class="TypeSpecifier Keyword Token Typedefine TYPEDEF_ID">phys_addr_t</span><span class="TypeSpecifier Keyword Token Typedefine SPACE"> </span><span class="Identifier DirectDeclaractor TypeSpecifier Token ID">size</span><span class="StructDeclaration Token SEMI">;</span><span class="StructDeclaration Token LF">
</span><span class="StructDeclaration Token SPACE">    </span><span class="TypeSpecifier Keyword EnumSpecifier Token ENUM">enum</span><span class="TypeSpecifier Keyword EnumSpecifier Token SPACE"> </span><span class="Identifier TypeSpecifier EnumID EnumSpecifier Token ID">memblock_flags</span><span class="Identifier TypeSpecifier EnumID EnumSpecifier Token SPACE"> </span><span class="Identifier DirectDeclaractor TypeSpecifier Token ID">flags</span><span class="StructDeclaration Token SEMI">;</span><span class="StructDeclaration Token LF">
</span><span class="Token HASH">#</span><span class="Keyword Preprocess Token IfGroup IFDEF">ifdef</span><span class="Keyword Preprocess Token IfGroup SPACE"> </span><span class="Identifier MacroDefine Token IfGroup ID">CONFIG_NUMA</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="BaseType Keyword TypeSpecifier Token INT">int</span><span class="BaseType Keyword TypeSpecifier Token SPACE"> </span><span class="Identifier DirectDeclaractor TypeSpecifier Token ID">nid</span><span class="StructDeclaration Token SEMI">;</span><span class="StructDeclaration Token LF">
</span><span class="Token HASH">#</span><span class="EndifLine Keyword Preprocess Token ENDIF">endif</span><span class="Token LF">
</span><span class="Structure Token brace-depth-0 RCURLY_BRACE">}</span><span class="Declaration Token SEMI">;</span><span class="Declaration Token LF">
</span><span class="Declaration Token LF">
</span><span class="Declaration Token LF">
</span><span class="Declaration Token COMMENT">/**
 * enum memblock_flags - definition of memory region attributes
 * @MEMBLOCK_NONE: no special request
 * @MEMBLOCK_HOTPLUG: memory region indicated in the firmware-provided memory
 * map during early boot as hot(un)pluggable system RAM (e.g., memory range
 * that might get hotunplugged later). With &quot;movable_node&quot; set on the kernel
 * commandline, try keeping this memory region hotunpluggable. Does not apply
 * to memblocks added (&quot;hotplugged&quot;) after early boot.
 * @MEMBLOCK_MIRROR: mirrored region
 * @MEMBLOCK_NOMAP: don&#x27;t add to kernel direct mapping and treat as
 * reserved in the memory map; refer to memblock_mark_nomap() description
 * for further details
 * @MEMBLOCK_DRIVER_MANAGED: memory region that is always detected and added
 * via a driver, and never indicated in the firmware-provided memory map as
 * system RAM. This corresponds to IORESOURCE_SYSRAM_DRIVER_MANAGED in the
 * kernel resource tree.
 */</span><span class="Declaration Token LF">
</span><span class="TypeSpecifier Keyword EnumSpecifier Token ENUM">enum</span><span class="TypeSpecifier Keyword EnumSpecifier Token SPACE"> </span><span class="Identifier TypeSpecifier EnumID EnumSpecifier Token ID">memblock_flags</span><span class="Identifier TypeSpecifier EnumID EnumSpecifier Token SPACE"> </span><span class="EnumSpecifier Token brace-depth-0 LCURLY_BRACE">{</span><span class="EnumSpecifier Token LF">
</span><span class="EnumSpecifier Token SPACE">    </span><span class="Identifier TypeSpecifier Enumerator MacroDefine Token ID">MEMBLOCK_NONE</span><span class="Identifier TypeSpecifier Enumerator MacroDefine Token SPACE">       </span><span class="Enumerator Token ASSIGN">=</span><span class="Enumerator Token SPACE"> </span><span class="TypeSpecifier PrimaryExpression Token Constant NUMBER">0x0</span><span class="EnumSpecifier Token COMMA">,</span><span class="EnumSpecifier Token SPACE">  </span><span class="EnumSpecifier Token COMMENT">/* No special request */</span><span class="EnumSpecifier Token LF">
</span><span class="EnumSpecifier Token SPACE">    </span><span class="Identifier TypeSpecifier Enumerator MacroDefine Token ID">MEMBLOCK_HOTPLUG</span><span class="Identifier TypeSpecifier Enumerator MacroDefine Token SPACE">    </span><span class="Enumerator Token ASSIGN">=</span><span class="Enumerator Token SPACE"> </span><span class="TypeSpecifier PrimaryExpression Token Constant NUMBER">0x1</span><span class="EnumSpecifier Token COMMA">,</span><span class="EnumSpecifier Token SPACE">  </span><span class="EnumSpecifier Token COMMENT">/* hotpluggable region */</span><span class="EnumSpecifier Token LF">
</span><span class="EnumSpecifier Token SPACE">    </span><span class="Identifier TypeSpecifier Enumerator MacroDefine Token ID">MEMBLOCK_MIRROR</span><span class="Identifier TypeSpecifier Enumerator MacroDefine Token SPACE">     </span><span class="Enumerator Token ASSIGN">=</span><span class="Enumerator Token SPACE"> </span><span class="TypeSpecifier PrimaryExpression Token Constant NUMBER">0x2</span><span class="EnumSpecifier Token COMMA">,</span><span class="EnumSpecifier Token SPACE">  </span><span class="EnumSpecifier Token COMMENT">/* mirrored region */</span><span class="EnumSpecifier Token LF">
</span><span class="EnumSpecifier Token SPACE">    </span><span class="Identifier TypeSpecifier Enumerator MacroDefine Token ID">MEMBLOCK_NOMAP</span><span class="Identifier TypeSpecifier Enumerator MacroDefine Token SPACE">      </span><span class="Enumerator Token ASSIGN">=</span><span class="Enumerator Token SPACE"> </span><span class="TypeSpecifier PrimaryExpression Token Constant NUMBER">0x4</span><span class="EnumSpecifier Token COMMA">,</span><span class="EnumSpecifier Token SPACE">  </span><span class="EnumSpecifier Token COMMENT">/* don&#x27;t add to kernel direct mapping */</span><span class="EnumSpecifier Token LF">
</span><span class="EnumSpecifier Token SPACE">    </span><span class="Identifier TypeSpecifier Enumerator MacroDefine Token ID">MEMBLOCK_DRIVER_MANAGED</span><span class="Identifier TypeSpecifier Enumerator MacroDefine Token SPACE"> </span><span class="Enumerator Token ASSIGN">=</span><span class="Enumerator Token SPACE"> </span><span class="TypeSpecifier PrimaryExpression Token Constant NUMBER">0x8</span><span class="EnumSpecifier Token COMMA">,</span><span class="EnumSpecifier Token SPACE">  </span><span class="EnumSpecifier Token COMMENT">/* always detected via a driver */</span><span class="EnumSpecifier Token LF">
</span><span class="EnumSpecifier Token brace-depth-0 RCURLY_BRACE">}</span><span class="Declaration Token SEMI">;</span></code></pre><h2 id="h2-3">总结</h2><p>操作系统通过BIOS 0x15中断，常见有E820、E801和E88子中断号获取设备总内存大小, 内存类型为usable的才能被操作系统所使用</p><p>memblock 子系统主要用于引导过程中的物理内存管理</p><h2 id="h2-4">参考</h2><ul><li><a href="https://www.zhihu.com/column/c_1444822980567805952" target="_blank">深入理解Linux内存管理 专栏</a></li></ul><ul><li><a href="https://www.zhihu.com/column/c_1543333099974721536" target="_blank">Linux内存管理 专栏</a></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../linux011/README" >linux011</a><ul><li><a href="../../linux011/README" >README</a></li></ul><ul><li><a href="../../linux011/基础知识概览" >基础知识概览</a></li></ul><ul><li><a href="../../linux011/init" >init</a></li></ul><ul><li><a href="../../linux011/kernel" >kernel</a></li></ul><ul><li><a href="../../linux011/mm" >mm</a></li></ul></li></ul><ul><li><a href="../../内存管理/物理布局探测" >内存管理</a><ul><li><a href="../../内存管理/物理布局探测" >物理布局探测</a></li></ul><ul><li><a href="../../内存管理/NUMA" >NUMA</a></li></ul><ul><li><a href="../../内存管理/namespace" >namespace</a></li></ul></li></ul><ul><li><a href="../../快速开始/编译内核" >快速开始</a><ul><li><a href="../../快速开始/编译内核" >编译内核</a></li></ul><ul><li><a href="../../快速开始/调试内核" >调试内核</a></li></ul><ul><li><a href="../../快速开始/邮件订阅" >邮件订阅</a></li></ul><ul><li><a href="../../快速开始/linux目录结构" >linux目录结构</a></li></ul><ul><li><a href="../../快速开始/lfs" >lfs</a></li></ul></li></ul><ul><li><a href="../../arch/ACPI" >arch</a><ul><li><a href="../../arch/ACPI" >ACPI</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../linux011/mm","../../内存管理/NUMA","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>