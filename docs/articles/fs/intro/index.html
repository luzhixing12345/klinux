<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/c.css /><link rel='stylesheet' href=../../../css/json.css /><link rel='stylesheet' href=../../../css/makefile.css /><link rel='stylesheet' href=../../../css/shell.css /><link rel='stylesheet' href=../../../css/txt.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/klinux" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">intro</a><ul><li><a href="#h2-1">文件系统层</a></li></ul><ul><li><a href="#h2-2">文件系统</a></li></ul><ul><li><a href="#h2-3">目录树</a></li></ul><ul><li><a href="#h2-4">设计</a></li></ul><ul><li><a href="#h2-5">抽象</a></li></ul><ul><li><a href="#h2-6">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">intro</h1><p>在Linux系统中,磁盘设备不仅仅是一个简单的字符设备,它的操作远比基本的读写更加复杂. 磁盘是所有程序共享的, 如果单纯的将这一大片地址空间丢给应用程序, 那么它们之间的数据访问和管理将是噩梦. 因此需要以一种有序的方式访问磁盘上的数据.如果仅仅由设备驱动程序将磁盘抽象为一个可读可写的字节序列,这种抽象是不够的.因为<b>这样的抽象没有考虑到磁盘的共享特性和访问模式</b>,可能会导致应用程序之间的数据访问冲突和效率低下.</p><blockquote><p>设备驱动程序详见 <a href="../../device/driver" target="_self">driver</a></p></blockquote><p>Linux系统通过<b>文件系统</b>提供了一个更高级别的抽象来解决这个问题.文件系统管理着磁盘上的数据存储和检索,它提供了一种结构化的方式来组织数据,使得应用程序可以通过文件和目录的层次结构来访问存储在磁盘上的信息.这样,应用程序不需要直接与磁盘交互,而是通过文件系统进行操作.</p><p>文件系统还负责处理数据的缓存、权限控制、数据一致性和其他管理任务.它为应用程序提供了一个统一的接口,无论底层的物理存储设备是什么,应用程序都以相同的方式进行数据存取.这种设计不仅简化了应用程序的开发,也提高了数据访问的效率和安全性.</p><h2 id="h2-1">文件系统层</h2><p>我们的磁盘 (存储设备) 有几个很重要的访问特性</p><ol start="1"><li>以数据块 (block) 为单位访问<p>磁盘不支持随机访问,或者说随机访问的性能不如顺序访问.这是因为磁盘内部的物理特性决定了数据的读取和写入通常是按照某种顺序进行的,例如,磁盘上的磁头需要移动到正确的磁道上才能访问特定的数据块.因此,连续的数据传输通常比随机访问单个数据块更加高效</p><blockquote><p>最佳的传输模式与设备相关 (HDD v.s. SSD)</p></blockquote></li></ol><ol start="2"><li>大吞吐量<p>使用 DMA 传送数据</p></li></ol><ol start="3"><li><b>应用程序不直接访问</b><p>访问者通常是文件系统 (维护磁盘上的数据结构), 比如打开/写入文件 <code>/tmp/a.txt</code></p><p>且系统中存在大量并发的访问 (操作系统中的进程都要访问文件系统)</p></li></ol><p>Linux操作系统中实现了一个称为<b>block IO层</b>的结构,这一层在多CPU环境下工作,负责处理来自上层应用程序和文件系统的磁盘访问请求.在这个层面上,我们可以将其理解为一个中间层,<b>它接收来自上层的请求并将其转换为对磁盘的块级操作</b>.</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240408160414.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240408160414.png" alt="20240408160414"></a></p><blockquote><p>关于这一部分的详细讨论见 <a href="../vfs/intro.md" target="_blank">vfs</a></p></blockquote><p>当你想要向磁盘写入数据时,例如写入一系列的数据块(1, 2, 3, ..., 9),你的请求首先会被提交给block IO层.在这一层中,存在一个队列,它负责管理和调度所有的读写请求.block IO层的API提供了基本的读块和写块操作,同时也支持确保所有写入操作都已持久化到存储设备的功能,这通常是通过fsync系统调用实现的.</p><blockquote><pre class="language-shell"><code><span class="Token Program ID">man</span><span class="Token SPACE"> </span><span class="Token NUMBER">2</span><span class="Token SPACE"> </span><span class="Token ID">fsync</span></code></pre></blockquote><p>fsync是一个同步操作,当你认为某些数据非常重要,需要立即持久化到存储设备时,你可以使用fsync来<b>确保所有待写入的数据都被安全地存储</b>.例如,在拔出U盘之前,你可以使用fsync来确保所有缓存中的数据都被写入到U盘中.</p><p>在Linux中,除了IO调度的复杂性,对于上层应用程序和文件系统来说,它们不需要关心底层的实现细节.文件系统层和虚拟文件系统(VFS)将不同类型的请求(如读取数据块、写入数据块等)封装并提交给block IO层的队列.最终,这些请求会通过总线和磁盘接口传递给磁盘驱动程序,由驱动程序完成实际的磁盘读取和写入操作.</p><h2 id="h2-2">文件系统</h2><p>磁盘中存储几乎所有的数据, 但是字节序列并不是磁盘的好抽象, 因此文件系统的设计目标主要有两个:</p><ul><li>提供合理的 API 使多个应用程序能<b>共享数据</b></li></ul><ul><li>提供一定的<b>隔离</b>,使恶意/出错程序的伤害不能任意扩大</li></ul><p>文件系统对磁盘存储进行了虚拟化.它将大块的物理磁盘空间分割成许多较小的、可扩展的<b>虚拟磁盘</b>.磁盘 (I/O 设备) 可以看做是一个可以读/写的字节序列, 而每个虚拟磁盘也是一个可读写的字节序列,可以视为一个<b>文件</b>.这些文件可以根据需要动态地调整大小,例如,可以从4KB扩展到16KB,以适应数据存储的需求变化.</p><p>操作系统中的文件系统管理着众多的文件,每个文件都是一个独立的字节序列,即一个虚拟磁盘.用户和应用程序可以通过文件系统对这些文件进行增删改查等操作.为了便于管理和访问,需要文件系统提供<b>命名管理</b>.每个文件都有一个唯一的名称,如&quot;a.txt&quot;或&quot;bin/ls&quot;,用户可以通过这些名称来访问和管理文件, 还要给他提供文件的检索/遍历的这些功能; 文件系统还需要提供<b>数据管理</b>, 以便随机读写和调整文件大小</p><blockquote><p>文件偏移量管理</p></blockquote><h2 id="h2-3">目录树</h2><p>文件夹,通常被称为目录,是文件系统中用于组织和管理文件的一种重要结构.它为用户和应用程序提供了一种直观的方式来分类和访问文件,使得在庞大的文件集合中寻找特定文件变得简单高效.</p><blockquote><p>想象一下,如果你的所有课程资料、作业、项目等都杂乱无章地堆放在一起,想要找到某一特定课程的大作业,无疑是一项艰巨的任务.这就像是在没有分类的图书馆中寻找一本特定的书一样困难.因此,文件夹的概念应运而生,它允许我们将相关的文件组织在一起,形成一个有层次的结构,从而提高查找和管理的效率.</p></blockquote><p>文件夹的工作原理类似于我们日常生活中的分类方法.例如,你可能会将不同学科的资料分别存放在不同的文件夹中,每个学科的文件夹下又可以细分为不同的课程或项目.这样的树状结构不仅使得文件管理变得有序,而且也符合我们大脑处理信息的习惯.我们倾向于将信息按照类别和关联性进行组织.</p><p>在操作系统中,文件系统的目录结构也是基于类似的原理.例如,在Windows操作系统中,你可能会看到&quot;Program Files&quot;、&quot;Windows&quot;、&quot;Users&quot;等顶层目录,这些目录下又包含了更具体的子目录和文件.这样的结构使得用户可以快速地定位到特定的应用程序、系统文件或个人文档. Windows 下每个设备 (驱动器) 是一棵树, C:/ D:/, U盘分配给新的盘符</p><p>Linux操作系统采用了一种更为统一的文件系统结构,整个系统中只有一个根目录(<code>/</code>).这种设计简化了文件系统的层次结构,使得所有的文件和目录都在这一个统一的框架下进行管理.当然,这种设计也带来了一些操作上的挑战,比如<b>如何处理外部存储设备</b></p><p>Linux通过&quot;<b>挂载</b>&quot;(mounting)的概念来解决这个问题, 目录树的灵活性和强大的挂载机制是其文件系统管理的核心特点.即将外部存储设备&quot;挂载&quot;到文件系统的某个目录下,使其成为文件系统的一部分,从而可以像访问本地文件一样访问这些外部存储设备上的文件. 通过挂载,可以将几乎任何类型的存储设备或文件系统添加到目录树中的任何位置,从而实现对文件的高效组织和访问</p><p>我们可以将一个磁盘文件挂载到一个目录下, 也可以将一个设备挂载到一个目录</p><p>在Linux操作系统中,<code>mount</code>命令是用来将一个文件系统挂载到目录树中的特定位置的操作.这个过程是通过操作系统的文件系统管理层来实现的,而不是简单地&quot;hack&quot;目录API.以下是<code>mount</code>操作的实现逻辑:</p><ol start="1"><li><b>确定挂载点</b>:首先,需要确定文件系统将要挂载到的目录位置,即挂载点.这个位置可以是根目录<code>/</code>,也可以是文件系统中的任何其他目录.</li></ol><ol start="2"><li><b>路径解析</b>:当一个应用程序或用户尝试访问一个文件时,操作系统会通过路径解析来确定文件的确切位置.例如,用户可能会尝试打开<code>/home/username/ABC/JYY/A.txt</code>这样的路径.</li></ol><ol start="3"><li><b>挂载表查询</b>:在路径解析过程中,操作系统会参考挂载表.挂载表是操作系统维护的一个数据结构,记录了哪些文件系统被挂载到了哪些目录点.例如,使用<code>mount -l</code>命令可以查看当前系统的挂载表.</li></ol><ol start="4"><li><b>文件系统切换</b>:如果解析到的路径指向了一个挂载点,操作系统会根据挂载表中的信息,将对该路径的访问请求切换到相应的文件系统.这意味着,对于同一个目录节点,操作系统会根据挂载表中的信息,重新进行路径解析,但这次是在挂载的文件系统上下文中.</li></ol><ol start="5"><li><b>统一的目录解析代码</b>:Linux操作系统中,无论是挂载了多少个不同类型的文件系统,如NTFS、ext4、FAT32等,操作系统都有一套统一的目录解析代码来处理这些请求.这套代码能够识别挂载点,并根据挂载表中的信息,正确地将请求路由到相应的文件系统.</li></ol><blockquote><p>更多有关 mount 的讨论见 <a href="../../fs/mount" target="_self">mount</a></p></blockquote><h2 id="h2-4">设计</h2><p>相比于内存 RAM 的读写设计, 磁盘没有办法做到 1 bit 的修改. 其中一个主要的挑战是<b>读写放大</b>.例如,当用户程序仅需要修改一个文件中的一小部分数据时, 文件系统仍然需要将一整个数据块读出, 修改后再将其写入.</p><p>然而,我们也有一些有利因素.如果我们从整个操作系统的角度来考虑,而不是仅仅关注单个应用程序的单次读写操作,我们会发现<b>许多程序会持续地访问大量文件</b>.例如,浏览器在启动时会读取多个文件,而视频编辑软件在运行时也会加载许多动态链接库和数据.通过合理地组织这些数据,我们可以利用数据<b>局部性</b>原理,优化文件的存储和访问模式.这意味着,如果我们将经常一起访问的数据放置在相邻的位置,那么当一个数据被读取时,其相邻的数据也可能很快被再次访问,从而减少读写放大的影响.</p><p>此外,缓存技术是缓解读写放大的有效手段.文件系统可以将频繁访问的数据保存在内存缓存中,这样当再次访问这些数据时,就可以直接从内存中读取,而不是从磁盘.对于写操作,文件系统可以将数据先写入内存缓存,然后在合适的时机批量写入磁盘.这种方法可以将多次磁盘写入合并为一次,减少了对磁盘的I/O操作,从而有效缓解读写放大问题.</p><p>这些策略在计算机系统的基础课程中已有介绍,它们是提高计算机性能的重要技术.通过这些方法,文件系统可以更高效地管理数据,提供更好的用户体验.因此,在设计文件系统时,我们需要综合考虑这些因素,以实现高效、稳定的数据存储和访问.</p><h2 id="h2-5">抽象</h2><ul><li>open/close/(creat)</li></ul><ul><li>read/write/lseek/(tell)</li></ul><ul><li>fstat/ftruncate</li></ul><ul><li>unlink/mkdir/dup</li></ul><p>文件系统所做的事情实际上就是一个 hashmap, 完成从文件名到文件的一个映射: <code>Map&lt;string, File&gt;</code>, 其中 <code>File</code> 除了最基础的字节信息还有元数据, 如下所示</p><pre class="language-c"><code><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">File</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Structure BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Structure LF">
</span><span class="Token Structure SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">mode</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">permissions</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration SPACE"> </span><span class="Token StructDeclaration COMMENT">// 文件权限</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">uint32</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">type</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">size</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">user</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">group</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration SPACE"> </span><span class="Token StructDeclaration COMMENT">// 文件类型, 大小, 用户/组</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">timestamps</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">atime</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">mtime</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">ctime</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration SPACE"> </span><span class="Token StructDeclaration COMMENT">// 修改时间, 创建时间</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">content</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">bytes</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration SPACE"> </span><span class="Token StructDeclaration COMMENT">// 文件内容</span><span class="Token StructDeclaration LF">
</span><span class="Token Structure BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Declaration SEMI">;</span></code></pre><p>在这个系统中,&quot;inode&quot; 是一个关键的概念,它代表了文件系统中的一个节点,包含了文件的元数据,如文件大小、文件类型、权限等信息.每个 &quot;inode&quot; 都有一个唯一的标识符,确保了文件系统中的每个文件或目录都能被准确地识别和访问.这种唯一性是至关重要的,因为它允许系统有效地管理和维护文件的索引., <b>不同的文件系统可以具有相同的 inode</b>, <b>它就是一个整数</b>, 是文件系统的主键(key)</p><p>文件系统的第一步就是将文件名映射到 inode, 即 <code>file_path -&gt; inode_num</code>; 第二步是将 inode 映射到文件, 即 <code>inode_num -&gt; File</code></p><p>我们注意到第一个映射中文件名是唯一的, 但是不同的文件名可以有相同的 inode 值, 比如说 <code>dirA/dirB/..</code> 和 <code>dirA/dirC/..</code> 都指向了 <code>dirA</code>; 每一个 inode 值也都唯一对应一个文件</p><blockquote><p>除此之外 <code>dirA</code> 目录还有其下的 <code>.</code> 和来自上级目录的 <code>dirA</code> 指向它</p></blockquote><p>物理上以扇区(Sector)为概念, 逻辑上以块(Block)为概念; 物理磁盘上2010 年以前扇区大小通常是 512B, 其后新的磁盘通常来说是 4KB, 逻辑块早期是 1KB, 现在多为 4KB</p><pre class="language-c"><code><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">BlockDevice</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Structure BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Structure LF">
</span><span class="Token Structure SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">readBlock</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier LONG">long</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">n</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier VOID">void</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">buf</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">writeBlock</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier LONG">long</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">n</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword QualifyType TypeSpecifier CONST">const</span><span class="Token Keyword QualifyType TypeSpecifier SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier VOID">void</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">buf</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token Structure BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">FileSystem</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Structure BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Structure LF">
</span><span class="Token Structure SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">File</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">open</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier CHAR">char</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">filename</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">mode</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">close</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">File</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">file</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">read</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">File</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier VOID">void</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">buf</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">len</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">write</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">File</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword QualifyType TypeSpecifier CONST">const</span><span class="Token Keyword QualifyType TypeSpecifier SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier VOID">void</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">buf</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">len</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">lseek</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">File</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">offset</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">whence</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">unlink</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier CHAR">char</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">filename</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">mkdir</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier CHAR">char</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">path</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token Structure BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Declaration SEMI">;</span></code></pre><h2 id="h2-6">参考</h2><ul><li><a href="https://www.bilibili.com/video/BV1m24y1A7Fi/" target="_blank">设备驱动程序与文件系统 (Linux 设备驱动;目录管理 API) [南京大学2023操作系统-P27] (蒋炎岩)</a></li></ul><ul><li><a href="https://www.bilibili.com/video/BV1xdN411C74V/" target="_blank">FAT 和 UNIX 文件系统 (磁盘上的数据结构) [南京大学2023操作系统-P28] (蒋炎岩)</a></li></ul><ul><li><a href="https://www.bilibili.com/video/BV1jM411W7jV/" target="_blank">Linux 文件系统(一):抽象</a></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/693575325" target="_blank">【存储知识】文件系统与硬盘存储(分区、格式化、挂载、inode、软链接与硬链接)</a></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../快速开始/编译内核" >快速开始</a><ul><li><a href="../../快速开始/编译内核" >编译内核</a></li></ul><ul><li><a href="../../快速开始/调试内核" >调试内核</a></li></ul><ul><li><a href="../../快速开始/制作linux发行版" >制作linux发行版</a></li></ul><ul><li><a href="../../快速开始/邮件订阅" >邮件订阅</a></li></ul></li></ul><ul><li><a href="../../mm/物理布局探测" >mm</a><ul><li><a href="../../mm/物理布局探测" >物理布局探测</a></li></ul><ul><li><a href="../../mm/NUMA" >NUMA</a></li></ul><ul><li><a href="../../mm/buddy" >buddy</a></li></ul><ul><li><a href="../../mm/slab分配器" >slab分配器</a></li></ul><ul><li><a href="../../mm/memory compaction" >memory compaction</a></li></ul><ul><li><a href="../../mm/va-translate" >va-translate</a></li></ul><ul><li><a href="../../mm/tlb" >tlb</a></li></ul></li></ul><ul><li><a href="../../fs/storage" >fs</a><ul><li><a href="../../fs/storage" >storage</a></li></ul><ul><li><a href="../../fs/intro" >intro</a></li></ul><ul><li><a href="../../fs/mount" >mount</a></li></ul><ul><li><a href="../../fs/fhs" >fhs</a></li></ul></li></ul><ul><li><a href="../../runtime/proc" >runtime</a><ul><li><a href="../../runtime/proc" >proc</a></li></ul><ul><li><a href="../../runtime/vsdo" >vsdo</a></li></ul><ul><li><a href="../../runtime/elf_format" >elf_format</a></li></ul><ul><li><a href="../../runtime/elf_loader" >elf_loader</a></li></ul><ul><li><a href="../../runtime/ld" >ld</a></li></ul></li></ul><ul><li><a href="../../kernel/内核初始化" >kernel</a><ul><li><a href="../../kernel/内核初始化" >内核初始化</a></li></ul><ul><li><a href="../../kernel/rcu" >rcu</a></li></ul><ul><li><a href="../../kernel/工作队列" >工作队列</a></li></ul></li></ul><ul><li><a href="../../arch/cpu" >arch</a><ul><li><a href="../../arch/cpu" >cpu</a></li></ul><ul><li><a href="../../arch/cache" >cache</a></li></ul><ul><li><a href="../../arch/multicore" >multicore</a></li></ul><ul><li><a href="../../arch/cache-coherence" >cache-coherence</a></li></ul><ul><li><a href="../../arch/memory-coherence" >memory-coherence</a></li></ul><ul><li><a href="../../arch/总线" >总线</a></li></ul><ul><li><a href="../../arch/中断" >中断</a></li></ul></li></ul><ul><li><a href="../../proc/schedule" >proc</a><ul><li><a href="../../proc/schedule" >schedule</a></li></ul><ul><li><a href="../../proc/nice" >nice</a></li></ul><ul><li><a href="../../proc/manage" >manage</a></li></ul><ul><li><a href="../../proc/signal" >signal</a></li></ul><ul><li><a href="../../proc/cgroup" >cgroup</a></li></ul></li></ul><ul><li><a href="../../device/io" >device</a><ul><li><a href="../../device/io" >io</a></li></ul><ul><li><a href="../../device/disk" >disk</a></li></ul><ul><li><a href="../../device/ssd" >ssd</a></li></ul><ul><li><a href="../../device/driver" >driver</a></li></ul><ul><li><a href="../../device/io_uring" >io_uring</a></li></ul></li></ul><ul><li><a href="../../others/safety" >others</a><ul><li><a href="../../others/safety" >safety</a></li></ul><ul><li><a href="../../others/Q&A" >Q&A</a></li></ul></li></ul><ul><li><a href="../../driver/intro" >driver</a><ul><li><a href="../../driver/intro" >intro</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../fs/storage","../../fs/mount","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>