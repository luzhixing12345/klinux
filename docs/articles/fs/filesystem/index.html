<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/c.css /><link rel='stylesheet' href=../../../css/diff.css /><link rel='stylesheet' href=../../../css/json.css /><link rel='stylesheet' href=../../../css/makefile.css /><link rel='stylesheet' href=../../../css/shell.css /><link rel='stylesheet' href=../../../css/txt.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/klinux" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">文件系统</a><ul><li><a href="#h2-1">发展历史</a></li></ul><ul><li><a href="#h2-2">什么是文件系统?</a></li></ul><ul><li><a href="#h2-3">数据块(block)</a></li></ul><ul><li><a href="#h2-4">问题: 读写放大</a></li></ul><ul><li><a href="#h2-5">文件系统层</a></li></ul><ul><li><a href="#h2-6">文件系统</a></li></ul><ul><li><a href="#h2-7">目录树</a></li></ul><ul><li><a href="#h2-8">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">文件系统</h1><p>在 <a href="../../fs/storage" target="_self">存储</a> 中我们介绍了有关存储设备的发展历史, 从最开始的机械打孔, 到磁, 到闪存..., 虽然文件系统和存储设备息息相关, 但这些则更多偏向硬件差异/内部实现/优化, 并不是大多数软件开发者关注的重点. 我们知道硬件设备会通过驱动程序由操作系统内核进行统一管理, 因此本文讨论的更多是偏向操作系统内部文件系统的软件设计与实现.</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240505230502.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240505230502.png" alt="20240505230502"></a></p><h2 id="h2-1">发展历史</h2><p>早期的 Unix 文件系统简称为 FS.FS 仅包括引导块、超级块、一团 inode 和数据块.这适用于早期Unix设计的小磁盘,但随着技术的进步和磁盘的变大,在索引节点群和它们所引用的数据块之间来回移动磁头会导致<b>抖动</b>.</p><p>马歇尔·柯克·麦库西克(Marshall Kirk McKusick)当时是伯克利的研究生,他优化了 UNIX V7 FS 布局,通过发明柱面组来创建 BSD 4.2 的 Fast File System(<b>FFS</b>),柱面组将磁盘分解成更小的块,每个组都有自己的 inode 和数据块.</p><p>Linux 内核的早期开发是在 MINIX 操作系统下进行的交叉开发. 作为 Linux 的第一个文件系统, <b>Minix</b> 文件系统基本上没有错误,但在内部使用 16 位偏移量,因此最大大小限制仅为 64 MB,文件名长度限制为 14 个字符. 由于这些限制, Linux 开始着手开发可以替代的本机文件系统.</p><p>为了简化新文件系统的添加并提供通用文件 API, <a href="../../fs/vfs" target="_self">VFS</a> 被添加到 Linux 内核中.扩展文件系统 (<b>ext</b>) 于 1992 年 4 月发布,是第一个使用 VFS API 的文件系统,并包含在 Linux 版本 0.96c 中. ext 文件系统解决了 Minix 文件系统中的两个主要问题(最大分区大小和文件名长度限制为 14 个字符),并允许 2 GB 的数据和最多 255 个字符的文件名.</p><p>但 ext 保留了一些问题,例如性能不佳和缺少一些日期戳.取代 ext 的两个竞争者很快被开发出来:<b>ext2</b> 和 Xiafs. 它们有着相同的目标:提供良好的性能、合理的限制并修复 ext.最初,Xiafs 比 ext2 更稳定,但作为<b>对 MINIX 文件系统的相当简约的修改,它不太适合未来的扩展</b>. 最终的结果是,Xiafs 变化很小,而 ext2 有了很大的发展,迅速提高了稳定性和性能,并增加了扩展.ext2 经过一段时间的调整,迅速成为 Linux 的标准文件系统.从那时起,ext2 已经发展成为一个非常成熟和健壮的文件系统.</p><p>ext2 是对扩展文件系统的大修, 融合了 Berkeley Fast File System(FFS) 的许多想法. 此外 ext2 在设计时还考虑了可扩展性,在其许多磁盘数据结构中留有空间供将来的版本使用. 从那时起,ext2 一直是 VFS API 许多新扩展的测试平台.</p><p>由于ext2文件系统驱动程序不支持 2038 年之后的日期(32位整数溢出带来的<a href="https://en.wikipedia.org/wiki/Year_2038_problem" target="_blank">Y2038问题</a>), 因此如今 linux 6.9 中已经于该 <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=b960e8093e7a57de98724931d17b2fa86ff1105f" target="_blank">commit</a> 正式 <a href="https://www.phoronix.com/news/Linux-6.9-Deprecates-EXT2" target="_blank">弃用 ext2</a>, 取而代之的是可以兼容 ext2 的 ext4</p><p>ext2 的继任者 <b>ext3</b> 引入了<a href="https://en.wikipedia.org/wiki/Journaling_file_system" target="_blank">日志</a>的概念, 以提高系统突然停止时文件系统的可靠性. 虽然 ext3 的性能(速度)不如竞争对手的 Linux 文件系统(如 ext4、JFS、ReiserFS 和 XFS),但 ext3 有一个显着的优势,因为<b>它允许从 ext2 进行就地升级,而无需备份和恢复数据</b>. 由于其相对简单和更广泛的测试基础,它也被认为比其他 Linux 文件系统更安全</p><p>ext3 缺少&quot;现代&quot;文件系统功能,例如动态 inode 分配和扩展.这种情况有时可能是一个缺点,但对于<b>可恢复性</b>来说,这是一个显着的优势.文件系统元数据全部位于固定的已知位置,并且数据结构具有一定的冗余性.在重大数据损坏中,ext2 或 ext3 可能是可恢复的,而基于树的文件系统可能不可恢复</p><p>ext3 的继任者 <b>ext4</b> 最初是 ext3 的一系列向后兼容扩展, 其他 Linux 内核开发者出于稳定性的考虑,反对接受 ext3 的扩展, 并提议 fork ext3 的源代码,将其重命名为 ext4,并在那里执行所有开发,而不会影响现有的 ext3 用户. Ext4 在性能、可扩展性和可靠性方面引入了许多新的改进.最值得注意的是,ext4 支持大小为 1 EB (1024 x 1024 TB)的文件系统</p><hr><p>文件系统可以分为:</p><ul><li><b>磁盘文件系统</b>, 利用磁盘存储介质在短时间内随机寻址数据的能力.其他考虑因素包括访问最初请求的数据的速度,以及可能还会请求以下数据的预期.这允许多个用户(或进程)访问磁盘上的各种数据,而不考虑数据的顺序位置<p>例如 FAT(FAT12、FAT16、FAT32)、exFAT、NTFS、ReFS、HFS 和 HFS+、HPFS、APFS、UFS、ext2、ext3、ext4、XFS、btrfs, 绝大部分文件系统均是为磁盘设计考虑的</p></li></ul><ul><li><b>闪存文件系统</b>, 考虑了闪存设备的特殊能力、性能和限制.通常,磁盘文件系统可以使用闪存设备作为底层存储介质, 上述的大部分磁盘文件系统都可以在闪存文件系统上表现出色, 但也有单独为闪存介质特性设计的文件系统,例如 UBIFS, YAFFS, SPIFFS</li></ul><ul><li><b>磁带文件系统</b>, 磁带是顺序存储介质,其随机数据访问时间比磁盘长得多,这给通用文件系统的创建和有效管理带来了挑战, 例如 IBM 的 <a href="https://en.wikipedia.org/wiki/Linear_Tape_File_System" target="_blank">Linear Tape File System</a></li></ul><ul><li><b>数据库文件系统</b>, 与分层结构化管理不同,或者除了分层结构化管理之外,文件还按其特征(如文件类型、主题、作者或类似的丰富元数据)进行标识. 其他还有例如非常大的文件系统,由<a href="https://en.wikipedia.org/wiki/Apache_Hadoop" target="_blank">Apache Hadoop</a>和<a href="https://en.wikipedia.org/wiki/Google_File_System" target="_blank">Google File System(GFS)</a>等应用程序所体现,使用一些数据库文件系统概念</li></ul><ul><li><b>事务性文件系统</b>, 某些程序需要进行多个文件系统更改,或者如果一个或多个更改由于任何原因失败,则不进行任何更改.<p>例如,正在安装或更新软件的程序可能会写入可执行文件、库和/或配置文件.如果某些写入失败并且软件被部分安装或更新,则软件可能已损坏或无法使用.密钥系统实用程序(如命令行界面)的更新不完整可能会使整个系统处于不可用状态.</p><p>事务处理引入了原子性保证,确保事务内部的操作要么全部提交,要么事务可以中止,系统丢弃其所有部分结果.这意味着如果发生崩溃或电源故障,恢复后,存储状态将是一致的.软件将完全安装,或者失败的安装将完全回滚,但系统上不会留下不可用的部分安装.事务还提供隔离保证,这意味着在事务提交之前,事务中的操作对系统上的其他线程是隐藏的,并且系统上的干扰操作将与事务一起正确序列化.</p></li></ul><ul><li><b>网络文件系统</b>, 它充当远程文件访问协议的客户端,提供对服务器上文件的访问.使用本地接口的程序可以透明地创建、管理和访问远程联网计算机中的分层目录和文件.网络文件系统的示例包括 NFS 、AFS、SMB 协议的客户端,以及用于 FTP, SSH (sshfs)</li></ul><ul><li><b>用户态文件系统</b>, 例如 FUSE</li></ul><ul><li><b>分布式文件系统</b></li></ul><h2 id="h2-2">什么是文件系统?</h2><p>那么什么是文件呢? 对于 UNIX 来说, <b>文件就是字节</b>, 文件的内容是由用户来解释的. 任何数据都可以被视为一种文件, 文件只是数据的一种抽象表示方式</p><p>那么为了管理文件在内存/磁盘上的组织形式, 就诞生了文件系统. 抽象的来说, 文件系统是用来<b>组织</b>和<b>存储</b>计算机数据的. 它的功能类似于一个 <code>Map&lt;i, str&gt;</code>, i 为文件对应的唯一索引编号, str 对应文件内容的字节数据. 但显而易见使用唯一标识符作为 Map 的索引 key 并不是用户友好的, 因此通常需要提供一个用户友好的命名服务.</p><p>命名服务需要完成一部分工作, 例如:</p><ul><li><b>外部名字</b>到<b>内部名字</b>的地址转换(<b>名字解析</b>)</li></ul><ul><li>建立名字和对象/资源之间的关系, 一对一或者多对一</li></ul><ul><li>删除绑定</li></ul><ul><li>列举对象绑定的所有名称(反向映射) ...</li></ul><p>一般来说命名服务通常选择由用户友好的<b>字符串</b>来作为外部名字使用, 名字空间的名字管理也会遵从特定的方法,名字会有一些特定的结构,比如包含位置信息, 最常见的就是<b>层次式的命名</b>. 例如 <code>/a/x</code>和 <code>/b/c/x</code> 的文件名字都是x,但上下文不同. 名字的每个部分都由不同的上下文解释,相同的名字可以用在不同的上下文中表示不同的对象. <b>在文件系统中,上下文就是目录</b>, 如下图所示, 一个经典的层次式命名空间</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240506214350.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240506214350.png" alt="20240506214350"></a></p><p>对于文件来说, 除了最重要的文件内容之外也需要一些元数据作为额外的信息记录, 因此一个 <code>File</code> 的抽象如下</p><pre class="language-c"><code><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">File</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Structure BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Structure LF">
</span><span class="Token Structure SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">mode</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">permissions</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration SPACE"> </span><span class="Token StructDeclaration COMMENT">// 文件权限</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">uint32</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">type</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">size</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">user</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">group</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration SPACE"> </span><span class="Token StructDeclaration COMMENT">// 文件类型, 大小, 用户/组</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">timestamps</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">atime</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">mtime</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">ctime</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration SPACE"> </span><span class="Token StructDeclaration COMMENT">// 修改时间, 创建时间</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">content</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">bytes</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration SPACE"> </span><span class="Token StructDeclaration COMMENT">// 文件内容</span><span class="Token StructDeclaration LF">
</span><span class="Token Structure BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Declaration SEMI">;</span></code></pre><p>因此文件系统最核心最重要的工作就是完成<b>从文件名到文件的一个映射</b>: <code>Map&lt;string, File&gt;</code></p><ul><li>第一步就是将文件名映射到索引节点, 我们称为 inode_num, 即 <code>file_path -&gt; inode_num</code>;</li></ul><ul><li>第二步是将 inode 映射到文件, 即 <code>inode_num -&gt; File</code></li></ul><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240506221237.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240506221237.png" alt="20240506221237"></a></p><p>我们注意到第一个映射中文件名是唯一的, 但是不同的文件名可以有相同的 inode_num 值, 比如说 <code>dirA/dirB/..</code> 和 <code>dirA/dirC/..</code> 都指向了 <code>dirA</code>;</p><blockquote><p>除此之外 <code>dirA</code> 目录还有其下的 <code>.</code> 和来自上级目录的 <code>dirA</code> 指向它</p></blockquote><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240506231735.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240506231735.png" alt="20240506231735"></a></p><blockquote><p>因此一个普通目录的引用数为 <a href="https://unix.stackexchange.com/a/101536" target="_blank">2</a>; <code>/</code> 目录的 <code>.</code> 和 <code>..</code> 都指向它自己</p></blockquote><p>在这个系统中 <code>inode_num</code> 是一个非常重要的桥梁, 也是文件系统的主键(key). 大多数文件系统将其设计为 <code>uint_32</code>, 这也限制了文件系统的最大文件个数. 使用整数类型主要是为了方便利用例如红黑树的特性,可以在 O(logN) 时间内完成插入和搜索.</p><blockquote><p>这并不是必要的, 如果文件名的字符串比较特殊, 例如 TFS 中将元数据保存在文件名当中, 可以不需要两次映射; 或者所有的文件名可以组成一个紧密的前缀树, 也可以直接以文件名作为主键. 具体取决于文件系统设计之初的需求和场景</p></blockquote><p>可以用来持久化存储的存储介质有很多, 但操作系统能感知的差异大多被硬件控制器抹去了, 因此下文以当前最常用的<b>磁盘为存储设备代指</b>. 磁盘在物理上以扇区(Sector)为概念, 逻辑上以块(Block)为概念; 物理磁盘上2010 年以前扇区大小通常是 512B, 其后新的磁盘通常来说是 4KB, 逻辑块早期是 1KB, 现在多为 4KB</p><blockquote><p>时至今日仍然是 4KB, 因为最多 64 位操作系统 4 四级页表内存页面大小就是 4KB, Block size 再大反而不好</p></blockquote><p>因此我们可以为文件系统和磁盘做出如下的抽象表示, <code>FileSystem</code> 封装统一的外部接口供用户调用, <code>BlockDevice</code> 对应逻辑上磁盘, 采用线性的地址, 通过接口和 <code>FileSystem</code> 完成交互; <code>BlockDevice</code> 又最终和物理磁盘 <code>Disk</code> 完成交互, 由磁盘硬件控制器完成从逻辑地址到物理地址(LBA)的转换, 将数据读写到磁盘扇区当中.</p><pre class="language-c"><code><span class="Token COMMENT">// Physical: Logical block addressing (LBA)</span><span class="Token LF">
</span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">Disk</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Structure BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Structure LF">
</span><span class="Token Structure SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">readSector</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier LONG">long</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">n</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier VOID">void</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">buf</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">writeSector</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier LONG">long</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">n</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword QualifyType TypeSpecifier CONST">const</span><span class="Token Keyword QualifyType TypeSpecifier SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier VOID">void</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">buf</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token Structure BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Structure LF">
</span><span class="Token Structure LF">
</span><span class="Token Structure COMMENT">// Logical: Linear space of contiguous blocks</span><span class="Token Structure LF">
</span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">BlockDevice</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Structure BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Structure LF">
</span><span class="Token Structure SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">readBlock</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier LONG">long</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">n</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier VOID">void</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">buf</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">writeBlock</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier LONG">long</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">n</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword QualifyType TypeSpecifier CONST">const</span><span class="Token Keyword QualifyType TypeSpecifier SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier VOID">void</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">buf</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token Structure BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">FileSystem</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Structure BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Structure LF">
</span><span class="Token Structure SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">File</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">open</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier CHAR">char</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">filename</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">mode</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">close</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">File</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">file</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">read</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">File</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier VOID">void</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">buf</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">len</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">write</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">File</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword QualifyType TypeSpecifier CONST">const</span><span class="Token Keyword QualifyType TypeSpecifier SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier VOID">void</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">buf</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">len</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">lseek</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">File</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">offset</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">whence</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">unlink</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier CHAR">char</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">filename</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName TypeSpecifier ID">mkdir</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier CHAR">char</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">path</span><span class="Token DirectDeclaractor Declarator BraceDepth-1 RPAREN">)</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token Structure BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Declaration SEMI">;</span></code></pre><h2 id="h2-3">数据块(block)</h2><p>首先需要明晰一点, <b>扇区</b>(sector)和<b>数据块</b>(block)是两个不同的概念.</p><ul><li>扇区: <b>磁盘或光盘上磁道的细分</b>, 是硬盘的最小单位.对于大多数磁盘,每个扇区存储固定数量的用户可访问数据,传统上硬盘驱动器 (HDD) 为 512 字节,CD-ROM 和 DVD-ROM 为 2048 字节.较新的 HDD 和 SSD 使用 4096 字节 (4 KiB) 扇区,称为高级格式 (<a href="https://en.wikipedia.org/wiki/Advanced_Format" target="_blank">AF</a>)<p>第一代高级格式(4K 扇区技术)通过将存储在 8 个 512 字节扇区中的数据合并为一个长度为 4096 字节 (4 KB) 的扇区,更有效地使用存储表面介质.保留了传统 512 字节扇区架构的关键设计元素,特别是扇区开头的标识和同步标记以及扇区末尾的纠错编码 (ECC) 区域.在扇区标头和 ECC 区域之间,合并了 8 个 512 字节扇区,无需在每个单独的 512 字节数据块之间使用冗余标头区域</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240507233327.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240507233327.png" alt="20240507233327"></a></p><blockquote><p>简而言之, 可以认为现代磁盘(绝大部分)已经是 4 KB 的扇区大小了,  磁盘厂商省材料了, 进而省钱了. <del>陈旧的知识该更新了</del></p></blockquote></li></ul><ul><li>块: 也称为逻辑块,是<b>文件系统层面的概念</b>.文件系统不是按照扇区的来读数据, 而是按照是数据块来读取数据,就是说块(block)是文件系统存取数据的最小单位,一般大小是4KB(这个值可以修改,在格式化分区的时候修改)<p>BSD FFS 的作者也曾在 <a href="https://www.usenix.org/system/files/login/articles/584-mckusick.pdf" target="_blank">一篇杂志</a> 中提及, &quot;增加 block size 可以使文件系统的性能提升&quot;</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240505233657.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240505233657.png" alt="20240505233657"></a></p><p>在其<a href="https://freebsdfoundation.org/wp-content/uploads/2016/04/A-Brief-History-of-the-BSD-Fast-Filesystem.pdf" target="_blank">发展历史</a>中也可以看到 block size 的不断变化</p></li></ul><p>找到磁盘剩余空间的大小很快, 因为它保存在 super block 中, 可以在 O(1) 的时间内完成; 但是如果要数一下一个目录下的文件占了多少空间很慢, 需要遍历所有的文件</p><p>block 的分配与否记录在 bitmap 当中</p><blockquote><p>现代 CPU 可以通过多种CPU指令集来加速 bitmap 的查找, 这些指令集通常属于单指令多数据(SIMD)技术,它们可以同时对多个数据执行相同的操作,从而提高处理速度, 例如 MMX, SSE, AVX</p></blockquote><p>在一个 4KB Block 的文件系统当中, 一个非空的普通文件至少需要 4KB. 一个空的目录也需要占据至少 4KB.</p><blockquote><p>大多数文件系统的优化特例: 一个小于 60B 的符号链接可以被保存在 inode 中</p></blockquote><p>块大小对性能有一定的影响, 大块可以显著提高吞吐量, 而且元数据的占比更小; 小块可以有更高效的空间占用, 对于很多小文件来说比较合适.</p><p>也有早期的 <a href="https://dl.acm.org/doi/abs/10.1145/1113361.1113364" target="_blank">论文</a> 研究过系统中文件大小的变化规律, 整体来说文件的体积是在不断变大的, web 服务器上的小文件是很多的(很多小脚本, 小图标)</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240507233556.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240507233556.png" alt="20240507233556"></a></p><p>disk sector size &lt;= block size &lt;= memory page size (4KB), 现在都是 4KB, 算是巧合也是必然</p><p>如果块大小为 4KB, 那么对于一个 32 位的 block number (ext2)来说, 可以计算得到文件系统支持的最大容量为 <code>4KB * 2^32 = 16TB</code>, 而对于一个 48 bit 的block number(ext4) 足以支持 1EB(1024PB)</p><blockquote><p>但是因为考虑到块组(block group)的上限为 256TB, 128MB pre group, 因此需要开启 meta block group 的选项</p></blockquote><p>用一个 block 来存 bitmap, 对于 4KB 的 block 有 32K 个 bits, 因此每个组最多 32K 个 blocks, 因此每个组最多 32K x 4KB = 128MB</p><p>传统UNIX文件系统采用的ext文件系统引入了块组(block group)概念,以增强数据的<b>局部性</b>,提高硬盘驱动器(HDD)的文件读写吞吐量,减少寻道时间和距离.个人猜测,对于SSD或闪存等非机械存储介质,块组的概念可能不太重要.此外,超级块(super block)和块组描述符(group descriptor)是文件系统的关键元数据,它们不仅在文件系统级别上存在主备份,还会在其他块组中多次备份,以确保在主备份损坏时,仍能通过其他备份恢复文件系统,避免数据丢失和系统尺寸、分布信息的不可恢复性.</p><h2 id="h2-4">问题: 读写放大</h2><p>相比于内存 RAM 的读写设计, 磁盘没有办法做到 1 bit 的修改. 其中一个主要的挑战是<b>读写放大</b>.例如,当用户程序仅需要修改一个文件中的一小部分数据时, 文件系统仍然需要将一整个数据块读出, 修改后再将其写入.</p><p>然而,我们也有一些有利因素.如果我们从整个操作系统的角度来考虑,而不是仅仅关注单个应用程序的单次读写操作,我们会发现<b>许多程序会持续地访问大量文件</b>.例如,浏览器在启动时会读取多个文件,而视频编辑软件在运行时也会加载许多动态链接库和数据.通过合理地组织这些数据,我们可以利用数据<b>局部性</b>原理,优化文件的存储和访问模式.这意味着,如果我们将经常一起访问的数据放置在相邻的位置,那么当一个数据被读取时,其相邻的数据也可能很快被再次访问,从而减少读写放大的影响.</p><p>此外,缓存技术是缓解读写放大的有效手段.文件系统可以将频繁访问的数据保存在内存缓存中,这样当再次访问这些数据时,就可以直接从内存中读取,而不是从磁盘.对于写操作,文件系统可以将数据先写入内存缓存,然后在合适的时机批量写入磁盘.这种方法可以将多次磁盘写入合并为一次,减少了对磁盘的I/O操作,从而有效缓解读写放大问题.</p><p>这些策略在计算机系统的基础课程中已有介绍,它们是提高计算机性能的重要技术.通过这些方法,文件系统可以更高效地管理数据,提供更好的用户体验.因此,在设计文件系统时,我们需要综合考虑这些因素,以实现高效、稳定的数据存储和访问.</p><p>在Linux系统中,磁盘设备不仅仅是一个简单的字符设备,它的操作远比基本的读写更加复杂. 磁盘是所有程序共享的, 如果单纯的将这一大片地址空间丢给应用程序, 那么它们之间的数据访问和管理将是噩梦. 因此需要以一种有序的方式访问磁盘上的数据.如果仅仅由设备驱动程序将磁盘抽象为一个可读可写的字节序列,这种抽象是不够的.因为<b>这样的抽象没有考虑到磁盘的共享特性和访问模式</b>,可能会导致应用程序之间的数据访问冲突和效率低下.</p><h2 id="h2-5">文件系统层</h2><p>我们的磁盘 (存储设备) 有几个很重要的访问特性</p><ol start="1"><li>以数据块 (block) 为单位访问<p>磁盘不支持随机访问,或者说随机访问的性能不如顺序访问.这是因为磁盘内部的物理特性决定了数据的读取和写入通常是按照某种顺序进行的,例如,磁盘上的磁头需要移动到正确的磁道上才能访问特定的数据块.因此,连续的数据传输通常比随机访问单个数据块更加高效</p><blockquote><p>最佳的传输模式与设备相关 (HDD v.s. SSD)</p></blockquote></li></ol><ol start="2"><li>大吞吐量<p>使用 DMA 传送数据</p></li></ol><ol start="3"><li><b>应用程序不直接访问</b><p>访问者通常是文件系统 (维护磁盘上的数据结构), 比如打开/写入文件 <code>/tmp/a.txt</code></p><p>且系统中存在大量并发的访问 (操作系统中的进程都要访问文件系统)</p></li></ol><p>Linux操作系统中实现了一个称为<b>block IO层</b>的结构,这一层在多CPU环境下工作,负责处理来自上层应用程序和文件系统的磁盘访问请求.在这个层面上,我们可以将其理解为一个中间层,<b>它接收来自上层的请求并将其转换为对磁盘的块级操作</b>.</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240408160414.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240408160414.png" alt="20240408160414"></a></p><blockquote><p>关于这一部分的详细讨论见 <a href="../../fs/vfs" target="_self">vfs</a></p></blockquote><p>当你想要向磁盘写入数据时,例如写入一系列的数据块(1, 2, 3, ..., 9),你的请求首先会被提交给block IO层.在这一层中,存在一个队列,它负责管理和调度所有的读写请求.block IO层的API提供了基本的读块和写块操作,同时也支持确保所有写入操作都已持久化到存储设备的功能,这通常是通过fsync系统调用实现的.</p><blockquote><pre class="language-shell"><code><span class="Token Program ID">man</span><span class="Token SPACE"> </span><span class="Token NUMBER">2</span><span class="Token SPACE"> </span><span class="Token ID">fsync</span></code></pre></blockquote><p>fsync是一个同步操作,当你认为某些数据非常重要,需要立即持久化到存储设备时,你可以使用fsync来<b>确保所有待写入的数据都被安全地存储</b>.例如,在拔出U盘之前,你可以使用fsync来确保所有缓存中的数据都被写入到U盘中.</p><p>在Linux中,除了IO调度的复杂性,对于上层应用程序和文件系统来说,它们不需要关心底层的实现细节.文件系统层和虚拟文件系统(VFS)将不同类型的请求(如读取数据块、写入数据块等)封装并提交给block IO层的队列.最终,这些请求会通过总线和磁盘接口传递给磁盘驱动程序,由驱动程序完成实际的磁盘读取和写入操作.</p><h2 id="h2-6">文件系统</h2><p>磁盘中存储几乎所有的数据, 但是字节序列并不是磁盘的好抽象, 因此文件系统的设计目标主要有两个:</p><ul><li>提供合理的 API 使多个应用程序能<b>共享数据</b></li></ul><ul><li>提供一定的<b>隔离</b>,使恶意/出错程序的伤害不能任意扩大</li></ul><p>文件系统对磁盘存储进行了虚拟化.它将大块的物理磁盘空间分割成许多较小的、可扩展的<b>虚拟磁盘</b>.磁盘 (I/O 设备) 可以看做是一个可以读/写的字节序列, 而每个虚拟磁盘也是一个可读写的字节序列,可以视为一个<b>文件</b>.这些文件可以根据需要动态地调整大小,例如,可以从4KB扩展到16KB,以适应数据存储的需求变化.</p><p>操作系统中的文件系统管理着众多的文件,每个文件都是一个独立的字节序列,即一个虚拟磁盘.用户和应用程序可以通过文件系统对这些文件进行增删改查等操作.为了便于管理和访问,需要文件系统提供<b>命名管理</b>.每个文件都有一个唯一的名称,如&quot;a.txt&quot;或&quot;bin/ls&quot;,用户可以通过这些名称来访问和管理文件, 还要给他提供文件的检索/遍历的这些功能; 文件系统还需要提供<b>数据管理</b>, 以便随机读写和调整文件大小</p><blockquote><p>文件偏移量管理</p></blockquote><h2 id="h2-7">目录树</h2><p>文件夹,通常被称为目录,是文件系统中用于组织和管理文件的一种重要结构.它为用户和应用程序提供了一种直观的方式来分类和访问文件,使得在庞大的文件集合中寻找特定文件变得简单高效.</p><blockquote><p>想象一下,如果你的所有课程资料、作业、项目等都杂乱无章地堆放在一起,想要找到某一特定课程的大作业,无疑是一项艰巨的任务.这就像是在没有分类的图书馆中寻找一本特定的书一样困难.因此,文件夹的概念应运而生,它允许我们将相关的文件组织在一起,形成一个有层次的结构,从而提高查找和管理的效率.</p></blockquote><p>文件夹的工作原理类似于我们日常生活中的分类方法.例如,你可能会将不同学科的资料分别存放在不同的文件夹中,每个学科的文件夹下又可以细分为不同的课程或项目.这样的树状结构不仅使得文件管理变得有序,而且也符合我们大脑处理信息的习惯.我们倾向于将信息按照类别和关联性进行组织.</p><p>在操作系统中,文件系统的目录结构也是基于类似的原理.例如,在Windows操作系统中,你可能会看到&quot;Program Files&quot;、&quot;Windows&quot;、&quot;Users&quot;等顶层目录,这些目录下又包含了更具体的子目录和文件.这样的结构使得用户可以快速地定位到特定的应用程序、系统文件或个人文档. Windows 下每个设备 (驱动器) 是一棵树, C:/ D:/, U盘分配给新的盘符</p><p>Linux操作系统采用了一种更为统一的文件系统结构,整个系统中只有一个根目录(<code>/</code>).这种设计简化了文件系统的层次结构,使得所有的文件和目录都在这一个统一的框架下进行管理.当然,这种设计也带来了一些操作上的挑战,比如<b>如何处理外部存储设备</b></p><p>Linux通过&quot;<b>挂载</b>&quot;(mounting)的概念来解决这个问题, 目录树的灵活性和强大的挂载机制是其文件系统管理的核心特点.即将外部存储设备&quot;挂载&quot;到文件系统的某个目录下,使其成为文件系统的一部分,从而可以像访问本地文件一样访问这些外部存储设备上的文件. 通过挂载,可以将几乎任何类型的存储设备或文件系统添加到目录树中的任何位置,从而实现对文件的高效组织和访问</p><p>我们可以将一个磁盘文件挂载到一个目录下, 也可以将一个设备挂载到一个目录</p><p>在Linux操作系统中,<code>mount</code>命令是用来将一个文件系统挂载到目录树中的特定位置的操作.这个过程是通过操作系统的文件系统管理层来实现的,而不是简单地&quot;hack&quot;目录API.以下是<code>mount</code>操作的实现逻辑:</p><ol start="1"><li><b>确定挂载点</b>:首先,需要确定文件系统将要挂载到的目录位置,即挂载点.这个位置可以是根目录<code>/</code>,也可以是文件系统中的任何其他目录.</li></ol><ol start="2"><li><b>路径解析</b>:当一个应用程序或用户尝试访问一个文件时,操作系统会通过路径解析来确定文件的确切位置.例如,用户可能会尝试打开<code>/home/username/ABC/JYY/A.txt</code>这样的路径.</li></ol><ol start="3"><li><b>挂载表查询</b>:在路径解析过程中,操作系统会参考挂载表.挂载表是操作系统维护的一个数据结构,记录了哪些文件系统被挂载到了哪些目录点.例如,使用<code>mount -l</code>命令可以查看当前系统的挂载表.</li></ol><ol start="4"><li><b>文件系统切换</b>:如果解析到的路径指向了一个挂载点,操作系统会根据挂载表中的信息,将对该路径的访问请求切换到相应的文件系统.这意味着,对于同一个目录节点,操作系统会根据挂载表中的信息,重新进行路径解析,但这次是在挂载的文件系统上下文中.</li></ol><ol start="5"><li><b>统一的目录解析代码</b>:Linux操作系统中,无论是挂载了多少个不同类型的文件系统,如NTFS、ext4、FAT32等,操作系统都有一套统一的目录解析代码来处理这些请求.这套代码能够识别挂载点,并根据挂载表中的信息,正确地将请求路由到相应的文件系统.</li></ol><blockquote><p>更多有关 mount 的讨论见 <a href="../../fs/mount" target="_self">mount</a></p></blockquote><h2 id="h2-8">参考</h2><ul><li><a href="https://www.bilibili.com/video/BV1m24y1A7Fi/" target="_blank">设备驱动程序与文件系统 (Linux 设备驱动;目录管理 API) [南京大学2023操作系统-P27] (蒋炎岩)</a></li></ul><ul><li><a href="https://www.bilibili.com/video/BV1xdN411C74V/" target="_blank">FAT 和 UNIX 文件系统 (磁盘上的数据结构) [南京大学2023操作系统-P28] (蒋炎岩)</a></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/693575325" target="_blank">【存储知识】文件系统与硬盘存储(分区、格式化、挂载、inode、软链接与硬链接)</a></li></ul><ul><li><a href="https://en.wikipedia.org/wiki/Disk_sector" target="_blank">Disk sector</a></li></ul><ul><li><a href="https://www.bilibili.com/video/BV1jM411W7jV/" target="_blank">Linux 文件系统(一):抽象</a></li></ul><ul><li><a href="https://www.bilibili.com/video/BV11L411y785/" target="_blank">Linux 文件系统(二):磁盘</a></li></ul><ul><li><a href="https://www.bilibili.com/video/BV1QT411r738/" target="_blank">Linux 文件系统(三):分块读写</a></li></ul><ul><li>bsd ffs<ul><li><a href="https://www.youtube.com/watch?v=r5nFapl5C1s" target="_blank">FreeBSDFridays: History of the BSD Fast Filesystem</a></li></ul><ul><li><a href="https://www.youtube.com/watch?v=Lqctf-tfBX8" target="_blank">A Brief History of the BSD Fast Filesystem</a></li></ul></li></ul><ul><li>ext<ul><li><a href="https://en.wikipedia.org/wiki/Ext2" target="_blank">Ext2</a></li></ul><ul><li><a href="https://en.wikipedia.org/wiki/Unix_File_System" target="_blank">Unix File System</a></li></ul><ul><li><a href="https://en.wikipedia.org/wiki/Ext3" target="_blank">Ext3</a></li></ul></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../快速开始/编译内核" >快速开始</a><ul><li><a href="../../快速开始/编译内核" >编译内核</a></li></ul><ul><li><a href="../../快速开始/调试内核" >调试内核</a></li></ul><ul><li><a href="../../快速开始/制作linux发行版" >制作linux发行版</a></li></ul><ul><li><a href="../../快速开始/邮件订阅" >邮件订阅</a></li></ul></li></ul><ul><li><a href="../../mm/物理布局探测" >mm</a><ul><li><a href="../../mm/物理布局探测" >物理布局探测</a></li></ul><ul><li><a href="../../mm/NUMA" >NUMA</a></li></ul><ul><li><a href="../../mm/buddy" >buddy</a></li></ul><ul><li><a href="../../mm/slab分配器" >slab分配器</a></li></ul><ul><li><a href="../../mm/memory compaction" >memory compaction</a></li></ul><ul><li><a href="../../mm/va-translate" >va-translate</a></li></ul><ul><li><a href="../../mm/tlb" >tlb</a></li></ul></li></ul><ul><li><a href="../../fs/storage" >fs</a><ul><li><a href="../../fs/storage" >storage</a></li></ul><ul><li><a href="../../fs/filesystem" >filesystem</a></li></ul><ul><li><a href="../../fs/fd" >fd</a></li></ul><ul><li><a href="../../fs/inode" >inode</a></li></ul><ul><li><a href="../../fs/mount" >mount</a></li></ul><ul><li><a href="../../fs/fhs" >fhs</a></li></ul><ul><li><a href="../../fs/ext4" >ext4</a></li></ul><ul><li><a href="../../fs/vfs" >vfs</a></li></ul></li></ul><ul><li><a href="../../runtime/proc" >runtime</a><ul><li><a href="../../runtime/proc" >proc</a></li></ul><ul><li><a href="../../runtime/vsdo" >vsdo</a></li></ul><ul><li><a href="../../runtime/elf_format" >elf_format</a></li></ul><ul><li><a href="../../runtime/elf_loader" >elf_loader</a></li></ul><ul><li><a href="../../runtime/ld" >ld</a></li></ul></li></ul><ul><li><a href="../../kernel/init" >kernel</a><ul><li><a href="../../kernel/init" >init</a></li></ul><ul><li><a href="../../kernel/rcu" >rcu</a></li></ul><ul><li><a href="../../kernel/workqueue" >workqueue</a></li></ul></li></ul><ul><li><a href="../../arch/cpu" >arch</a><ul><li><a href="../../arch/cpu" >cpu</a></li></ul><ul><li><a href="../../arch/cache" >cache</a></li></ul><ul><li><a href="../../arch/multicore" >multicore</a></li></ul><ul><li><a href="../../arch/cache-coherence" >cache-coherence</a></li></ul><ul><li><a href="../../arch/memory-coherence" >memory-coherence</a></li></ul><ul><li><a href="../../arch/bus" >bus</a></li></ul><ul><li><a href="../../arch/interrupt" >interrupt</a></li></ul></li></ul><ul><li><a href="../../proc/schedule" >proc</a><ul><li><a href="../../proc/schedule" >schedule</a></li></ul><ul><li><a href="../../proc/nice" >nice</a></li></ul><ul><li><a href="../../proc/manage" >manage</a></li></ul><ul><li><a href="../../proc/signal" >signal</a></li></ul><ul><li><a href="../../proc/cgroup" >cgroup</a></li></ul><ul><li><a href="../../proc/task_struct" >task_struct</a></li></ul></li></ul><ul><li><a href="../../device/io" >device</a><ul><li><a href="../../device/io" >io</a></li></ul><ul><li><a href="../../device/disk" >disk</a></li></ul><ul><li><a href="../../device/ssd" >ssd</a></li></ul><ul><li><a href="../../device/driver" >driver</a></li></ul><ul><li><a href="../../device/io_uring" >io_uring</a></li></ul></li></ul><ul><li><a href="../../others/safety" >others</a><ul><li><a href="../../others/safety" >safety</a></li></ul><ul><li><a href="../../others/Q&A" >Q&A</a></li></ul></li></ul><ul><li><a href="../../driver/intro" >driver</a><ul><li><a href="../../driver/intro" >intro</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../fs/storage","../../fs/fd","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>