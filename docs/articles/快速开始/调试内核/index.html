<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/c.css /><link rel='stylesheet' href=../../../css/diff.css /><link rel='stylesheet' href=../../../css/json.css /><link rel='stylesheet' href=../../../css/makefile.css /><link rel='stylesheet' href=../../../css/shell.css /><link rel='stylesheet' href=../../../css/tree.css /><link rel='stylesheet' href=../../../css/txt.css /><link rel='stylesheet' href=../../../css/x86asm.css /><link rel='stylesheet' href=../../../css/yaml.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/klinux.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">调试内核</a><ul><li><a href="#h2-1">从initramfs到根文件系统</a></li></ul><ul><li><a href="#h2-2">qemu</a></li></ul><ul><li><a href="#h2-3">Busybox</a></li></ul><ul><li><a href="#h2-4">制作initramfs</a></li></ul><ul><li><a href="#h2-5">QEMU 启动</a></li></ul><ul><li><a href="#h2-6">Vscode + gdb</a></li></ul><ul><li><a href="#h2-7">生成源码标签</a></li></ul><ul><li><a href="#h2-8">总结</a></li></ul><ul><li><a href="#h2-9">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">调试内核</h1><p>本文默认读者已经通过 linux 源码编译得到内核镜像了, 即用于调试的 vmlinux 和 用于启动的 bzImage</p><h2 id="h2-1">从initramfs到根文件系统</h2><p>操作系统内核仅仅用于提供对硬件资源的管理，以及进程调度、内存管理等最基本的能力, 只有一个裸内核用户也没有办法进行任何的交互使用，所以我们起码需要一些软件环境才能够使用。</p><p>在Linux内核被加载到内存并运行后，内核进程最终需要切换到用户的进程来使用计算机，而用户进程的可执行文件一般保存在磁盘等外部存储设备上，这个存储设备也被称为 <b>linux 根文件系统</b>。</p><p>对于磁盘来说，想要读取其中的文件内容需要内核安装对应的磁盘驱动，以及对应的文件系统模块(比如ext4)，但是内核源码在编译时大部分驱动都是以模块的方式[M]编译的，而这些驱动程序保存在存储设备上（<code>/lib/modules/$(uname -r)/kernel/</code>）。那么出现了一个鸡生蛋蛋生鸡的问题，<b>要访问 / 目录就需要先加载驱动程序，但是没有驱动又没办法访问访问 /</b>。</p><blockquote style="border-left-color: #0969da; background-color: #e8f3ff;"><div style="color: #0969da;"><img class="icon-note" loading="lazy" src="../../../img/note.svg" alt="[!NOTE]"> NOTE </div><p> 在早期的linux系统中，一般只有硬盘或者软盘被用来作为linux根文件系统的存储设备，因此也就很容易把这些设备的驱动程序集成到内核中。但是现在的嵌入式系统中可能将根文件系统保存到各种存储设备上，包括scsi、sata，u-disk等等。因此把这些设备的驱动代码全部编译到内核中显然就不是很方便。</p></blockquote><p>因此我们需要initramfs, initramfs 是一个很小很精简的内存文件系统, 所有的数据和文件都保存在内存中(ramfs，掉电消失)，它包括一些基本的工具和驱动程序, 比如说 ls cat mkdir 等等, 以便在系统启动后能够挂载更完整的文件系统。initramfs 通过一个临时的内存文件系统提供了早期的用户空间,<b>可以做内核在引导过程中自己无法轻松完成的事情。</b> 比如说:</p><ul><li>挂载根分区(用于加密分区、逻辑分区和其他特殊分区)</li></ul><ul><li>提供简约的救援外壳(如果出现问题)</li></ul><ul><li>自定义启动过程(例如打印欢迎消息、启动启动等)</li></ul><ul><li>加载模块(例如第三方驱动程序)</li></ul><p>迁移到早期用户空间是必要的,<b>因为事实上查找和安装真正的根设备很复杂</b>。根分区可以跨多个设备(raid 或单独的日志)，它们可以在网络上(需要dhcp,设置特定的MAC地址,登录服务器等)，它们可以存在于可移动媒体上,具有动态分配的主要/次要数字和持续的命名问题,需要完整的 udev 实现来解决。它们可以被压缩、加密、写入时复制、环回装载、奇怪的分区等。此外内核的核心模块放置于 <code>/lib/modules/$(uname -r)/kernel/</code> 当中, 这些模块必须要根目录(/) 被挂载时才能够被读取。但是如果核心本身不具备磁盘的驱动程序时, 当然无法挂载根目录,也就没有办法取得驱动程序,因此造成两难的地步。</p><p>此外，一旦根文件系统启动出错（比如找不到/dev/sda，内核配置有问题，libc 等关键库被误删除导致等等），系统会回退到 initramfs 的状态，这个模式也被称为救援模式（rescue mode），用于在系统启动失败时还有一个可用的环境进行救火（参见<a href="../../快速开始/安装内核与救火" target="_self">安装内核和救火</a>）。</p><p>首先需要说明的是, <b>使用 initramfs 是可选的</b>。我们当然可以把驱动程序直接编译进内核（不以模块形式保存到文件），这样就可以直接挂载指定的根分区, init 系统加载其他模块并启动服务。对于一些嵌入式 linux 设备（比如路由器等）就是这么做的。只不过大部分 linux 发行版都采用的这种 initramfs 的两步启动模式。</p><ul><li>使用 initramfs 启动裸内核，完成基础的初始化工作并挂载真正的根文件系统</li></ul><ul><li>使用 switch_root 将 / 目录切换到根文件系统所在的目录，再依赖 systemd 等程序完成其他服务的启动和加载</li></ul><blockquote><p>比如 <a href="http://archive.ubuntu.com/ubuntu/dists/bionic-updates/main/installer-amd64/current/images/netboot/mini.iso" target="_blank">Ubuntu18.04 mini.iso</a> 只有 70MB, 只包含了一个图形化的 Ubuntu 安装流程, 大部分的软件包都是从网络上下载的。这种复杂性(不可避免地包括策略)在内核空间不好处理也不应该处理, 很适合在用户空间中完成相关的配置操作</p></blockquote><blockquote style="border-left-color: #1a7f37; background-color: #e5f6ea;"><div style="color: #1a7f37;"><img class="icon-tip" loading="lazy" src="../../../img/tip.svg" alt="[!TIP]"> TIP </div><p> initramfs 到根文件系统的启动演示参考视频：<a href="https://www.bilibili.com/video/BV1Yz421S7vK" target="_blank">18-Linux 操作系统 (initramfs; 最小 Linux 世界) [南京大学2024操作系统]</a></p></blockquote><blockquote style="border-left-color: #0969da; background-color: #e8f3ff;"><div style="color: #0969da;"><img class="icon-note" loading="lazy" src="../../../img/note.svg" alt="[!NOTE]"> NOTE </div><p> 参考阅读</p><ul><li><a href="https://zhuanlan.zhihu.com/p/715345004" target="_blank">一文讲清initramfs是什么</a></li></ul><ul><li><a href="https://unix.stackexchange.com/questions/122100/why-do-i-need-initramfs" target="_blank">为什么需要 initramfs</a></li></ul><ul><li><a href="https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt" target="_blank">kernel ramfs-rootfs-initramfs.txt</a></li></ul><ul><li><a href="http://www.linuxfromscratch.org/blfs/view/cvs/postlfs/initramfs.html" target="_blank">blfs initramfs</a></li></ul><ul><li><a href="https://wiki.gentoo.org/wiki/Custom_Initramfs" target="_blank">custom initramfs</a></li></ul><ul><li><a href="https://unix.stackexchange.com/a/474452" target="_blank">Why do I need initramfs?</a></li></ul><ul><li><a href="https://wiki.gentoo.org/wiki/Custom_Initramfs" target="_blank">gentoo wiki initramfs</a></li></ul></blockquote><p>下面我们来完成一个简易但是完善的 linux 启动与调试过程</p><h2 id="h2-2">qemu</h2><p>调试内核首先需要一个虚拟化的硬件模拟器, <a href="https://www.qemu.org/" target="_blank">QEMU</a> 是一个非常健壮的模拟器和仿真器, 对虚拟化技术的支持很好, 可以直接使用 apt 安装</p><pre class="language-shell"><code><span class="Token ID">sudo</span><span class="Token SPACE"> </span><span class="Token ID">apt</span><span class="Token SPACE"> </span><span class="Token ID">install</span><span class="Token SPACE"> </span><span class="Token ID">qemu</span><span class="Token SPACE"> </span><span class="Token ID">qemu-system</span><span class="Token SPACE"> </span><span class="Token ID">qemu-kvm</span></code></pre><p>也可以选择手动编译安装最新版的 qemu</p><p>从 <a href="https://www.qemu.org/download/#source" target="_blank">qemu download</a> 找到当前最新版本, 笔者目前最新版本为 9.0.1</p><pre class="language-shell"><code><span class="Token ID">sudo</span><span class="Token SPACE"> </span><span class="Token ID">apt-get</span><span class="Token SPACE"> </span><span class="Token ID">install</span><span class="Token SPACE"> </span><span class="Token ID">git</span><span class="Token SPACE"> </span><span class="Token ID">libglib2.0-dev</span><span class="Token SPACE"> </span><span class="Token ID">libfdt-dev</span><span class="Token SPACE"> </span><span class="Token ID">libpixman-1-dev</span><span class="Token SPACE"> </span><span class="Token ID">zlib1g-dev</span><span class="Token SPACE"> </span><span class="Token ID">ninja-build</span></code></pre><p>下面的 <code>--prefix</code> 为最终安装的路径, 可以选择安装安装的位置, 笔者这里直接安装在 <code>~/qemu</code> 下了</p><pre class="language-shell"><code><span class="Token ID">wget</span><span class="Token SPACE"> </span><span class="Token Url ID">https://download.qemu.org/qemu-9.0.1.tar.xz</span><span class="Token LF">
</span><span class="Token ID">tar</span><span class="Token SPACE"> </span><span class="Token ID">xvJf</span><span class="Token SPACE"> </span><span class="Token ID">qemu-9.0.1.tar.xz</span><span class="Token LF">
</span><span class="Token Keyword CD">cd</span><span class="Token SPACE"> </span><span class="Token ID">qemu-9.0.1</span><span class="Token LF">
</span><span class="Token ID">./configure</span><span class="Token SPACE"> </span><span class="Token OPTION">--prefix</span><span class="Token ASSIGN">=</span><span class="Token TILDE">~</span><span class="Token DIV">/</span><span class="Token ID">qemu</span><span class="Token SPACE"> </span><span class="Token OPTION">--enable-kvm</span><span class="Token SPACE">  </span><span class="Token OPTION">--target-list</span><span class="Token ASSIGN">=</span><span class="Token ID">x86_64-softmmu</span><span class="Token LF">
</span><span class="Token ID">make</span><span class="Token SPACE"> </span><span class="Token OPTION">-j</span><span class="Token BACKTICK">`</span><span class="Token ID">nproc</span><span class="Token BACKTICK">`</span><span class="Token LF">
</span><span class="Token ID">sudo</span><span class="Token SPACE"> </span><span class="Token ID">make</span><span class="Token SPACE"> </span><span class="Token ID">install</span></code></pre><h2 id="h2-3">Busybox</h2><p><a href="https://busybox.net/" target="_blank">BusyBox</a> 是一个轻量级的 Unix 工具箱,它集成了许多标准 Unix 工具的功能,并且可以运行在资源受限的系统上,例如嵌入式设备和网络路由器等。BusyBox 能够代替大多数标准 Unix 工具集的实现,从而减少了系统空间和资源的需求。</p><p>BusyBox 的工具集包括了数百个 Unix 工具,如 ls/cp/cat/grep/tar/gzip/awk/sed/vi/ping/telnet 等,<b>它们都被打包成一个可执行文件</b>。BusyBox 本身只有一个可执行文件,但它包含了大量的 Unix 工具,并且可以通过命令行参数来指定使用哪些工具。</p><blockquote><p>busybox 在当系统出现故障没有办法正常登录解决, 特别是在关键组件被误删或损坏时(比如误删 GLIBC), 可以找到你的根文件系统所在的分区并挂载到一个目录, 然后将准备好的 BusyBox 可执行文件复制到挂载的根文件系统中, 在 chroot 环境中,创建一些符号链接,以便 BusyBox 能够模拟常见的 UNIX 工具, 然后就可以使用 BusyBox 提供的基本工具进行系统修复（参见<a href="../../快速开始/安装内核与救火" target="_self">安装内核和救火</a>）。</p></blockquote><pre class="language-shell"><code><span class="Token ID">wget</span><span class="Token SPACE"> </span><span class="Token Url ID">https://busybox.net/downloads/busybox-1.36.0.tar.bz2</span><span class="Token LF">
</span><span class="Token ID">tar</span><span class="Token SPACE"> </span><span class="Token ID">xf</span><span class="Token SPACE"> </span><span class="Token ID">busybox-1.36.0.tar.bz2</span><span class="Token LF">
</span><span class="Token Keyword CD">cd</span><span class="Token SPACE"> </span><span class="Token ID">busybox-1.36.0/</span><span class="Token LF">
</span><span class="Token ID">make</span><span class="Token SPACE"> </span><span class="Token ID">menuconfig</span></code></pre><p>配置选项中勾选 Build Static Lib, 因为这一步只是制作一个简单的根文件系统, 此时还没有 glibc 等重要的 C 运行库, 所以没办法动态链接的运行, 暂时用静态链接将 glibc 打包进可执行文件</p><pre class="language-shell"><code><span class="Token MINUS">-</span><span class="Token REDIRECT_TO">&gt;</span><span class="Token SPACE"> </span><span class="Token ID">Settings</span><span class="Token LF">
</span><span class="Token SPACE">   </span><span class="Token MINUS">-</span><span class="Token REDIRECT_TO">&gt;</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token MUL">*</span><span class="Token BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token SPACE"> </span><span class="Token ID">Build</span><span class="Token SPACE"> </span><span class="Token ID">static</span><span class="Token SPACE"> </span><span class="Token ID">binary</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token ID">no</span><span class="Token SPACE"> </span><span class="Token ID">shared</span><span class="Token SPACE"> </span><span class="Token ID">libs</span><span class="Token BraceDepth-0 RPAREN">)</span></code></pre><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20230314191937.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230314191937.png" alt="20230314191937" class="pic-big"></a></p><blockquote><p>如果要编译 32 位的 busybox, 需要在 settings 中为 <code>CFLAGS</code> <code>LDFLAGS</code> 添加 <code>-m32</code> 选项, 并且安装 32 位编译环境</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240306183920.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240306183920.png" alt="20240306183920" class="pic-big"></a></p><pre class="language-shell"><code><span class="Token ID">sudo</span><span class="Token SPACE"> </span><span class="Token ID">apt-get</span><span class="Token SPACE"> </span><span class="Token ID">install</span><span class="Token SPACE"> </span><span class="Token ID">gcc-multilib</span></code></pre></blockquote><pre class="language-shell"><code><span class="Token ID">make</span><span class="Token SPACE"> </span><span class="Token OPTION">-j</span><span class="Token DOLLAR">$</span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token ID">nproc</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token LF">
</span><span class="Token ID">make</span><span class="Token SPACE"> </span><span class="Token ID">install</span></code></pre><blockquote style="border-left-color: #1a7f37; background-color: #e5f6ea;"><div style="color: #1a7f37;"><img class="icon-tip" loading="lazy" src="../../../img/tip.svg" alt="[!TIP]"> TIP </div><p> 如果编译时出现报错 &quot;&#x27;TC_CBQ_MAXPRIO&#x27; undeclared&quot; &quot;&#x27;TCA_CBQ_OVL_STRATEGY&#x27; undeclared&quot;</p><p>这是一个 Busybox 社区中的<a href="https://lists.busybox.net/pipermail/busybox-cvs/2024-January/041752.html" target="_blank">已知问题</a>，核心原因是 CBQ support 在 <a href="https://github.com/torvalds/linux/commit/33241dca486264193ed68167c8eeae1fb197f3df" target="_blank">commit</a> 被移除</p><p>修复这个错误只需要删除 rm networking/tc.c 后直接编译即可</p></blockquote><p>make 结束的时候会有如下的警告, 忽略即可</p><pre class="language-shell"><code><span class="Token ID">Static</span><span class="Token SPACE"> </span><span class="Token ID">linking</span><span class="Token SPACE"> </span><span class="Token ID">against</span><span class="Token SPACE"> </span><span class="Token ID">glibc</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token ID">can</span><span class="Token APOSTROPHE">&#x27;</span><span class="Token ID">t</span><span class="Token SPACE"> </span><span class="Token ID">use</span><span class="Token SPACE"> </span><span class="Token OPTION">--gc-sections</span><span class="Token LF">
</span><span class="Token ID">Trying</span><span class="Token SPACE"> </span><span class="Token ID">libraries:</span><span class="Token SPACE"> </span><span class="Token ID">crypt</span><span class="Token SPACE"> </span><span class="Token ID">m</span><span class="Token SPACE"> </span><span class="Token ID">resolv</span><span class="Token SPACE"> </span><span class="Token ID">rt</span><span class="Token LF">
</span><span class="Token SPACE"> </span><span class="Token ID">Library</span><span class="Token SPACE"> </span><span class="Token ID">crypt</span><span class="Token SPACE"> </span><span class="Token ID">is</span><span class="Token SPACE"> </span><span class="Token ID">not</span><span class="Token SPACE"> </span><span class="Token ID">needed</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token ID">excluding</span><span class="Token SPACE"> </span><span class="Token ID">it</span><span class="Token LF">
</span><span class="Token SPACE"> </span><span class="Token ID">Library</span><span class="Token SPACE"> </span><span class="Token ID">m</span><span class="Token SPACE"> </span><span class="Token ID">is</span><span class="Token SPACE"> </span><span class="Token ID">needed</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token ID">can</span><span class="Token APOSTROPHE">&#x27;</span><span class="Token ID">t</span><span class="Token SPACE"> </span><span class="Token ID">exclude</span><span class="Token SPACE"> </span><span class="Token ID">it</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token ID">yet</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token LF">
</span><span class="Token SPACE"> </span><span class="Token ID">Library</span><span class="Token SPACE"> </span><span class="Token ID">resolv</span><span class="Token SPACE"> </span><span class="Token ID">is</span><span class="Token SPACE"> </span><span class="Token ID">needed</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token ID">can</span><span class="Token APOSTROPHE">&#x27;</span><span class="Token ID">t</span><span class="Token SPACE"> </span><span class="Token ID">exclude</span><span class="Token SPACE"> </span><span class="Token ID">it</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token ID">yet</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token LF">
</span><span class="Token SPACE"> </span><span class="Token ID">Library</span><span class="Token SPACE"> </span><span class="Token ID">rt</span><span class="Token SPACE"> </span><span class="Token ID">is</span><span class="Token SPACE"> </span><span class="Token ID">not</span><span class="Token SPACE"> </span><span class="Token ID">needed</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token ID">excluding</span><span class="Token SPACE"> </span><span class="Token ID">it</span><span class="Token LF">
</span><span class="Token SPACE"> </span><span class="Token ID">Library</span><span class="Token SPACE"> </span><span class="Token ID">m</span><span class="Token SPACE"> </span><span class="Token ID">is</span><span class="Token SPACE"> </span><span class="Token ID">needed</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token ID">can</span><span class="Token APOSTROPHE">&#x27;</span><span class="Token ID">t</span><span class="Token SPACE"> </span><span class="Token ID">exclude</span><span class="Token SPACE"> </span><span class="Token ID">it</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token ID">yet</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token LF">
</span><span class="Token SPACE"> </span><span class="Token ID">Library</span><span class="Token SPACE"> </span><span class="Token ID">resolv</span><span class="Token SPACE"> </span><span class="Token ID">is</span><span class="Token SPACE"> </span><span class="Token ID">needed</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token ID">can</span><span class="Token APOSTROPHE">&#x27;</span><span class="Token ID">t</span><span class="Token SPACE"> </span><span class="Token ID">exclude</span><span class="Token SPACE"> </span><span class="Token ID">it</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token ID">yet</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token LF">
</span><span class="Token ID">Final</span><span class="Token SPACE"> </span><span class="Token ID">link</span><span class="Token SPACE"> </span><span class="Token ID">with:</span><span class="Token SPACE"> </span><span class="Token ID">m</span><span class="Token SPACE"> </span><span class="Token ID">resolv</span></code></pre><p>编译得到的可执行文件保存在 <code>_install/</code> 目录下, 我们可以进入这个目录的bin文件夹下使用 <code>ll</code> 看到一个busybox可执行文件和众多链接文件, 这个 busybox 就是之后需要使用的工具</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20230314192159.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230314192159.png" alt="20230314192159" class="pic-big"></a></p><h2 id="h2-4">制作initramfs</h2><p>新建一个文件夹(workspace)用于后续的工作区</p><pre class="language-shell"><code><span class="Token ID">mkdir</span><span class="Token SPACE"> </span><span class="Token ID">workspace</span><span class="Token LF">
</span><span class="Token Keyword CD">cd</span><span class="Token SPACE"> </span><span class="Token ID">workspace</span></code></pre><p>创建一些文件内容初始化</p><pre class="language-shell"><code><span class="Token ID">touch</span><span class="Token SPACE"> </span><span class="Token ID">Makefile</span><span class="Token LF">
</span><span class="Token ID">mkdir</span><span class="Token SPACE"> </span><span class="Token OPTION">-p</span><span class="Token SPACE"> </span><span class="Token ID">initramfs/bin</span><span class="Token LF">
</span><span class="Token ID">touch</span><span class="Token SPACE"> </span><span class="Token ID">initramfs/init</span><span class="Token LF">
</span><span class="Token ID">chmod</span><span class="Token SPACE"> </span><span class="Token PLUS">+</span><span class="Token ID">x</span><span class="Token SPACE"> </span><span class="Token ID">initramfs/init</span></code></pre><p>然后将 <code>_install/bin/busybox</code> 拷贝到 bin/ 目录下，将 <code>arch/x86_64/boot/bzImage</code> 拷贝到 workspace 下，此时的目录结构:</p><pre class="language-tree"><code><span class="Token Dir ID">.</span><span class="Token LF">
</span><span class="Token TEXT">├</span><span class="Token TEXT">─</span><span class="Token TEXT">─</span><span class="Token SPACE"> </span><span class="Token File ID">Makefile</span><span class="Token LF">
</span><span class="Token TEXT">├</span><span class="Token TEXT">─</span><span class="Token TEXT">─</span><span class="Token SPACE"> </span><span class="Token File ID">bzImage</span><span class="Token LF">
</span><span class="Token TEXT">├</span><span class="Token TEXT">─</span><span class="Token TEXT">─</span><span class="Token SPACE"> </span><span class="Token Dir ID">initramfs</span><span class="Token LF">
</span><span class="Token TEXT">│</span><span class="Token TEXT"> </span><span class="Token TEXT"> </span><span class="Token SPACE"> </span><span class="Token TEXT">├</span><span class="Token TEXT">─</span><span class="Token TEXT">─</span><span class="Token SPACE"> </span><span class="Token Dir ID">bin</span><span class="Token LF">
</span><span class="Token TEXT">│</span><span class="Token TEXT"> </span><span class="Token TEXT"> </span><span class="Token SPACE"> </span><span class="Token TEXT">│</span><span class="Token TEXT"> </span><span class="Token TEXT"> </span><span class="Token SPACE"> </span><span class="Token TEXT">└</span><span class="Token TEXT">─</span><span class="Token TEXT">─</span><span class="Token SPACE"> </span><span class="Token File ID">busybox</span><span class="Token LF">
</span><span class="Token TEXT">│</span><span class="Token TEXT"> </span><span class="Token TEXT"> </span><span class="Token SPACE"> </span><span class="Token TEXT">└</span><span class="Token TEXT">─</span><span class="Token TEXT">─</span><span class="Token SPACE"> </span><span class="Token File ID">init</span></code></pre><p>在 initramfs/ 中新建 <code>init</code> 文件用于启动, 将下面的内容复制到init中, 它的作用是设置一些基本的环境和挂载文件系统,并最终执行一个shell, 以便于在引导过程中提供一个临时的操作环境,以便进行一些必要的操作或调试</p><pre class="language-shell"><code><span class="Token COMMENT">#!/bin/busybox sh</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token COMMENT"># initrd, only busybox and /init</span><span class="Token LF">
</span><span class="Token ID">BB</span><span class="Token ASSIGN">=</span><span class="Token DIV">/</span><span class="Token ID">bin/busybox</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token DOLLAR">$</span><span class="Token ID">BB</span><span class="Token SPACE"> </span><span class="Token OPTION">--install</span><span class="Token SPACE"> </span><span class="Token OPTION">-s</span><span class="Token SPACE"> </span><span class="Token DIV">/</span><span class="Token ID">bin</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token ID">mkdir</span><span class="Token SPACE"> </span><span class="Token OPTION">-p</span><span class="Token SPACE"> </span><span class="Token ID">dev</span><span class="Token SPACE"> </span><span class="Token ID">etc</span><span class="Token SPACE"> </span><span class="Token ID">lib</span><span class="Token SPACE"> </span><span class="Token ID">mnt</span><span class="Token SPACE"> </span><span class="Token ID">proc</span><span class="Token SPACE"> </span><span class="Token ID">sbin</span><span class="Token SPACE"> </span><span class="Token ID">sys</span><span class="Token SPACE"> </span><span class="Token ID">tmp</span><span class="Token SPACE"> </span><span class="Token ID">var</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token ID">mount</span><span class="Token SPACE"> </span><span class="Token OPTION">-t</span><span class="Token SPACE"> </span><span class="Token ID">devtmpfs</span><span class="Token SPACE">  </span><span class="Token ID">devtmpfs</span><span class="Token SPACE">  </span><span class="Token DIV">/</span><span class="Token ID">dev</span><span class="Token LF">
</span><span class="Token ID">mount</span><span class="Token SPACE"> </span><span class="Token OPTION">-t</span><span class="Token SPACE"> </span><span class="Token ID">proc</span><span class="Token SPACE">      </span><span class="Token ID">proc</span><span class="Token SPACE">      </span><span class="Token DIV">/</span><span class="Token ID">proc</span><span class="Token LF">
</span><span class="Token ID">mount</span><span class="Token SPACE"> </span><span class="Token OPTION">-t</span><span class="Token SPACE"> </span><span class="Token ID">sysfs</span><span class="Token SPACE">     </span><span class="Token ID">sysfs</span><span class="Token SPACE">     </span><span class="Token DIV">/</span><span class="Token ID">sys</span><span class="Token LF">
</span><span class="Token ID">mount</span><span class="Token SPACE"> </span><span class="Token OPTION">-t</span><span class="Token SPACE"> </span><span class="Token ID">tmpfs</span><span class="Token SPACE">     </span><span class="Token ID">tmpfs</span><span class="Token SPACE">     </span><span class="Token DIV">/</span><span class="Token ID">tmp</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token ID">exec</span><span class="Token SPACE"> </span><span class="Token NUMBER">0</span><span class="Token REDIRECT_FROM">&lt;</span><span class="Token DIV">/</span><span class="Token ID">dev/console</span><span class="Token LF">
</span><span class="Token ID">exec</span><span class="Token SPACE"> </span><span class="Token NUMBER">1</span><span class="Token REDIRECT_TO">&gt;</span><span class="Token DIV">/</span><span class="Token ID">dev/console</span><span class="Token LF">
</span><span class="Token ID">exec</span><span class="Token SPACE"> </span><span class="Token NUMBER">2</span><span class="Token REDIRECT_TO">&gt;</span><span class="Token DIV">/</span><span class="Token ID">dev/console</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token ID">echo</span><span class="Token SPACE"> </span><span class="Token DOLLAR">$</span><span class="Token ID">SHELL</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token ID">echo</span><span class="Token SPACE"> </span><span class="Token OPTION">-e</span><span class="Token SPACE"> </span><span class="Token String STRING">&quot;</span><span class="Token Control String STRING">\n</span><span class="Token String STRING">Boot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds</span><span class="Token Control String STRING">\n</span><span class="Token String STRING">&quot;</span><span class="Token LF">
</span><span class="Token ID">setsid</span><span class="Token SPACE"> </span><span class="Token ID">cttyhack</span><span class="Token SPACE"> </span><span class="Token ID">setuidgid</span><span class="Token SPACE"> </span><span class="Token NUMBER">1000</span><span class="Token SPACE"> </span><span class="Token ID">sh</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token ID">poweroff</span><span class="Token SPACE"> </span><span class="Token OPTION">-d</span><span class="Token SPACE"> </span><span class="Token NUMBER">0</span><span class="Token SPACE">  </span><span class="Token OPTION">-f</span></code></pre><p>脚本中的命令简单解释一下:</p><ul><li>busybox --install -s /bin: 将 busybox 包含的程序在 /bin 目录下创建软链接</li></ul><ul><li>mount: <code>/dev</code> <code>/sys</code> <code>/proc</code> <code>/tmp</code> 这些目录及其内部的文件并不是真实的磁盘文件, 而是在操作系统运行的过程中创建的文件, 它们的文件系统属于<b>内存文件系统</b>. 一方面为用户提供了内核相关的接口, 例如可以通过访问 <code>/proc/&lt;uid&gt;</code> 获取到某个进程的相关数据</li></ul><ul><li>setsid cttyhack setuidgid 1000 sh: 效果是在一个新的、独立的会话中,以指定用户(UID为1000)的身份启动一个新的Shell会话,并且该会话有一个有效的控制终端<p>root 用户的 UID 为 0, 普通用户的 UID 从 1000 起</p></li></ul><blockquote style="border-left-color: #1a7f37; background-color: #e5f6ea;"><div style="color: #1a7f37;"><img class="icon-tip" loading="lazy" src="../../../img/tip.svg" alt="[!TIP]"> TIP </div><p> 事实上即使不去挂载 /sys /proc 系统也可以正常启动运行，但是这些文件系统是用户空间和内核交互的关键接口，不挂载的话ps、top、free 全部失败，其他 init 脚本或者守护进程也可能会失败</p><pre class="language-shell"><code><span class="Token COMMENT">#!/bin/busybox sh</span><span class="Token LF">
</span><span class="Token ID">BB</span><span class="Token ASSIGN">=</span><span class="Token DIV">/</span><span class="Token ID">bin/busybox</span><span class="Token LF">
</span><span class="Token DOLLAR">$</span><span class="Token ID">BB</span><span class="Token SPACE"> </span><span class="Token OPTION">--install</span><span class="Token SPACE"> </span><span class="Token OPTION">-s</span><span class="Token SPACE"> </span><span class="Token DIV">/</span><span class="Token ID">bin</span><span class="Token LF">
</span><span class="Token ID">setsid</span><span class="Token SPACE"> </span><span class="Token ID">cttyhack</span><span class="Token SPACE"> </span><span class="Token ID">setuidgid</span><span class="Token SPACE"> </span><span class="Token NUMBER">1000</span><span class="Token SPACE"> </span><span class="Token ID">sh</span><span class="Token LF">
</span><span class="Token ID">poweroff</span><span class="Token SPACE"> </span><span class="Token OPTION">-d</span><span class="Token SPACE"> </span><span class="Token NUMBER">0</span><span class="Token SPACE">  </span><span class="Token OPTION">-f</span></code></pre></blockquote><p>把下面的内容复制到 Makefile 中</p><blockquote><p>注意下面的 Makefile 代码复制过去之后还需要手动改一下空格为 \t, 不然会出错</p></blockquote><pre class="language-makefile"><code><span class="Token Mission ID">.PHONY</span><span class="Token COLON">:</span><span class="Token SPACE"> </span><span class="Token ID">init</span><span class="Token SPACE"> </span><span class="Token ID">qemu</span><span class="Token SPACE"> </span><span class="Token ID">clean</span><span class="Token SPACE"> </span><span class="Token ID">debug</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token Variable ID">KERNEL</span><span class="Token SPACE"> </span><span class="Token ASSIGN">=</span><span class="Token SPACE"> </span><span class="Token ID">bzImage</span><span class="Token LF">
</span><span class="Token Variable ID">INITRAMFS</span><span class="Token SPACE"> </span><span class="Token ASSIGN">=</span><span class="Token SPACE"> </span><span class="Token ID">initramfs.img</span><span class="Token LF">
</span><span class="Token Variable ID">QEMU</span><span class="Token SPACE"> </span><span class="Token ASSIGN">=</span><span class="Token SPACE"> </span><span class="Token ID">qemu-system-x86_64</span><span class="Token LF">
</span><span class="Token COMMENT"># 如果是自己编译的 qemu 可以使用自己的路径</span><span class="Token LF">
</span><span class="Token COMMENT"># QEMU = ~/qemu/bin/qemu-system-x86_64</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token Mission ID">init</span><span class="Token COLON">:</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token ID">cd</span><span class="Token SPACE"> </span><span class="Token ID">./initramfs</span><span class="Token SPACE"> </span><span class="Token AMPERSAND">&amp;</span><span class="Token AMPERSAND">&amp;</span><span class="Token SPACE"> </span><span class="Token ID">find</span><span class="Token SPACE"> </span><span class="Token ID">.</span><span class="Token SPACE"> </span><span class="Token PIPE">|</span><span class="Token SPACE"> </span><span class="Token ID">cpio</span><span class="Token SPACE"> </span><span class="Token OPTION">-ov</span><span class="Token SPACE"> </span><span class="Token OPTION">--format</span><span class="Token ASSIGN">=</span><span class="Token ID">newc</span><span class="Token SPACE"> </span><span class="Token PIPE">|</span><span class="Token SPACE"> </span><span class="Token ID">gzip</span><span class="Token SPACE"> </span><span class="Token Variable ID">-9</span><span class="Token SPACE"> </span><span class="Token REDIRECT_FROM">&gt;</span><span class="Token SPACE"> </span><span class="Token ID">../</span><span class="Token DOLLAR">$</span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token Variable ID">INITRAMFS</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token Mission ID">qemu</span><span class="Token COLON">:</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token DOLLAR">$</span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token Variable ID">QEMU</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token SPACE"> </span><span class="Token BACK_SLASH">\</span><span class="Token LF">
</span><span class="Token SPACE">          </span><span class="Token OPTION">-kernel</span><span class="Token SPACE"> </span><span class="Token DOLLAR">$</span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token Variable ID">KERNEL</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token SPACE"> </span><span class="Token BACK_SLASH">\</span><span class="Token LF">
</span><span class="Token SPACE">          </span><span class="Token OPTION">-initrd</span><span class="Token SPACE"> </span><span class="Token DOLLAR">$</span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token Variable ID">INITRAMFS</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token SPACE"> </span><span class="Token BACK_SLASH">\</span><span class="Token LF">
</span><span class="Token SPACE">          </span><span class="Token OPTION">-m</span><span class="Token SPACE"> </span><span class="Token NUMBER">1G</span><span class="Token SPACE"> </span><span class="Token BACK_SLASH">\</span><span class="Token LF">
</span><span class="Token SPACE">          </span><span class="Token OPTION">-nographic</span><span class="Token SPACE"> </span><span class="Token BACK_SLASH">\</span><span class="Token LF">
</span><span class="Token SPACE">          </span><span class="Token OPTION">-append</span><span class="Token SPACE"> </span><span class="Token STRING">&quot;earlyprintk=serial,ttyS0 console=ttyS0&quot;</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token Mission ID">debug</span><span class="Token COLON">:</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token DOLLAR">$</span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token Variable ID">QEMU</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token SPACE"> </span><span class="Token BACK_SLASH">\</span><span class="Token LF">
</span><span class="Token SPACE">          </span><span class="Token OPTION">-kernel</span><span class="Token SPACE"> </span><span class="Token DOLLAR">$</span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token Variable ID">KERNEL</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token SPACE"> </span><span class="Token BACK_SLASH">\</span><span class="Token LF">
</span><span class="Token SPACE">          </span><span class="Token OPTION">-initrd</span><span class="Token SPACE"> </span><span class="Token DOLLAR">$</span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token Variable ID">INITRAMFS</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token SPACE"> </span><span class="Token BACK_SLASH">\</span><span class="Token LF">
</span><span class="Token SPACE">          </span><span class="Token OPTION">-m</span><span class="Token SPACE"> </span><span class="Token NUMBER">1G</span><span class="Token SPACE"> </span><span class="Token BACK_SLASH">\</span><span class="Token LF">
</span><span class="Token SPACE">          </span><span class="Token OPTION">-nographic</span><span class="Token SPACE"> </span><span class="Token BACK_SLASH">\</span><span class="Token LF">
</span><span class="Token SPACE">          </span><span class="Token OPTION">-append</span><span class="Token SPACE"> </span><span class="Token STRING">&quot;earlyprintk=serial,ttyS0 console=ttyS0&quot;</span><span class="Token SPACE"> </span><span class="Token BACK_SLASH">\</span><span class="Token LF">
</span><span class="Token SPACE">          </span><span class="Token OPTION">-S</span><span class="Token SPACE"> </span><span class="Token BACK_SLASH">\</span><span class="Token LF">
</span><span class="Token SPACE">          </span><span class="Token OPTION">-s</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token Mission ID">clean</span><span class="Token COLON">:</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token ID">rm</span><span class="Token SPACE"> </span><span class="Token DOLLAR">$</span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token Variable ID">INITRAMFS</span><span class="Token BraceDepth-0 RPAREN">)</span></code></pre><p>简单解释一下这里的命令的含义</p><ul><li>首先是后面这一段很长的<code>find . | cpio -ov --format=newc | gzip -9 &gt; ../initramfs.img</code><p>这个命令的作用是将当前目录下的所有文件和子目录,打包成一个 cpio 归档文件,并使用 gzip 压缩成一个压缩文件,最后保存到上级目录的 initramfs.img 文件中, 用于创建初始化内存文件系统(initramfs)</p><ul><li><code>find .</code>: 查找当前目录(以及其子目录)下的所有文件和目录,输出它们的路径。</li></ul><ul><li><code>cpio -ov --format=newc</code>: 将 find 命令输出的路径列表作为输入,创建一个 cpio 归档文件。-o 表示创建归档文件,-v 表示显示详细信息,<code>--format=newc</code> 表示使用 newc 格式创建归档文件,该格式通常用于初始化内存文件系统(initramfs).</li></ul><ul><li><code>gzip -9</code>: 对 cpio 归档文件进行压缩,并且使用最高压缩比 -9 以达到最小化文件大小。</li></ul><ul><li>最后将压缩后的数据流输出到上级目录中的 initramfs.img 文件中,使用重定向符号 &gt; 来实现。</li></ul></li></ul><ul><li><code>-nographic</code> 表示在终端中以无图形模式启动虚拟机,不使用图形界面。</li></ul><ul><li><code>-append &quot;earlyprintk=serial,ttyS0 console=ttyS0&quot;</code> 表示向内核传递启动参数。其中,earlyprintk=serial,ttyS0 表示启用串口输出信息,console=ttyS0 表示将控制台输出定向到串口终端(ttyS0)上。</li></ul><p>最终的文件结构如下所示</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20230314202620.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230314202620.png" alt="20230314202620" class="pic-big"></a></p><h2 id="h2-5">QEMU 启动</h2><p>制作initramfs</p><pre class="language-shell"><code><span class="Token ID">make</span><span class="Token SPACE"> </span><span class="Token ID">init</span></code></pre><blockquote><p>如果报错 cpio 找不到的话先下载 <code>sudo apt install cpio</code></p></blockquote><p>执行之后会得到 <code>initramfs.img</code></p><p>使用qemu开始模拟</p><pre class="language-shell"><code><span class="Token ID">make</span><span class="Token SPACE"> </span><span class="Token ID">qemu</span></code></pre><p>成功启动后按下enter进入命令行, 使用ls查看目录结构, 也可以在这个命令行中测试一些内容, 这些常用命令都是 busybox 提供的支持</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20230518133704.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230518133704.png" alt="20230518133704" class="pic-big"></a></p><p>这是一个临时的内存文件系统，在这个系统上的内容不会被保存下来，可以简单尝试 echo &quot;123&quot; &gt; 1.txt，重启之后发现 1.txt 消失了</p><p>退出 QEMU 模拟: 使用 <kbd>ctrl</kbd> + <kbd>A</kbd> 然后按下 <kbd>x</kbd></p><h2 id="h2-6">Vscode + gdb</h2><p>启用调试内核只需要</p><pre class="language-shell"><code><span class="Token ID">make</span><span class="Token SPACE"> </span><span class="Token ID">debug</span></code></pre><blockquote style="border-left-color: #1a7f37; background-color: #e5f6ea;"><div style="color: #1a7f37;"><img class="icon-tip" loading="lazy" src="../../../img/tip.svg" alt="[!TIP]"> TIP </div><p> <b>调试时不要使用 qemu 的 -enable-kvm</b>, 否则无法正确的插入断点</p><p>正常执行的话不调试可以在 qemu 启动时加上 <code>-enable-kvm -cpu host</code> 大大加速启动</p></blockquote><p>&quot;-S&quot;选项表示在启动时暂停虚拟机的执行。它使得虚拟机在启动后立即进入调试模式,并等待调试器连接。&quot;-s&quot;选项表示在启动时打开一个GDB服务器,监听本地的1234端口。这个选项与&quot;-S&quot;选项一起使用,用于配合调试器进行调试</p><blockquote><p>如果没有冲突的话默认使用 1234 端口即可, 否则添加 <code>-gdb tcp::12345</code> 进行端口调整</p></blockquote><ul><li>你可以在一个终端中在 workspace 目前下使用 <code>make qemu</code>, 此时运行会卡住</li></ul><ul><li>然后再另一个终端中在 linux6.6 目前下使用 <code>gdb vmlinux</code> 调试<p>进入gdb后连接1234端口</p><pre class="language-shell"><code><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token ID">gdb</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token SPACE"> </span><span class="Token ID">target</span><span class="Token SPACE"> </span><span class="Token ID">remote</span><span class="Token SPACE"> </span><span class="Token COLON">:</span><span class="Token NUMBER">1234</span></code></pre><p>在start_kernel处打一个断点(此函数位于init/main.c), 然后继续</p><pre class="language-shell"><code><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token ID">gdb</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token SPACE"> </span><span class="Token ID">b</span><span class="Token SPACE"> </span><span class="Token ID">start_kernel</span><span class="Token LF">
</span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token ID">gdb</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token SPACE"> </span><span class="Token ID">c</span></code></pre></li></ul><p>当然, 这种方法很原始, 笔者更倾向于使用带 GUI 的更加方便的vscode来进行调试</p><h2 id="h2-7">生成源码标签</h2><p>首先阅读代码的时候没有什么智能提示和补全, 这是因为需要生成智能补全的头文件, 高版本的内核提供了一个脚本就可以直接得到 <code>compile_commands.json</code></p><blockquote><p>linux 默认提供了 <code>make gtags</code> 生成源码标签, 我们不使用</p></blockquote><pre class="language-shell"><code><span class="Token ID">python3</span><span class="Token SPACE"> </span><span class="Token ID">./scripts/clang-tools/gen_compile_commands.py</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token COMMENT"># 如果是老版本linux这个文件的位置在</span><span class="Token LF">
</span><span class="Token ID">python3</span><span class="Token SPACE"> </span><span class="Token ID">./scripts/gen_compile_commands.py</span></code></pre><p>等待一段时间运行结束之后得到 <code>compile_commands.json</code></p><p>如果没有找到这个脚本可以使用 <a href="https://github.com/rizsotto/Bear" target="_blank">Bear</a> 来在编译时生成脚本</p><pre class="language-shell"><code><span class="Token ID">sudo</span><span class="Token SPACE"> </span><span class="Token ID">apt</span><span class="Token SPACE"> </span><span class="Token ID">install</span><span class="Token SPACE"> </span><span class="Token ID">bear</span><span class="Token LF">
</span><span class="Token ID">bear</span><span class="Token SPACE"> </span><span class="Token OPTION">--</span><span class="Token SPACE"> </span><span class="Token REDIRECT_FROM">&lt;</span><span class="Token ID">之前的</span><span class="Token SPACE"> </span><span class="Token ID">make</span><span class="Token SPACE"> </span><span class="Token ID">命令</span><span class="Token REDIRECT_TO">&gt;</span><span class="Token LF">
</span><span class="Token COMMENT"># bear -- make -j`nproc`</span></code></pre><p>默认的 Vscode C++ 插件都可以索引到根目录下的 <code>compile_commands.json</code>, 但可能还是会有一些报错如下所示, 这是因为 compile_commands.json 中的编译选项有一些无法识别的东西</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20230518140756.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230518140756.png" alt="20230518140756" class="pic-big"></a></p><p>如果读者使用的是 clangd 的话可以直接设置它的配置文件, 创建 ~/.config/clangd/config.yaml 文件, 该配置的含义是忽略无法识别的编译选项, 大部分无法识别的编译参数都是以 -m -f 开头的</p><pre class="language-yaml"><code><span class="Token Key ID">CompileFlags</span><span class="Token COLON">:</span><span class="Token LF">
</span><span class="Token SPACE">  </span><span class="Token Key ID">Add</span><span class="Token COLON">:</span><span class="Token SPACE"> </span><span class="Token MINUS">-</span><span class="Token ID">Wno-unknown-warning-option</span><span class="Token LF">
</span><span class="Token SPACE">  </span><span class="Token Key ID">Remove</span><span class="Token COLON">:</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token MINUS">-</span><span class="Token ID">m</span><span class="Token STAR">*</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token MINUS">-</span><span class="Token ID">f</span><span class="Token STAR">*</span><span class="Token BraceDepth-0 RSQUAR_PAREN">]</span></code></pre><p>如果使用的是微软的 c++ 插件的话可以手动将这个文件中的这几个编译选项删除, 使用如下命令直接修改 <code>compile_commands.json</code></p><pre class="language-shell"><code><span class="Token ID">sed</span><span class="Token SPACE"> </span><span class="Token OPTION">-i</span><span class="Token SPACE"> </span><span class="Token APOSTROPHE">&#x27;</span><span class="Token ID">s/</span><span class="Token BACK_SLASH">\</span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token OPTION">-mpreferred-stack-boundary</span><span class="Token ASSIGN">=</span><span class="Token NUMBER">3</span><span class="Token BACK_SLASH">\</span><span class="Token PIPE">|</span><span class="Token OPTION">-mindirect-branch</span><span class="Token ASSIGN">=</span><span class="Token ID">thunk-extern</span><span class="Token BACK_SLASH">\</span><span class="Token PIPE">|</span><span class="Token OPTION">-mindirect-branch-register</span><span class="Token BACK_SLASH">\</span><span class="Token PIPE">|</span><span class="Token OPTION">-mindirect-branch-cs-prefix</span><span class="Token BACK_SLASH">\</span><span class="Token PIPE">|</span><span class="Token OPTION">-fno-allow-store-data-races</span><span class="Token BACK_SLASH">\</span><span class="Token PIPE">|</span><span class="Token OPTION">-fconserve-stack</span><span class="Token BACK_SLASH">\</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token DIV">/</span><span class="Token DIV">/</span><span class="Token ID">g</span><span class="Token APOSTROPHE">&#x27;</span><span class="Token SPACE"> </span><span class="Token ID">compile_commands.json</span><span class="Token LF">
</span><span class="Token ID">sed</span><span class="Token SPACE"> </span><span class="Token OPTION">-i</span><span class="Token SPACE"> </span><span class="Token APOSTROPHE">&#x27;</span><span class="Token ID">s/-mfunction-return</span><span class="Token ASSIGN">=</span><span class="Token ID">thunk-extern//g</span><span class="Token APOSTROPHE">&#x27;</span><span class="Token SPACE"> </span><span class="Token ID">compile_commands.json</span><span class="Token LF">
</span><span class="Token ID">sed</span><span class="Token SPACE"> </span><span class="Token OPTION">-i</span><span class="Token SPACE"> </span><span class="Token APOSTROPHE">&#x27;</span><span class="Token ID">s/-fzero-call-used-regs</span><span class="Token ASSIGN">=</span><span class="Token ID">used-gpr//g</span><span class="Token APOSTROPHE">&#x27;</span><span class="Token SPACE"> </span><span class="Token ID">compile_commands.json</span><span class="Token LF">
</span><span class="Token ID">sed</span><span class="Token SPACE"> </span><span class="Token OPTION">-i</span><span class="Token SPACE"> </span><span class="Token APOSTROPHE">&#x27;</span><span class="Token ID">s/-fsanitize</span><span class="Token ASSIGN">=</span><span class="Token ID">bounds-strict//g</span><span class="Token APOSTROPHE">&#x27;</span><span class="Token SPACE"> </span><span class="Token ID">compile_commands.json</span><span class="Token LF">
</span><span class="Token ID">sed</span><span class="Token SPACE"> </span><span class="Token OPTION">-i</span><span class="Token SPACE"> </span><span class="Token APOSTROPHE">&#x27;</span><span class="Token ID">s/-mrecord-mcount//g</span><span class="Token APOSTROPHE">&#x27;</span><span class="Token SPACE"> </span><span class="Token ID">compile_commands.json</span></code></pre><p>然后就没有报错了, 整个代码看起来很清爽</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20230518224144.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230518224144.png" alt="20230518224144" class="pic-big"></a></p><blockquote style="border-left-color: #0969da; background-color: #e8f3ff;"><div style="color: #0969da;"><img class="icon-note" loading="lazy" src="../../../img/note.svg" alt="[!NOTE]"> NOTE </div><p> 没有报错指大部分文件都没有明显的警告了, 如果点开一些头文件还是可以看到找不到符号的问题, 这是因为有一些头文件引用不规范, 暂且搁置</p><p>这里简单介绍一下这几个编译选项的含义，这些编译选项是 GCC 独有的，clang 并不完全支持所以报错找不到</p><ul><li>-mpreferred-stack-boundary=3： 控制栈指针的对齐边界，表示以 2^3 = 8 字节对齐栈</li></ul><ul><li>-mindirect-branch=thunk-extern：强制所有间接分支（如 jmp *%rax）不直接执行，而是跳转到“thunk”函数中执行，以防止推测执行攻击，thunk-extern 表示使用外部定义的 thunk（通常在 arch/x86/lib/retpoline.S 中定义），内核支持 retpoline（Return trampoline）技术来防止 CPU 推测攻击</li></ul><ul><li>-mindirect-branch-register：也是 Spectre v2 防护的一部分，要求使用寄存器跳转时（如 jmp *%rax），使用特定的寄存器保存目标地址</li></ul><ul><li>-mindirect-branch-cs-prefix：给间接分支加上 CS 段前缀，主要用于 x86 retpoline 安全补丁 的一个变体，以改变 CPU 的预测行为，使其不被误预测到不安全的路径</li></ul><ul><li>-fno-allow-store-data-races：GCC 默认认为非原子变量的读写之间的竞争是“未定义行为”，但在内核中这些情况经常出现。因此这个选项告诉编译器: &quot;不要乱优化有数据竞争的代码，我自己知道在干什么&quot;，保证内核同步原语（如 READ_ONCE, WRITE_ONCE）正确工作</li></ul><ul><li>-fconserve-stack：要求编译器尽量节省栈空间，Linux 内核的栈只有 8KB（在某些架构甚至更小），编译器的递归展开或寄存器溢出到栈上可能导致栈溢出</li></ul></blockquote><p>考虑到其他内核版本可能使用了不同的编译选项, 读者可以根据 clangd 的提示信息从中删除或修改对应的内容</p><pre class="language-shell"><code><span class="Token ID">sed</span><span class="Token SPACE"> </span><span class="Token OPTION">-i</span><span class="Token SPACE"> </span><span class="Token APOSTROPHE">&#x27;</span><span class="Token ID">s/your</span><span class="Token SPACE"> </span><span class="Token ID">warnning</span><span class="Token SPACE"> </span><span class="Token ID">command//g</span><span class="Token APOSTROPHE">&#x27;</span><span class="Token SPACE"> </span><span class="Token ID">compile_commands.json</span></code></pre><hr><p>接下来配置调试程序, 新建<code>.vscode/launch.json</code>, 复制如下的代码, 设置调试的名称是 <code>qemu-kernel-gdb</code>（这个名字可以随意修改）, 使用本机的1234端口（这个端口号不要修改，这是 qemu gdb 默认的映射端口）调试 vmlinux 文件</p><pre class="language-json"><code><span class="Token Object BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Object LF">
</span><span class="Token Object SPACE">    </span><span class="Token String Key Pair STRING">&quot;version&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token String Pair STRING">&quot;0.2.0&quot;</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">    </span><span class="Token String Key Pair STRING">&quot;configurations&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token Array Pair BraceDepth-1 LSQUAR_PAREN">[</span><span class="Token Array Pair LF">
</span><span class="Token Array Pair SPACE">        </span><span class="Token Object BraceDepth-2 LCURLY_BRACE">{</span><span class="Token Object LF">
</span><span class="Token Object SPACE">            </span><span class="Token String Key Pair STRING">&quot;name&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token String Pair STRING">&quot;qemu-kernel-gdb&quot;</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">            </span><span class="Token String Key Pair STRING">&quot;type&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token String Pair STRING">&quot;cppdbg&quot;</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">            </span><span class="Token String Key Pair STRING">&quot;request&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token String Pair STRING">&quot;launch&quot;</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">            </span><span class="Token String Key Pair STRING">&quot;miDebuggerServerAddress&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token String Pair STRING">&quot;127.0.0.1:1234&quot;</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">            </span><span class="Token String Key Pair STRING">&quot;program&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token String Pair STRING">&quot;${workspaceFolder}/vmlinux&quot;</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">            </span><span class="Token String Key Pair STRING">&quot;targetArchitecture&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token String Pair STRING">&quot;x64&quot;</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">            </span><span class="Token String Key Pair STRING">&quot;args&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token Array Pair BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token Array Pair BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">            </span><span class="Token String Key Pair STRING">&quot;stopAtEntry&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token Keyword Pair FALSE">false</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">            </span><span class="Token String Key Pair STRING">&quot;cwd&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token String Pair STRING">&quot;${workspaceFolder}&quot;</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">            </span><span class="Token String Key Pair STRING">&quot;environment&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token Array Pair BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token Array Pair BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">            </span><span class="Token String Key Pair STRING">&quot;externalConsole&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token Keyword Pair FALSE">false</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">            </span><span class="Token String Key Pair STRING">&quot;logging&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token Object Pair BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Object Pair LF">
</span><span class="Token Object Pair SPACE">                </span><span class="Token String Key Pair STRING">&quot;engineLogging&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token Keyword Pair FALSE">false</span><span class="Token Keyword Pair LF">
</span><span class="Token Keyword Pair SPACE">            </span><span class="Token Object Pair BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">            </span><span class="Token String Key Pair STRING">&quot;MIMode&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token String Pair STRING">&quot;gdb&quot;</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">            </span><span class="Token String Key Pair STRING">&quot;setupCommands&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token Array Pair BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token Array Pair LF">
</span><span class="Token Array Pair SPACE">                </span><span class="Token Object BraceDepth-1 LCURLY_BRACE">{</span><span class="Token Object LF">
</span><span class="Token Object SPACE">                    </span><span class="Token String Key Pair STRING">&quot;text&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token String Pair STRING">&quot;dir .&quot;</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">                    </span><span class="Token String Key Pair STRING">&quot;ignoreFailures&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token Keyword Pair FALSE">false</span><span class="Token Keyword Pair LF">
</span><span class="Token Keyword Pair SPACE">                </span><span class="Token Object BraceDepth-1 RCURLY_BRACE">}</span><span class="Token Array Pair COMMA">,</span><span class="Token Array Pair LF">
</span><span class="Token Array Pair SPACE">                </span><span class="Token Object BraceDepth-1 LCURLY_BRACE">{</span><span class="Token Object LF">
</span><span class="Token Object SPACE">                    </span><span class="Token String Key Pair STRING">&quot;text&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token String Pair STRING">&quot;add-auto-load-safe-path ./&quot;</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">                    </span><span class="Token String Key Pair STRING">&quot;ignoreFailures&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token Keyword Pair FALSE">false</span><span class="Token Keyword Pair LF">
</span><span class="Token Keyword Pair SPACE">                </span><span class="Token Object BraceDepth-1 RCURLY_BRACE">}</span><span class="Token Array Pair COMMA">,</span><span class="Token Array Pair LF">
</span><span class="Token Array Pair SPACE">                </span><span class="Token Object BraceDepth-1 LCURLY_BRACE">{</span><span class="Token Object LF">
</span><span class="Token Object SPACE">                    </span><span class="Token String Key Pair STRING">&quot;text&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token String Pair STRING">&quot;-enable-pretty-printing&quot;</span><span class="Token Object COMMA">,</span><span class="Token Object LF">
</span><span class="Token Object SPACE">                    </span><span class="Token String Key Pair STRING">&quot;ignoreFailures&quot;</span><span class="Token Pair COLON">:</span><span class="Token Pair SPACE"> </span><span class="Token Keyword Pair TRUE">true</span><span class="Token Keyword Pair LF">
</span><span class="Token Keyword Pair SPACE">                </span><span class="Token Object BraceDepth-1 RCURLY_BRACE">}</span><span class="Token Object LF">
</span><span class="Token Object SPACE">            </span><span class="Token Array Pair BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token Array Pair LF">
</span><span class="Token Array Pair SPACE">        </span><span class="Token Object BraceDepth-2 RCURLY_BRACE">}</span><span class="Token Object LF">
</span><span class="Token Object SPACE">    </span><span class="Token Array Pair BraceDepth-1 RSQUAR_PAREN">]</span><span class="Token Array Pair LF">
</span><span class="Token Object BraceDepth-0 RCURLY_BRACE">}</span></code></pre><p>至此已经全部结束了, 试着在 <code>init/main.c</code> 中搜索 <code>start_kernel</code>, 在下面打一个断点试试?</p><p>在目录 workspace 下执行 <code>make debug</code> 开启 qemu 模拟, 并把内核的调试信息通过 1234 端口转发出去, 然后点击 vscode 的调试以连接 1234 端口使用 gdb 调试</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20230518224436.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230518224436.png" alt="20230518224436" class="pic-big"></a></p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20230518224610.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230518224610.png" alt="20230518224610" class="pic-big"></a></p><blockquote style="border-left-color: #0969da; background-color: #e8f3ff;"><div style="color: #0969da;"><img class="icon-note" loading="lazy" src="../../../img/note.svg" alt="[!NOTE]"> NOTE </div><p></p><p>读者这里可能有些混乱，怎么一会儿是 vmlinux 一会儿是 bzImage。事实上 vmlinux 和 bzImage 都是Linux内核编译生成的文件，它们的主要区别在于它们的文件格式和用途。</p><ul><li>vmlinux 是Linux内核编译生成的<b>未压缩</b>的内核镜像文件<ul><li>它是一个 ELF 文件，包含了整个内核的代码和数据，主要<b>用来调试内核</b>.</li></ul><ul><li><b>并不是“裸机镜像”，不能直接被 BIOS/UEFI/QEMU 当作可启动映像加载</b></li></ul></li></ul><ul><li>bzImage 是通过 make bzImage 从 vmlinux 包装生成的一个<b>压缩过</b>的<b>可引导内核镜像</b><ul><li>它是<b>用来引导启动Linux操作系统</b>的</li></ul><ul><li>bzImage 将vmlinux压缩成一个单独的文件，并添加一些引导代码和头部信息</li></ul><ul><li><b>它可以直接被 BIOS/UEFI 或 QEMU 识别、加载并执行</b></li></ul></li></ul><p>所以在 Makefile 脚本中我们使用的是可引导的 bzImage，bzImage首先会被加载到内存中，然后被解压缩成vmlinux形式的内核映像。而 vscode 中 launch.json 是 gdb 的配置参数，gdb 需要传入 ELF 文件并进行调试信息符号解析，所以需要传入 vmlinux</p><p>更多内容详见<a href="../../kernel/内核镜像格式" target="_self">内核镜像格式</a> 和 <a href="https://kernel.org/doc/html/v6.6/arch/x86/boot.html" target="_blank">Linux boot protocol</a></p></blockquote><h2 id="h2-8">总结</h2><p>至此我们完成了一个基础的 linux kernel 调试环境, 但是目前的所有操作都只会保存在 initramfs 中, 目前可用的软件很少, 没有编译器, 没有联网, 没有 apt 包管理工具, 不能持久化存储。不过你已经可以开启你的内核调试之旅了，将编译好的软件拷贝到 initramfs/ 下然后重新打包就可以把可执行文件带进去了！</p><blockquote style="border-left-color: #1a7f37; background-color: #e5f6ea;"><div style="color: #1a7f37;"><img class="icon-tip" loading="lazy" src="../../../img/tip.svg" alt="[!TIP]"> TIP </div><p> 现在系统中还没有 libc 的动态链接库，包括 busybox 在内的所有文件都是静态链接得到的，记得加上参数 -static</p></blockquote><p>下文我们介绍一下如何使用 qemu 模拟更加复杂的环境, 以及如何利用现有的 Linux 发行版根文件系统(比如说 Ubuntu 的基础软件包)来搭建一个可用的 linux 开发环境, 替换自己编译的内核</p><h2 id="h2-9">参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/715345004" target="_blank">一文讲清initramfs是什么</a></li></ul><ul><li><a href="https://unix.stackexchange.com/questions/122100/why-do-i-need-initramfs" target="_blank">为什么需要 initramfs</a></li></ul><ul><li><a href="https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt" target="_blank">kernel ramfs-rootfs-initramfs.txt</a></li></ul><ul><li><a href="https://howardlau.me/programming/debugging-linux-kernel-with-vscode-qemu.html" target="_blank">使用 VSCode + qemu 搭建 Linux 内核调试环境</a></li></ul><ul><li><a href="https://www.yuque.com/wwyf/blog/og2h3r" target="_blank">如何舒服地调试 Linux 内核</a></li></ul><ul><li><a href="https://www.bilibili.com/video/BV1dY411f75B" target="_blank">[Linux Kernel] 通过 VS Code 和 QEMU 调试 Linux 内核(QEMU;GDB;VS Code;Linux)</a></li></ul><ul><li><a href="https://wiki.gentoo.org/wiki/Custom_Initramfs" target="_blank">gentoo wiki initramfs</a></li></ul><ul><li><a href="https://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/" target="_blank">booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb</a></li></ul><ul><li><a href="https://consen.github.io/2018/01/17/debug-linux-kernel-with-qemu-and-gdb/" target="_blank">debug-linux-kernel-with-qemu-and-gdb</a></li></ul><ul><li><a href="http://www.linuxfromscratch.org/blfs/view/cvs/postlfs/initramfs.html" target="_blank">blfs initramfs</a></li></ul><ul><li><a href="https://wiki.gentoo.org/wiki/Custom_Initramfs" target="_blank">custom initramfs</a></li></ul><ul><li><a href="https://unix.stackexchange.com/a/474452" target="_blank">Why do I need initramfs?</a></li></ul><ul><li><a href="https://github.com/clangd/clangd/issues/662" target="_blank">clangd: ignore unknown compiler options</a></li></ul><ul><li><a href="https://www.kernel.org/doc/html/v4.9/dev-tools/gdb-kernel-debugging.html" target="_blank">kernel gdb-kernel-debugging</a></li></ul></div>
                <script>
                document.addEventListener('DOMContentLoaded', function() {
                    var markdownBody = document.querySelector('.markdown-body');
                    var giscusDiv = markdownBody.querySelector('.giscus');
                    var referenceHtml = `<div class="references-tabs-container">
<div class="references-tabs-nav">
<button class="references-tab-btn active" data-tab="references-out">本文引用</button>
<button class="references-tab-btn " data-tab="references-in">本文被引用</button>
</div>
<div class="references-tabs-content">
<div class="references-tab-pane active" id="references-out">
<ul class="reference-list">
<li><a href="../../快速开始/安装内核与救火"><span class="reference-icon" aria-hidden="true"></span><span class="reference-title">安装内核与救火</span></a></li>
<li><a href="../../kernel/内核镜像格式"><span class="reference-icon" aria-hidden="true"></span><span class="reference-title">内核镜像格式</span></a></li>
</ul>
</div>
<div class="references-tab-pane " id="references-in">
<ul class="reference-list">
<li><a href="../../快速开始/开发环境搭建"><span class="reference-icon" aria-hidden="true"></span><span class="reference-title">开发环境搭建</span></a></li>
<li><a href="../../快速开始/安装内核与救火"><span class="reference-icon" aria-hidden="true"></span><span class="reference-title">安装内核与救火</span></a></li>
<li><a href="../../mm/页表"><span class="reference-icon" aria-hidden="true"></span><span class="reference-title">页表</span></a></li>
<li><a href="../../mm/numa"><span class="reference-icon" aria-hidden="true"></span><span class="reference-title">numa</span></a></li>
</ul>
</div>
</div>
</div>`;
                    
                    if (giscusDiv) {
                        giscusDiv.insertAdjacentHTML('beforebegin', referenceHtml);
                    } else {
                        markdownBody.insertAdjacentHTML('beforeend', referenceHtml);
                    }
                    
                    // 添加选项卡切换功能
                    setTimeout(function() {
                        var tabButtons = document.querySelectorAll('.references-tab-btn');
                        var tabPanes = document.querySelectorAll('.references-tab-pane');
                        
                        tabButtons.forEach(function(button) {
                            button.addEventListener('click', function() {
                                var targetTab = this.getAttribute('data-tab');
                                
                                // 移除所有active类
                                tabButtons.forEach(btn => btn.classList.remove('active'));
                                tabPanes.forEach(pane => pane.classList.remove('active'));
                                
                                // 添加active类到当前选中的选项卡
                                this.classList.add('active');
                                var targetPane = document.getElementById(targetTab);
                                if (targetPane) {
                                    targetPane.classList.add('active');
                                }
                            });
                        });
                    }, 100);
                });
                </script>
                
    <div id="dir-tree-placeholder"></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/dir_tree_toggle.js"></script><script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../快速开始/编译内核","../../快速开始/开发环境搭建","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/clipboard.svg","../../../img/clipboard-check.svg");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script>
            <script src="https://giscus.app/client.js" data-repo="luzhixing12345/klinux" 
            data-repo-id="R_kgDOJIKiEw" data-category="Q&A" data-category-id="DIC_kwDOJIKiE84CgFwK" data-mapping="pathname" data-strict="0"
            data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom"
            data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async>
            </script>
            <script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>
<script>
    const ws = new WebSocket("ws://127.0.0.1:8765");
    ws.onmessage = (event) => {
        if (event.data === "reload") location.reload();
    };
</script>

</html>