<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/prism.css /><link rel='stylesheet' href=../../../css/index.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <div class="header-navigator"><ul><li><a href="#h1-0">ACPI</a></li></ul></div><div class='markdown-body'><h1 id="h1-0">ACPI</h1><blockquote><p><a href="https://rdist.root.org/2008/10/17/all-about-acpi/" target="_blank">all-about-acpi</a></p></blockquote><p>ACPI(Advanced Configuration and Power Interface)是一种标准,用于使电源管理等功能(最初位于 BIOS 中)可供操作系统进行枚举和控制.</p><p>ACPI 是一项复杂的 600 页标准.它假设读者具有大量有关 PC 硬件和 BIOS 的底层知识.过去,BIOS 是 PC 上首先启动的东西.首先,它将配置 PCI 插槽和板等外围设备.为了保持控制,它会在启动操作系统之前挂接系统管理中断(SMI).SMI 由 OEM 与实际硬件绑定,例如将笔记本电脑的盖子开关连接到微控制器.BIOS 具有硬编码的事件类型和处理它们的逻辑("如果按下盖子开关,则关闭背光").好处是操作系统完全不知道 BIOS,因为 SMI 对软件来说基本上是不可见的,因此它可以在所有 PC 上运行而无需更改.</p><p>在ACPI模型中,BIOS(或者现在的EFI)仍然执行基本的初始化.硬件设置完毕后,它会挂接SMI.不同之处在于,它现在在 RAM 中提供一组表供操作系统使用.虽然大多数静态表描述硬件,但最重要的一个("DSDT")提供称为 AML(ACPI Machine Language(ACPI机器语言)) 的字节码.操作系统在启动过程的早期就设置了解释器并加载 BIOS 的 AML.AML 由方法和数据类型组成,并按与设备逻辑排列相匹配的树形排列.例如,与视频设备相关的方法将位于其父 PCI 主机接口的 AML 设备对象下.</p><p>ACPI表中的控制方法是用于定义和实现与硬件设备交互的操作代码.这些控制方法可以被操作系统和驱动程序调用,以执行特定的功能,如配置设备,处理中断,处理电源管理等.而AML就是用来编写这些控制方法的语言.</p><p>AML是一种高级语言,设计用于与ACPI规范的表和结构进行交互.它使用类似于树结构的语法,具有声明性和事件驱动的特性.AML的语法和语义被规范定义,以确保ACPI表的一致性和可移植性.</p><p>使用AML,开发者可以编写ACPI控制方法,描述硬件设备的行为和操作.这些方法可以被操作系统解释和执行,以实现设备的初始化,配置和管理.AML提供了一套丰富的语言特性,包括条件语句,循环语句,变量,函数等,以支持复杂的控制逻辑和算法.</p><p>操作系统遍历 AML 树,初始化各种设备并使用 AML 和特定于设备的方法为它们分配资源.通常,操作系统会在其内部设备驱动程序树和对其进行阴影处理的 AML 节点句柄之间保留映射.这允许它稍后调用该节点下的方法来更改功率级别或配置其唤醒功能.例如,您希望操作系统在未使用内部调制解调器时将其关闭.这是通过调用代表调制解调器的设备节点的 AML 方法来完成的.</p><p>操作系统始终以这种方式与 ACPI 进行互操作.操作系统调用 AML(或通过中断反之亦然)来打开/关闭设备电源,更改背光设置,更改 CPU 频率/电压或暂停/恢复系统.虽然作为操作系统开发人员来说,这种级别的控制是很好的,但在此过程中也遇到了很多障碍.</p><p>ACPI 可以被视为微软和英特尔试图控制以前由 Phoenix/AMI 以及实际上为戴尔等公司构建系统的众多台湾集成商拥有的领域.他们这样做可以说有充分的理由,包括解决如此多的 BIOS 错误的支持成本.阴谋论者可能认为这是比尔盖茨试图破坏Linux但ACPI带来的痛苦也一直由微软承担.盖茨从未真正获得 ACPI 的专有扩展,但 Windows 确实享有 OEM 厂商使用它作为其 BIOS 实现的验证套件的特权地位.由于没有开放的互操作性测试,规范非常复杂,并且有关低级 BIOS 和硬件的信息都捆绑在 NDA 中,随着新 PC 的出现,开源内核遇到了许多兼容性问题.这个过程绝对应该更加开放,并且似乎正在变得更好,这很大程度上要归功于英特尔在 Linux 方面的努力.</p><p>ACPI规范OSPM(Operating System-directed configuration and Power Management) 和OSPM各种方法就是操作系统里的ACPI驱动和ACPI firmware之间的一个互动的接口. x86启动OS后,没有ACPI之前,firmware(BIOS)的代码是无法被执行了,除非通过SMI中断处理程序. 但有了ACPI,BIOS提前把ACPI的一些静态表格和AML的bytecode代码装载到内存, 然后ACPI驱动就会加载AML的解释器,这样OS就可以通过ACPI驱动调用预先装载的AML代码. AML(ACPI Machine Language)是和Java类似的一种虚拟机解释型语言,所以不同操作系统的ACPI驱动, 只要有相同的虚拟机解释器,就可以直接从操作系统调用ACPI写好的AML的代码了. 所以,前文所述的所有热插拔的OSPM方法,其实就是对应ACPI firmware的AML的一段函数代码而已.</p></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../linux011/README" >linux011</a><ul><li><a href="../../linux011/README" >README</a></li></ul><ul><li><a href="../../linux011/基础知识概览" >基础知识概览</a></li></ul><ul><li><a href="../../linux011/init" >init</a></li></ul><ul><li><a href="../../linux011/kernel" >kernel</a></li></ul><ul><li><a href="../../linux011/mm" >mm</a></li></ul></li></ul><ul><li><a href="../../前期准备/编译内核" >前期准备</a><ul><li><a href="../../前期准备/编译内核" >编译内核</a></li></ul><ul><li><a href="../../前期准备/调试内核" >调试内核</a></li></ul><ul><li><a href="../../前期准备/邮件订阅" >邮件订阅</a></li></ul><ul><li><a href="../../前期准备/linux目录结构" >linux目录结构</a></li></ul><ul><li><a href="../../前期准备/lfs" >lfs</a></li></ul></li></ul><ul><li><a href="../../linux/namespace-cgroups" >linux</a><ul><li><a href="../../linux/namespace-cgroups" >namespace-cgroups</a></li></ul><ul><li><a href="../../linux/内存管理" >内存管理</a></li></ul></li></ul><ul><li><a href="../../arch/ACPI" >arch</a><ul><li><a href="../../arch/ACPI" >ACPI</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../linux/内存管理",".","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/prism.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/check_box.js"></script>
</body>

</html>