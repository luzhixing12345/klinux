<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/c.css /><link rel='stylesheet' href=../../../css/diff.css /><link rel='stylesheet' href=../../../css/json.css /><link rel='stylesheet' href=../../../css/makefile.css /><link rel='stylesheet' href=../../../css/shell.css /><link rel='stylesheet' href=../../../css/txt.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/klinux.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">总线</a><ul><li><a href="#h2-1">基本概念</a></li></ul><ul><li><a href="#h2-2">PCI</a></li></ul><ul><li><a href="#h2-3">PCIe</a></li></ul><ul><li><a href="#h2-4">南桥芯片组(south bridge)</a></li></ul><ul><li><a href="#h2-5">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">总线</h1><h2 id="h2-1">基本概念</h2><p>电脑当中不同的设备之间交互数据需要通路,比如CPU要和内存交互数据,那CPU就需要搭建一条通往内存的电路,CPU要和显卡交互数据,那CPU就要搭建一条通往显卡的电路,电脑当中不同设备交互数据的通路,就被我们称之为总线</p><p>总线毕竟是建立在物理学准则上的,你不可能瞬间把所有的数据秒传,因此总线和道路一样,数据传输也是有一定速度限制的,你在单位时间内只能传输一定数量的数据,总线的数据传输能力,就被我们成为<b>带宽(bandwidth)</b></p><p>总线又分为<b>串行总线</b>和<b>并行总线</b>, 常见的 USB 即 Universal Serial Bus 通用串行总线, 时至今日已经发展的很充分了</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303205648.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303205648.png" alt="20240303205648"></a></p><p>早些年的老式设备都是采用并行传输的,而现在的设备都采用串行传输. 那这不是退步了吗? 并行明显比串行好啊,4车道肯定比1车道要好啊,但是事实上并行改串行不仅不是退步,反而是巨大的进步</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303205114.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303205114.png" alt="20240303205114"></a></p><p>并行传输总线是多个数据同步传输,那就需要做到三个点</p><ul><li>传输数据出去之前,需要让数据排排站对齐好</li></ul><ul><li>传输过程中,也需要让数据排排站对齐好</li></ul><ul><li>到了目的地后,还需要让数据排排站对齐好</li></ul><p>而串行总线就一个一个传过去就可以了. 并行总线需要照顾数据的协同传输,这就导致了并行总线的频率不能做的很高. 而对于串行总线来讲就没有这个问题,因为只有一条链路, 我就可以把频率做的很高很高,速度上去了就弥补了虽然一次只能传输一个数据的缺陷了</p><blockquote><p>如果玩过FPS枪战射击游戏的同学应该知道,霰弹枪,也就是喷子,一次虽然可以喷出去很多子弹,但是霰弹枪的射速都不是很快,而机枪虽然一次只能发射一发子弹,但是可以做到很高的射速,这里霰弹枪就好比是并行总线,而机枪就好比是串行总线</p></blockquote><p>并行总线两根相邻的链路之间由于是数据同时传输的,就会导致严重的<b>干扰</b>,而且并行的链路越多,这种干扰就越强,因此并行总线还需要加强抗干扰的能力,否则传输过程中数据可能就会发生损坏,而如果真的传输过程中数据故障了,假设传送了10个数据过去,有两个因为干扰出问题了,那你就还需要重新对齐数据再传输,如果是串行总线,一个数据出错了,你只需要重新传一个过去就可以了</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303210201.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303210201.png" alt="20240303210201"></a></p><p>除此之外并行总线的接口也是很大的问题. 因为并行总线是多链路一块传输数据的,这就导致他需要很多线,然后接口需要很多的针脚,所以一些看老式计算机里的并行接口,就会发现这些线都是扁平的而且很宽(如下图 IDE cable 所示),就是因为并行的链路很多,而且接口也做的异常的大,针脚的数量也是异常的多,线宽,针脚多,接口大,这对装机来讲就造成了很多不必要的麻烦,比如走线不方便,接口体积大占地,然后针脚还容易不小心弄弯了,也正是因为并行总线的这些缺点,后来我们的电脑里的总线就逐渐全部从并行换代成了串行</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303210606.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303210606.png" alt="20240303210606"></a></p><p>这里值得一提的是对于 PCIe 接口看起来也是密密麻麻的并行接口,但其实 PCIe 是串行总线,只不过串行总线同样可以做多链路传输,不过和并行的多链路不一样,串行的多链路,每根链路是独立的数据,相互之间没有关系,不像并行那样所有链路的数据是同步的</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303210817.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303210817.png" alt="20240303210817"></a></p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303210945.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303210945.png" alt="20240303210945"></a></p><p>并行总线为了保证<b>数据的同步</b>,需要作出很多的牺牲,而串行总线虽然一次只能传输一个单位的数据,但是由于受到的限制少,可以把频率做的很高,这样就能把速度提上去了,因此<b>串行总线才是未来的主流</b>,所以我们的电脑都在使用串行总线而放弃了并行总线</p><h2 id="h2-2">PCI</h2><p>早些年在微型电脑进入普通民用家庭的时候,电脑当中不同的设备所使用的总线接口是完全不一样的,声卡用着声卡的接口,网卡用着网卡的接口,显卡用着显卡的接口,而且最要命的是,不同品牌的接口还不一样,这就导致了你选择一块主板后,其搭载了什么总线接口,你就可以使用什么样接口的设备,你将来升级也只能使用这个接口的设备,这样的情况就造成了很多的局限性,而且对于硬件规格的统一带来了很多的麻烦</p><p>为了解决这个情况当时业内的电脑巨头IBM就联合intel为他们的PC/AT电脑制定了一个接口的标准,这就是大名鼎鼎的ISA总线</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303215919.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303215919.png" alt="20240303215919"></a></p><p>由于兼容性好, ISA 在上个世纪80年代是最广泛采用的系统总线,不过它的弱点也是显而易见的,由于使用的是并行总线,加上当时的抗干扰技术不成熟,他的频率无法做到很高,所以他的带宽只能达到每秒8MB/s的速率,比现在的USB接口还要慢很多,而且你插上一个设备后不能自动配置,还需要你手动去分配资源,无法做到即插即用,而且ISA总线最大只支持到6个外围设备,此外这个接口依赖于特定CPU才可以使用,并且受到CPU外频的影响,更换CPU导致的外频变更,会波及到所有接驳到ISA总线上的设备</p><p>也正是因为ISA总线的这些弊端,再加上我们电脑当中一些外围设备的性能需求越来越高,所需要的带宽也越来越高,所以ISA总线就逐渐被淘汰了,而在这之后有很多厂商陆续推出了各种各样的总线想来统一市场,但是最后都是昙花一现,而最终统一天下的就是PCI总线了,于是后来在PC/98规范中,大家就开始放弃了ISA总线,取而代之的就是更为先进的PCI总线</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303220315.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303220315.png" alt="20240303220315"></a></p><p>PCI(Peripheral Component Interconnect)接口相对于ISA接口来讲,不仅提高了带宽, 还做到了即插即用,插上设备以后,可以自动配置,不需要你手动去分配资源了.</p><p>此外PCI也是一种不依赖于具体的某款CPU的独立总线,之前的ISA就必须要在指定的CPU上才可以用,此外PCI总线还解决了硬件中断共享的一些相关问题, 也因此取代了几个慢速工业标准体系结构 (ISA) 插槽和一个快速 VESA 本地总线 (VLB) 插槽的组合作为总线配置</p><p>但是PCI也有他的天生设计缺陷,PCI采用的依旧是和ISA一样的<b>并行传输</b>,所以他的频率依旧不能做的很高,虽然速度相对于ISA提高了不少,但是还是不够快,此外PCI是采用共享总线的机制,这就让高负载下很多设备会一块抢带宽,最后还有一个就是不支持热拔插, 因此最后让位于 PCI Express</p><h2 id="h2-3">PCIe</h2><p>所以为了解决PCI总线的这些缺陷,技术再一次进行了总线革新,这就是目前我们所用的PCIe总线了,PCIe有两个存在形态,一个是<b>接口</b>,一个是<b>通道</b>,当他以接口形式存在的时候,就是你主板上那横着的长槽</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303210817.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303210817.png" alt="20240303210817"></a></p><p>大多数人对于PCIe插槽的理解可能就只是插显卡,事实上,除了显卡,你还可以插PCIe接口的固态硬盘,PCIe接口的无线网卡,PCIe接口的有线网卡,PCIe接口的声卡,视频采集卡,你还可以把PCIe转接成其他的接口,比如PCIe转M.2,PCIe转USB,PCIe转Type-c,所以这个接口的用途真的是异常的广泛,几乎所有高带宽需求的外围设备都能插在这个接口上</p><blockquote><p>主板上的PCIe插槽通常标有它们拥有的PCIe通道数.有时,看似很大的插槽可能只有几条车道.例如,只有 4 个 PCIe 通道(底部插槽)的 x16 插槽很常见.</p></blockquote><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303222420.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303222420.png" alt="20240303222420"></a></p><p>PCIe除了作为接口形式存在,还可以作为通道的形式存在,比如主板上的M.2固态硬盘接口,他虽然外形是M.2,但是数据传输是依赖于PCIe通道的,所以这时候接口形状是M.2,PCIe在这里就承担数据传输总线的作用了</p><blockquote><p>关于 PCIe NVMe SATA M.2 等关于总线/协议/接口的知识会在 arch/disk 中介绍</p></blockquote><p>PCIe总线的带宽是按长度计算的,最短的是PCIe X1,然后是PCIe X2,PCIe X4P,CIe X8,最长的就是PCIe X16. X16的PCIe速度就是X8的2倍,X4就是X1的4倍</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303222924.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303222924.png" alt="20240303222924"></a></p><p>任何X16的设备都可以插在尾部非闭合的X1槽中运行,只不过这个设备肯定是没法发挥全部的性能了,你也可以把X1的设备插在X16的槽中运行,只不过这样就会浪费带宽了</p><p>PCIe1.0的时候单向传输X1的速度只有250MB/S,那X2就是500MB/S,X4也就1GB/S,X8的话是2GB/S,X16才4GB/S,而我们的显卡,硬盘,还有网卡这些设备速度在不断的提高,所以第一版PCIe的速度很快就不够用了,由于PCIe目前没有什么明显的使用缺陷,所以不需要进行大版本的技术革新和换代,我们只需要让他传输的速度更快就行了,接口的形状和通讯协议就不需要变动了,这样的话还可以做到向下兼容,一些1.0的设备还可以插到2.0上用,2.0的设备也可以插在1.0的接口上用,虽然会降速,但是总比不能用强</p><p>而PCIe2.0的时候速度就相对于1.0做到了翻倍,X1的速度为500MB/S,X2为1GB/S,X4为2GB/S,X8为4GB/S,X16为8GB/S,而后来2.0也不够快了,所以我们的工程师又把PCIe的版本进行了更新,升级到了3.0,也就是目前我们绝大多数电脑里正在使用的PCIe总线的版本了,只要你是近几年配的电脑,主板上的PCIe总线版本都是3.0</p><p>PCIe3.0的速度相对于2.0又进行了翻倍,X1的速度就可以达到了1GB/S,而X2就是2GB/S,X4就是4GB/S,X8就是8GB/S,X16就是16GB/S,所以我们这就可以解释一个问题了,为什么目前的M.2固态硬盘顺序读写速度最高就3G/s呢,是因为目前的M.2接口所使用的总线版本为均为PCIe3.0 X4,速率上限4GB/S,所以你是无论如何也不可能跑到4GB/S以上的,因为接口的速率上限就这么高</p><blockquote><p>准确来说应该是 M.2 固态硬盘是用的是 M.2 接口, 插在一个 PCIe 槽上, 由南桥到 CPU 的系统总线是用的是 PCIe3.0 X4, 最大速率是 4.0GB/s</p></blockquote><p>简单来说每隔一代 PCIe 升级其总线带宽就会翻倍, 如今最新的版本为 PCIe6.0</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303223715.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303223715.png" alt="20240303223715"></a></p><blockquote><p>这里的编码 8:10 指的是 8 位用于数据传输, 2 位用于校验</p></blockquote><h2 id="h2-4">南桥芯片组(south bridge)</h2><p>PCIE是一种高速传输总线,他既可以直接以接口的形式存在,也可以以通道的形式存在. 那既然PCIE这么快,那为什么我们不让所有的设备都使用这个接口或者总线呢?</p><p>确实是这样,想法很美好,我们自然希望电脑里所有的设备都使用超高速的总线,而不是现在这样够用就好,最大的问题还是受制于成本和市场,PCIE作为一种超高速串行总线,为了达到飞快的速度,所以他的<b>频率设置的异常的高</b>,这种高频率的总线就对总线的线路设计要求非常的高,比如屏蔽磁干扰这些,所以PCIE总线对于主板的布线来讲是一大考验,为了安排下这种高速总线,主板不得不做更多的层数来解决高频总线带来的种种需要</p><blockquote><p>PCIe设备通常需要更多的电力,并且可能会产生更多的热量.在对功率和热管理有特殊要求的环境中,如便携式设备或低功耗应用,可能会避免使用PCIe. PCIe插槽和连接器的物理尺寸可能不适合所有类型的设备.在空间受限的应用中,如嵌入式系统或紧凑型设备,可能会选择更小尺寸的接口. 而且并非所有设备都需要PCIe提供的高速数据传输能力.对于一些低速或低带宽需求的设备,使用更简单的总线可能就足够了</p></blockquote><p>PCIE之所以可以达到这么快的速度,是因为他直接接通在CPU的PCIE控制器上,所以他才可以做到超低的延迟,超高的速度,而CPU的PCIE控制器本身也不可能提供无限数量的PCIE通道,CPU也需要考虑电路的设计成本,所以我们的民用平台CPU目前都只提供有限的可用PCIE通道数量</p><p>电脑里所有的设备最终都是要和CPU通信的,比如显卡/声卡/网卡/内存/硬盘,他们的数据最终无论怎么去,都要汇入CPU才可以计算,所以这些设备就必须要能和CPU通信,但是电脑里的外围设备太多了啊,主板上那么多的电子元器件,你让所有的设备都去找CPU,这对主板的布线难度要求就直接提升了好几个档次. 但实际上<b>CPU没有必要实时去和所有的外围设备通信</b>, 对于一些慢速设备可以使用南桥芯片组将数据汇总以后再交给CPU</p><blockquote><p>通常可以在主板的右下角看到南桥芯片组</p></blockquote><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240205174656.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240205174656.png" alt="20240205174656"></a></p><p>由于内存太过重要,CPU就亲自直接和它对接,而直连PCIe的话,数据交互的实时要求也很高,也由CPU直接去负责,而其余的设备,比如声卡,网卡,固态硬盘,机械硬盘,USB这些对实时通讯要求不高的设备,就全部接入南桥,南桥收集好数据后再汇报给CPU就可以了</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303231927.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303231927.png" alt="20240303231927"></a></p><p>下图是一张intel Z390平台官方的结构图, 这里注意左上角一个细节,直连CPU的PCIE只有16条,要么单16,要么8+8,要么8+4+4,而我们的目前的显卡大部分使用的都是PCIeX16,那如果我插一块显卡,这16条通道就全部被占用了, 那么M.2固态硬盘用的也是PCIE,而且一下就用掉了PCIE X4,那我的M.2固态硬盘是不是就会和显卡抢带宽啊,插上了固态硬盘显卡是不是就变成X12了呢?</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303232356.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303232356.png" alt="20240303232356"></a></p><p>事实上在intel平台,我们的M.2固态硬盘使用的PCIE通道并不是直接来自CPU的, 我们可以看见下方南桥最大可以延伸出来24根非直连PCIE,我们的M.2使用的就是来自南桥的这些PCIE, 所以你的显卡不会和M.2去抢PCIE通道,显卡使用的是左上角直连的X16,而M2使用的则是来自南桥当中的其中4条</p><p>而AMD的Ryzen平台则有那么一点细微的差异,AMD的Ryzen CPU提供了20条直连的PCIE通道,其中16条分给了PCIE槽,而另外4条分给了其中的一个M.2,所以AMD的Ryzen平台上,大部分主板上的第一个M.2所使用的PCIE通道都是CPU直接提供的</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303232605.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303232605.png" alt="20240303232605"></a></p><p>比方说很火的B450M MORTAR迫击炮,其最上方的M.2就是直连CPU的PCIE3.0X4,而下方第二条M.2使用的则是来自南桥的PCIE2.0X4,而PCIE2.0X4的带宽只有2GB/S,所以如果你把你的固态插在了第二个槽上,他就无法跑到2GB/S以上的速度了</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303232724.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303232724.png" alt="20240303232724"></a></p><p>我们接着看回intel官方的结构图,CPU和主板南桥之间是通过一个叫DMI3.0的总线进行连接的</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303232356.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240303232356.png" alt="20240303232356"></a></p><p>实际上这个总线就是PCIE3.0 X4,AMD也比较实诚,直接就在自己的芯片组结构图上标注着PCIE.,也就是说,CPU和南桥之间的数据带宽上限为PCIE3.0 X4,也就是4GB/S,所以我们这里就可以解释另外一个问题了,为什么目前的固态硬盘,包括M.2接口大部分都是使用PCIE3.0X4的总线了,因为目前的M.2都是接在南桥的,而南桥和CPU之间的总线速率上限是PCIE3.0 X4,所以所有接驳到南桥上的设备,其速率都无法超过4GB/S,</p><p>那么南桥明明可以分出24根PCIE,那为什么南桥和CPU之间却只开放一个PCIE3.0 X4的小水管呢? 原因很简单,那就是<b>接驳到南桥上的设备,通常来讲不会全部同时工作</b>,你的硬盘声卡网卡还有USB以及光驱,在大多数情况都只是一两个设备在传输,就算好几个设备同时从南桥往CPU传输数据,这几个设备也不太可能同时都是满载状态,可能确实存在这个情况,但是概率太低了</p><blockquote><p>假设一个停车场能停100辆车,但是不代表他的出入口也需要修成100条车道宽,因为这100辆车不太可能同时进出,在一瞬间内,也就几辆而已,所以就留两条路,一个进一个出就完全够用了,2车道在100辆车面前虽然显得很少,但是够用了, 南桥通往CPU的这个DMI3.0同理,虽然只有PCIE3.0 X4的速度也就是4GB/S,但是南桥上的设备同时满载的可能性太低,所以以目前的情况来讲是完全够用的</p></blockquote><h2 id="h2-5">参考</h2><ul><li><a href="https://www.bilibili.com/video/BV1jt411L7sg/" target="_blank">【硬核科普】一根线传输效率比多根线高?详解串并行总线的工作原理与优劣</a></li></ul><ul><li><a href="https://en.wikipedia.org/wiki/USB" target="_blank">USB</a></li></ul><ul><li><a href="https://www.lifewire.com/pci-express-pcie-2625962" target="_blank">What Is PCI Express (PCIe)?</a></li></ul><ul><li><a href="https://www.bilibili.com/video/BV1n4411m7HX/" target="_blank">【硬核科普】PCIe到底是个什么东西?他在电脑里是干什么的?</a></li></ul><ul><li><a href="https://www.bilibili.com/video/BV1cJ411K7HW/" target="_blank">【硬核科普】电脑主板右下角的散热片下面究竟隐藏着什么?详解主板南桥芯片组的功能和作用</a></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../快速开始/编译内核" >快速开始</a><ul><li><a href="../../快速开始/编译内核" >编译内核</a></li></ul><ul><li><a href="../../快速开始/调试内核" >调试内核</a></li></ul><ul><li><a href="../../快速开始/开发环境搭建" >开发环境搭建</a></li></ul><ul><li><a href="../../快速开始/制作linux发行版" >制作linux发行版</a></li></ul><ul><li><a href="../../快速开始/邮件订阅" >邮件订阅</a></li></ul><ul><li><a href="../../快速开始/patch" >patch</a></li></ul></li></ul><ul><li><a href="../../mm/detect" >mm</a><ul><li><a href="../../mm/detect" >detect</a></li></ul><ul><li><a href="../../mm/va_trans" >va_trans</a></li></ul><ul><li><a href="../../mm/numa" >numa</a></li></ul><ul><li><a href="../../mm/buddy" >buddy</a></li></ul><ul><li><a href="../../mm/slab" >slab</a></li></ul><ul><li><a href="../../mm/compaction" >compaction</a></li></ul><ul><li><a href="../../mm/tier" >tier</a></li></ul><ul><li><a href="../../mm/migration" >migration</a></li></ul><ul><li><a href="../../mm/mm_struct" >mm_struct</a></li></ul><ul><li><a href="../../mm/mmio" >mmio</a></li></ul></li></ul><ul><li><a href="../../fs/storage" >fs</a><ul><li><a href="../../fs/storage" >storage</a></li></ul><ul><li><a href="../../fs/filesystem" >filesystem</a></li></ul><ul><li><a href="../../fs/fd" >fd</a></li></ul><ul><li><a href="../../fs/inode" >inode</a></li></ul><ul><li><a href="../../fs/directory" >directory</a></li></ul><ul><li><a href="../../fs/disk-layout" >disk-layout</a></li></ul><ul><li><a href="../../fs/mount" >mount</a></li></ul><ul><li><a href="../../fs/vfs" >vfs</a></li></ul><ul><li><a href="../../fs/ext4" >ext4</a></li></ul><ul><li><a href="../../fs/fuse" >fuse</a></li></ul><ul><li><a href="../../fs/distribute-fs" >distribute-fs</a></li></ul></li></ul><ul><li><a href="../../runtime/proc" >runtime</a><ul><li><a href="../../runtime/proc" >proc</a></li></ul><ul><li><a href="../../runtime/vsdo" >vsdo</a></li></ul><ul><li><a href="../../runtime/elf_format" >elf_format</a></li></ul><ul><li><a href="../../runtime/elf_loader" >elf_loader</a></li></ul><ul><li><a href="../../runtime/ld" >ld</a></li></ul></li></ul><ul><li><a href="../../kernel/init" >kernel</a><ul><li><a href="../../kernel/init" >init</a></li></ul><ul><li><a href="../../kernel/atomic" >atomic</a></li></ul><ul><li><a href="../../kernel/rcu" >rcu</a></li></ul><ul><li><a href="../../kernel/workqueue" >workqueue</a></li></ul><ul><li><a href="../../kernel/lock" >lock</a></li></ul></li></ul><ul><li><a href="../../arch/cpu" >arch</a><ul><li><a href="../../arch/cpu" >cpu</a></li></ul><ul><li><a href="../../arch/cache" >cache</a></li></ul><ul><li><a href="../../arch/multicore" >multicore</a></li></ul><ul><li><a href="../../arch/cache-co" >cache-co</a></li></ul><ul><li><a href="../../arch/memory-co" >memory-co</a></li></ul><ul><li><a href="../../arch/bus" >bus</a></li></ul><ul><li><a href="../../arch/interrupt" >interrupt</a></li></ul></li></ul><ul><li><a href="../../proc/schedule" >proc</a><ul><li><a href="../../proc/schedule" >schedule</a></li></ul><ul><li><a href="../../proc/nice" >nice</a></li></ul><ul><li><a href="../../proc/manage" >manage</a></li></ul><ul><li><a href="../../proc/signal" >signal</a></li></ul><ul><li><a href="../../proc/cgroup" >cgroup</a></li></ul><ul><li><a href="../../proc/task_struct" >task_struct</a></li></ul><ul><li><a href="../../proc/rb-tree" >rb-tree</a></li></ul></li></ul><ul><li><a href="../../net/net-arch" >net</a><ul><li><a href="../../net/net-arch" >net-arch</a></li></ul><ul><li><a href="../../net/ip" >ip</a></li></ul><ul><li><a href="../../net/route" >route</a></li></ul><ul><li><a href="../../net/udp" >udp</a></li></ul><ul><li><a href="../../net/tcp" >tcp</a></li></ul><ul><li><a href="../../net/tools" >tools</a></li></ul></li></ul><ul><li><a href="../../device/io" >device</a><ul><li><a href="../../device/io" >io</a></li></ul><ul><li><a href="../../device/disk" >disk</a></li></ul><ul><li><a href="../../device/ssd" >ssd</a></li></ul><ul><li><a href="../../device/driver" >driver</a></li></ul><ul><li><a href="../../device/io_uring" >io_uring</a></li></ul></li></ul><ul><li><a href="../../others/safety" >others</a><ul><li><a href="../../others/safety" >safety</a></li></ul><ul><li><a href="../../others/Q&A" >Q&A</a></li></ul></li></ul><ul><li><a href="../../driver/intro" >driver</a><ul><li><a href="../../driver/intro" >intro</a></li></ul><ul><li><a href="../../driver/usb" >usb</a></li></ul><ul><li><a href="../../driver/pcie" >pcie</a></li></ul></li></ul><ul><li><a href="../../cve/dirtycow" >cve</a><ul><li><a href="../../cve/dirtycow" >dirtycow</a></li></ul><ul><li><a href="../../cve/dirtypipe" >dirtypipe</a></li></ul><ul><li><a href="../../cve/sudo" >sudo</a></li></ul><ul><li><a href="../../cve/meltdown" >meltdown</a></li></ul><ul><li><a href="../../cve/smashex" >smashex</a></li></ul></li></ul><ul><li><a href="../../perf/perf" >perf</a><ul><li><a href="../../perf/perf" >perf</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../arch/memory-co","../../arch/interrupt","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script>
            <script src="https://giscus.app/client.js" data-repo="luzhixing12345/klinux" 
            data-repo-id="R_kgDOJIKiEw" data-category="Q&A" data-category-id="DIC_kwDOJIKiE84CgFwK" data-mapping="pathname" data-strict="0"
            data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom"
            data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async>
            </script>
            <script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>