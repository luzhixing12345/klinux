<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/c.css /><link rel='stylesheet' href=../../../css/json.css /><link rel='stylesheet' href=../../../css/makefile.css /><link rel='stylesheet' href=../../../css/shell.css /><link rel='stylesheet' href=../../../css/txt.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/klinux.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">multicore</a><ul><li><a href="#h2-1">动机</a><ul><li><a href="#h3-2">摩尔定律失效</a></li></ul><ul><li><a href="#h3-3">性能问题</a></li></ul><ul><li><a href="#h3-4">并行性技术</a></li></ul></li></ul><ul><li><a href="#h2-5">多核处理器发展历史</a></li></ul><ul><li><a href="#h2-6">并行计算</a></li></ul><ul><li><a href="#h2-7">多处理器体系结构</a><ul><li><a href="#h3-8">UMA</a></li></ul><ul><li><a href="#h3-9">NUMA</a></li></ul><ul><li><a href="#h3-10">指令和数据</a></li></ul></li></ul><ul><li><a href="#h2-11">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">multicore</h1><p>提高处理器性能通常的办法是<b>提高主频</b>,但这样做会增加处理器的功耗和设计的复杂度,高频率所带来的高发热量会导致芯片运行不稳定,且处理器发展到今天,主频的提升空间已经不大;</p><p>在单核计算时,提高性能的并行手段是用superscalar(<b>超标量</b>)处理器的方式,使处理器在一个周期内执行多条指令,通常超标量处理器有两个或多个处理单元为充分利用这些硬件资源需要对软件进行精心设计,且为适应多流水线需要对软件进行大量修改,可移植性较差;</p><p>除此之外就是通过超流水线的方式提高频率,但是超流水线已有三十多级,已经达到瓶颈.因此,从指令级上提升性能已经达到极限.同时存在存储器访问速度与处理器运行速度不匹配的情况.这些势必影响计算机系统总体性能的提高</p><p>频率只是CPU性能指标之一而已, 架构先进程度, 制程工艺, 缓存大小快慢, 核心数量等等都是判断一个 CPU 是否优秀的重要指标</p><h2 id="h2-1">动机</h2><p>多核处理器是指在一枚处理器中集成两个或多个完整的计算引擎(内核),此时处理器能支持系统总线上的多个处理器,由总线控制器提供所有总线控制信号和命令信号. 如今市面上几乎所有的处理器都是多核处理器, 这其实是历史发展的必然原因, 主要有如下三个方面的因素</p><h3 id="h3-2">摩尔定律失效</h3><p>由于时钟速度受到流水线中最长、最慢阶段的限制,所以我们可以将构成每个阶段的逻辑门进行细分,特别是比较长的阶段,从而将流水线转换为具有更多短阶段的更深的超流水线. 这样整个处理器可以以更高的时钟速度运行.</p><p>现代计算机实现技术的基础核心是以晶体管为基本单元的平面集成电路. 1965年,时任仙童公司研发实验室主任的摩尔(GordonMooer)在Electronics上撰文,认为<b>集成电路芯片上所集成的晶体管数目每隔18个月就翻一倍</b>,这就是著名的摩尔定律.40年来,摩尔定律不但印证了集成电路技术的发展,也印证了计算机技术的发展. 下图展示了内存芯片和Intel微处理器的发展变化.</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240219181447.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240219181447.png" alt="20240219181447"></a></p><p>指数式增长速度是非常可怕的, 因此摩尔定律是不可能永远或者长期无限发展下去的,这个定律能维持50余年,已经堪称集成电路设计制造人员创造的奇迹.</p><p>近些年摩尔定律的速度已经放缓了,很多人声称摩尔定律已经失效、集成电路进入后摩尔时代,但芯片设计制造人员一直在不断改进设计与制造工艺为摩尔定律续命. 未来CPU的发展趋势应该是降低功耗、优化性能设计、提高功效等,而不是单纯的堆叠晶体管数量.</p><h3 id="h3-3">性能问题</h3><ul><li>功耗墙</li></ul><ul><li>ILP墙</li></ul><ul><li>内存墙</li></ul><p>-&gt; 在晶体管数量无法提升的情况下如何提高性能 =&gt; 多核</p><h3 id="h3-4">并行性技术</h3><p>现在基于WEB的许多应用都要求并行进行, 对并行性技术要求愈来愈高. 尤其在网络和服务器方面,对于 IO 的处理能力有很高的要求.这些领域对性能要求的增长速度远非单个CPU处理能力所能及的.所有这些都要求处理器朝着多核多线程的并行性技术方向发展.</p><h2 id="h2-5">多核处理器发展历史</h2><p>在一块芯片上集成的晶体管数目越多,意味着运算速度即主频就更快.但到了2005年,当主频接近4GHz时,英特尔和AMD发现,速度也会遇到自己的极限:那就是<b>单纯的主频提升,已经无法明显提升系统整体性能.</b></p><p>以英特尔发布的采用NetBurst架构的奔腾四CPU为例,它包括Willamette、Northwood和Prescott等三种采用不同核心的产品.利用冗长的运算流水线,即增加每个时钟周期同时执行的运算个数,就达到较高的主频.这三种处理器的最高频率,分别达到了2.0G、3.4G和3.8G.</p><blockquote><p>Wilamette 和 Northwood 内核包含一个 20 级指令流水线.与Pentium III相比,这是级数的显着增加,Pentium III的管道中只有10个级.普雷斯科特岩芯将管道的长度增加到 31 级.较长管道的一个缺点是,在分支错误预测的情况下,需要追溯的阶段数量增加,从而增加了所述错误预测的惩罚.为了解决这个问题,英特尔设计了快速执行引擎,并在其分支预测技术上投入了大量资金,英特尔声称该技术比奔腾 III 减少了 33% 的分支错误预测. 实际上,由于功耗和热量增加大于预期,无法达到足够高的时钟速度以抵消性能损失,因此较长的流水线通过执行的每时钟指令数 (IPC) 减少导致效率降低.</p></blockquote><p>按照当时的预测,奔腾四在该架构下,最终可以把主频提高到10GHz.但由于流水线过长,使得单位频率效能低下,加上由于缓存的增加和漏电流控制不利造成功耗大幅度增加,3.6GHz奔腾四芯片在性能上反而还不如早些时推出的3.4GHz产品.所以奔腾系列只达到3.8G,就戛然而止.</p><p>英特尔上海公司一位工程师在接受记者采访时表示,Netburst微架构的好处在于方便提升频率,可以让产品的<b>主频非常高.但性能提升并不明显</b>,频率提高50%,性能提升可能微不足道.因为Netburst<b>微架构的效率较低,CPU计算资源未被充分利用</b>,就像开车时&quot;边踩刹车边踩油门&quot;.</p><p>此外,随着功率增大,<b>散热</b>问题也越来越成为一个无法逾越的障碍.据测算,主频每增加1G,功耗将上升25瓦,而在芯片功耗超过150瓦后,<b>现有的风冷散热系统将无法满足散热的需要</b>.3.4GHz的奔腾四至尊版,晶体管达1.78亿个,最高功耗已达135瓦. 一些发烧友也会尝试超频的实际上,在奔腾四推出后不久,就在批评家那里获得了&quot;电炉&quot;的美称.更有好事者用它来玩煎蛋的游戏.</p><p>很显然,当晶体管数量增加导致功耗增长超过性能增长速度后,处理器的可靠性就会受到致命性的影响.就连戈登摩尔本人似乎也依稀看到了&quot;主频为王&quot;这条路的尽头</p><p>多核心CPU解决方案(多核)的出现,似乎给人带来了新的希望.早在上世纪90年代末,就有众多业界人士呼吁用CMP(单芯片多处理器)技术来替代复杂性较高的单线程CPU.IBM、惠普、Sun等高端服务器厂商,更是相继推出了多核服务器CPU.不过,由于服务器价格高、应用面窄,并未引起大众广泛的注意.</p><p>直到AMD抢先手推出64位处理器后,英特尔才想起利用&quot;多核&quot;这一武器进行&quot;帝国反击战&quot;.2005年4月,英特尔仓促推出简单封装双核的奔腾D和奔腾四至尊版840.AMD在之后也发布了双核皓龙(Opteron)和速龙(Athlon) 64 X2和处理器.但真正的&quot;双核元年&quot;,则被认为是2006年.这一年的7月23日,英特尔基于酷睿(Core)架构的处理器正式发布.2006年11月,又推出面向服务器、工作站和高端个人电脑的至强(Xeon)5300和酷睿双核和四核至尊版系列处理器.与上一代台式机处理器相比,酷睿2 双核处理器在性能方面提高40%,功耗反而降低40%.作为回应,7月24日,AMD也宣布对旗下的双核Athlon64 X2处理器进行大降价.由于功耗已成为用户在性能之外所考虑的首要因素,两大处理器巨头都在宣传多核处理器时,强调其&quot;节能&quot;效果.英特尔发布了功耗仅为50瓦的低电压版四核至强处理器.而AMD的&quot;Barcelona&quot;四核处理器的功耗没有超过95瓦.</p><h2 id="h2-6">并行计算</h2><p>Definition: &quot;A parallel computer is a collection of processing elements that <b>cooperate and communicate</b> to solve large problems fast.&quot;</p><blockquote><p>&quot;并行计算机是处理元件的集合,它们通过<b>合作和通信</b>快速解决大型问题.</p></blockquote><p>Parallel architecture = <b>computing</b> model + <b>communication</b> model</p><p>在处理并行任务中, 计算和通信都是很重要的环节, 其中我们重点关注多处理器的通信部分. 通信模型分为两种:</p><ul><li>共享地址: 通过 load/store 通信, 需要显式同步, 因为接收核心需要知道存储何时发生</li></ul><ul><li>消息传送: 通过消息通信, 隐式同步, 因为传输消息的时候就已经完成了同步</li></ul><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121114050.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121114050.png" alt="20240121114050"></a></p><p>下文我们重点看一下共享地址的多处理器体系结构的情况</p><h2 id="h2-7">多处理器体系结构</h2><p>提高硬件性能最简单,最便宜的方法之一是在主板上放置多个 CPU.这可以通过让不同的 CPU 承担不同的作业(非对称多处理)或让它们全部并行运行来完成相同的作业(对称多处理,又名 SMP)来完成.有效地进行非对称多处理需要有关计算机应执行的任务的专业知识,而这在 Linux 等通用操作系统中是不可用的.另一方面,对称多处理相对容易实现.</p><blockquote><p>相对容易但并不是真的很容易.在对称多处理环境中,CPU 共享相同的内存,因此在一个 CPU 中运行的代码可能会影响另一个 CPU 使用的内存.无法再确定在上一行中设置为某个值的变量仍然具有该值;显然,这样的编程是不可能的.</p></blockquote><p>在共享内存地址又分为两种模式, SMP 和 DSM</p><ul><li><b>SMP</b>(Symmetrical Multi-Processing): 即对称多处理技术,是指将<b>多CPU汇集在同一总线上,各CPU间进行内存和总线共享的技术</b>.将同一个工作平衡地(run in parallel)分布到多个CPU上运行,该相同任务在不同CPU上共享着相同的物理内存; 其内存组织是<b>集中式</b>的; 内存访问模型是均匀的, 称为 <b>UMA</b>(uniform memory access)</li></ul><ul><li><b>DSM</b>(distribute share memory): 即分布式共享存储器, 将存储器分散在节点之间, 各节点的 CPU 有本地的内存和远端内存, 访问时间不均匀; 其内存组织形式是<b>分布式</b>的; 内存访问模型是不均匀的, 称为 <b>NUMA</b>(non-uniform memory access)</li></ul><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121120723.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121120723.png" alt="20240121120723"></a></p><h3 id="h3-8">UMA</h3><p>Uniform Memory Access,简称UMA, 即均匀存储器存取模型.<b>所有处理器对所有内存有相等的访问时间</b></p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119232539.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119232539.png" alt="20240119232539"></a></p><p>既然要连接多个 CPU 和内存, 这种 UMA 的方式很明显是最简单直接的, 每个 CPU 访问内存的时间是相同的, 整个模型是完全对称的; 但问题也同样明显, <b>BUS 会成为性能的杀手</b>. <b>多个 CPU 需要平分总线的带宽, 这显然非常不利于计算</b>.</p><p>x86多处理器发展历史上,早期的多核和多处理器系统都是UMA架构的.这种架构下, 多个CPU通过同一个北桥(North Bridge)芯片与内存链接.北桥芯片里集成了内存控制器(Memory Controller),</p><p>下图是一个典型的早期 x86 UMA 系统,四路处理器通过 FSB (前端系统总线, Front Side Bus) 和主板上的内存控制器芯片 (MCH, Memory Controller Hub) 相连, CPU 通过 PCH 访问内存, DRAM 是以 UMA 方式组织的,延迟并无访问差异.</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/numa-fsb-3.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/numa-fsb-3.png" alt="image"></a></p><h3 id="h3-9">NUMA</h3><p>基于总线的计算机系统有一个瓶颈, 有限的带宽会导致可伸缩性问题.系统中添加的CPU越多,每个节点可用的带宽就越少.此外,添加的CPU越多,总线就越长, 延迟也就越高.</p><p>因此在另一种设计方法中, 多处理器采用物理分布式存储器, 为了支持更多的处理器, 存储器必须分散在处理器之间, 而不应当是集中式的;</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240120202032.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240120202032.png" alt="20240120202032"></a></p><p>将存储器分散在节点之间, 既增加了带宽, 也缩短了到本地存储器的延迟. DSM 多处理器也被称为 NUMA(非一致存储器访问), 这是因为它的<b>访问时间取决于数据字在存储器的位置.</b> DSM 的关键缺点是处理器之间传送数据的过程变得复杂了一些, 需要在软件中多花一些力气, 以充分利用分布式存储器提升的存储器带宽.</p><p>与UMA不同的是,<b>在NUMA中每个处理器有属于自己的本地物理内存(local memory),对于其他CPU来说是远程物理内存(remote memory)</b>.一般而言,访问本地物理内存由于路径更短,其访存时间要更短.</p><p>在 SMP(对称多处理技术) 和 DSM(分布式共享存储器) 这两种体系结构中, <b>线程之间的通信是通过共享地址空间完成的, 存储器的地址统一编码, 任何一个拥有正确寻址权限的处理器都可以向任意存储器位置发出存储器引用</b>. 共享存储器的含义就是指共享地址空间.</p><h3 id="h3-10">指令和数据</h3><p>单指令多数据 SIMD 和多指令多数据 MIMD</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121114417.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121114417.png" alt="20240121114417"></a></p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121114511.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121114511.png" alt="20240121114511"></a></p><h2 id="h2-11">参考</h2><ul><li><a href="https://www.163.com/dy/article/FLPKHUFL0511FQO9.html" target="_blank">仙童半导体和&quot;八叛逆&quot;所缔造的硅谷模式</a></li></ul><ul><li><a href="https://foxsen.github.io/archbase/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%84.html" target="_blank">多核处理结构.html</a></li></ul><ul><li><a href="https://www.zhihu.com/question/20809971/answer/1678502542" target="_blank">多核之后,CPU 的发展方向是什么?的回答</a></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/427398869" target="_blank">谈谈多核处理器</a></li></ul><ul><li>多核多线程处理器的发展及其软件系统架构</li></ul><ul><li><a href="https://baike.baidu.com/item/%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8/10278420" target="_blank">多核处理器</a></li></ul><ul><li><a href="https://zhidao.baidu.com/question/435213422142183884.html" target="_blank">多核处理器的发展历程</a></li></ul><ul><li><a href="https://www.zhihu.com/question/321291471/answer/660183713" target="_blank">如何理解处理器、CPU、多处理器、内核、多核?的回答</a></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../快速开始/编译内核" >快速开始</a><ul><li><a href="../../快速开始/编译内核" >编译内核</a></li></ul><ul><li><a href="../../快速开始/调试内核" >调试内核</a></li></ul><ul><li><a href="../../快速开始/制作文件系统" >制作文件系统</a></li></ul><ul><li><a href="../../快速开始/制作linux发行版" >制作linux发行版</a></li></ul><ul><li><a href="../../快速开始/linux目录结构" >linux目录结构</a></li></ul><ul><li><a href="../../快速开始/邮件订阅" >邮件订阅</a></li></ul></li></ul><ul><li><a href="../../mm/物理布局探测" >mm</a><ul><li><a href="../../mm/物理布局探测" >物理布局探测</a></li></ul><ul><li><a href="../../mm/NUMA" >NUMA</a></li></ul><ul><li><a href="../../mm/buddy" >buddy</a></li></ul><ul><li><a href="../../mm/slab分配器" >slab分配器</a></li></ul><ul><li><a href="../../mm/memory compaction" >memory compaction</a></li></ul></li></ul><ul><li><a href="../../runtime/proc" >runtime</a><ul><li><a href="../../runtime/proc" >proc</a></li></ul><ul><li><a href="../../runtime/vsdo" >vsdo</a></li></ul><ul><li><a href="../../runtime/elf_format" >elf_format</a></li></ul><ul><li><a href="../../runtime/elf_loader" >elf_loader</a></li></ul></li></ul><ul><li><a href="../../kernel/init" >kernel</a><ul><li><a href="../../kernel/init" >init</a></li></ul></li></ul><ul><li><a href="../../arch/cpu" >arch</a><ul><li><a href="../../arch/cpu" >cpu</a></li></ul><ul><li><a href="../../arch/cache" >cache</a></li></ul><ul><li><a href="../../arch/multicore" >multicore</a></li></ul><ul><li><a href="../../arch/cache-coherence" >cache-coherence</a></li></ul><ul><li><a href="../../arch/memory-coherence" >memory-coherence</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../arch/cache","../../arch/cache-coherence","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>