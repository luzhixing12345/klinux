<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/c.css /><link rel='stylesheet' href=../../../css/diff.css /><link rel='stylesheet' href=../../../css/json.css /><link rel='stylesheet' href=../../../css/makefile.css /><link rel='stylesheet' href=../../../css/shell.css /><link rel='stylesheet' href=../../../css/tree.css /><link rel='stylesheet' href=../../../css/txt.css /><link rel='stylesheet' href=../../../css/x86asm.css /><link rel='stylesheet' href=../../../css/yaml.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/klinux.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">路由</a><ul><li><a href="#h2-1">什么是路由？</a></li></ul><ul><li><a href="#h2-2">域内路由和域间路由</a><ul><li><a href="#h3-3">域内路由</a></li></ul><ul><li><a href="#h3-4">域间路由</a></li></ul></li></ul><ul><li><a href="#h2-5">路由表</a><ul><li><a href="#h3-6">路由与转发</a></li></ul></li></ul><ul><li><a href="#h2-7">路由算法</a><ul><li><a href="#h3-8">距离矢量协议</a></li></ul><ul><li><a href="#h3-9">链路状态协议</a></li></ul></li></ul><ul><li><a href="#h2-10">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">路由</h1><p>本文我们会讨论路由相关的问题，我们将会解决一个核心问题：两台都连接到互联网的机器是如何找到彼此的？</p><p>在正式开始之前我们需要创建一个简化的互联网模型，以帮助我们正式定义路由问题。如果我有很多台机器，应当以何种方式将它们互连起来呢？</p><p>一种简单的方式是使用单条链路连接所有机器，或者在每两台机器之间建立连接，它们分别被称为<b>单链路网络拓扑</b>和<b>全网状网络拓扑</b>，但是很显然这两种方式都有明显的缺点</p><ul><li>单链路网络拓扑每个机器可用的带宽有限，只有一个链路，所有五台机器都需要共享这条链路上的带宽</li></ul><ul><li>全网状网络拓扑扩展性很差，每当有一台新计算机加入网络，我们就必须在它和世界上所有其他计算机之间创建新的连接。</li></ul><p>为了创建更复杂的网络拓扑结构，我们很自然的引入了<b>路由器</b>的概念</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20251201105611.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20251201105611.png" alt="20251201105611" class="pic-small"></a></p><p>我们将每台机器归类为以下两种类型之一：<b>主机</b>和<b>路由器</b>。终端主机是指连接到互联网以发送和接收数据的计算机，路由器是连接到互联网的设备，负责接收和转发中间数据包。在你日常使用互联网时，你可能需要向谷歌服务器发送数据包来进行搜索，但你可能不需要直接向你的家用路由器或数据中心发送消息。这些路由器会帮助你将数据包转发给谷歌，但它们并不是数据包的最终目的地。</p><blockquote style="border-left-color: #0969da; background-color: #e8f3ff;"><div style="color: #0969da;"><img class="icon-note" loading="lazy" src="../../../img/note.svg" alt="[!NOTE]"> NOTE </div><p> 根据网络设计，路由器可能成为合法的目的地，但本文中我们将忽略路由器作为目的地的情况。不过，需要注意的是，路由器也可能成为发件人，并发送自己的数据包。</p></blockquote><p>有了路由器，我们可以很自然的创建更复杂的网络拓扑结构，这种拓扑结构也更具容错性。即使某条链路发生故障，数据包也可以通过网络中的其他路径到达目的地。</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20251201151450.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20251201151450.png" alt="20251201151450" class="pic-big"></a></p><h2 id="h2-1">什么是路由？</h2><p>假设机器 A 和机器 B 都连接到互联网。机器 A 想向机器 B 发送一条消息，但这两台机器并非直接相连。机器 A 如何知道应该将消息发送到哪里，才能最终到达机器 B？消息在网络中会经过哪条路径才能到达机器 B？</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20251130223300.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20251130223300.png" alt="20251130223300" class="pic-middle"></a></p><p>设计一个好的路由协议实际上是一个相当困难的过程，因为<b>网络拓扑结构瞬息万变</b>。例如，链路可能会在不可预测的时间发生故障，新的主机随时可能接入/断开了网络。如果网络发生变化，我们需要及时更新图，然后计算新图中的路径来解决路由问题。</p><p>路由的另一个难点在于，<b>路由器本身并不具备对整个网络的全局概览</b>。例如，如果网络中某处的链路发生故障，所有路由器无法自动获知。我们需要通过路由协议，将新的网络拓扑信息传递给所有路由器。路由器R2仅能感知到和自己相连的R1/R3，这导致路由协议通常是分布式协议，需要所有路由器计算出的答案共同构成路由问题的全局答案。</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20251201153347.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20251201153347.png" alt="20251201153347" class="pic-big"></a></p><h2 id="h2-2">域内路由和域间路由</h2><p>由于互联网的规模庞大，我们不可能设计一个单一的巨型路由协议。相反，我们将利用互联网是由众多网络组成的网络这一特性。</p><p>互联网由许多本地网络构成。每个本地网络都实现了自己的路由协议，用于定义如何在该本地网络内部发送数据包。然后，我们可以将所有这些本地网络连接起来，并实现一个跨所有本地网络的路由协议，用于定义如何在不同的本地网络之间发送数据包。</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20251130223650.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20251130223650.png" alt="20251130223650" class="pic-big"></a></p><h3 id="h3-3">域内路由</h3><p>本地网络并非完全相同。例如，它们的规模可能不同：有些网络可能拥有比其他网络更多的设备。或者，这些设备可能分布在更大的物理区域（例如整个学校校园）或更小的区域（例如您的家中）。网络在所需带宽、允许的故障率、可用支持人员数量、基础设施的年限、用于建设和维护的资金等方面也可能存在差异。</p><p>由于每个网络都有其自身的结构和需求，不同的本地网络可能会选择使用不同的路由协议。一种数据包路由策略在一个网络上可能有效，但在另一个网络上则可能无效。因此各个本地网络应当为其网络内的数据包选择路由策略。每个运营商都可以选择最适合自己的协议。</p><p>用于在本地网络内路由数据包的协议称为<b>域内</b>路由协议，或<b>内部网关协议 (IGP)</b> 。实际应用案例包括 OSPF（开放最短路径优先）和 IS-IS（中间系统到中间系统）。</p><blockquote><p>稍后会详细介绍每种协议</p></blockquote><h3 id="h3-4">域间路由</h3><p>相比之下，用于跨不同网络路由数据包的协议被称为<b>域间</b>路由协议，或<b>外部网关协议（EGP）</b> 。为了支持跨不同本地网络发送数据包，每个网络都需要同意使用相同的协议来彼此路由数据包。如果不同的网络使用不同的域间协议，就无法保证整个互联网能够以一致的方式连接。例如，如果一个运营商只实现了协议 X，而另一个运营商只实现了协议 Y，那么这两个本地网络将如何交换消息就不得而知了。</p><p>由于每个网络都必须同意使用相同的域间协议，因此互联网上大规模实施的<b>域间路由协议只有一种</b>，即 <b>BGP</b>（边界网关协议）。</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20251130230123.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20251130230123.png" alt="20251130230123" class="pic-big"></a></p><blockquote style="border-left-color: #0969da; background-color: #e8f3ff;"><div style="color: #0969da;"><img class="icon-note" loading="lazy" src="../../../img/note.svg" alt="[!NOTE]"> NOTE </div><p> 值得一提的是，域内路由和域间路由的模型便于读者理解互联网设备如何互连起来，但在实践中，二者之间的界限并不总是那么清晰。例如，BGP 除了用于不同网络之间之外，有时也会用于局域网内部。</p></blockquote><h2 id="h2-5">路由表</h2><p>在我们的网络模型中，每个路由器都有一定数量的出链路，将其连接到相邻的路由器和主机。换句话说，在底层图中，每个路由器节点都有一定数量的邻居节点，这些邻居节点通过一条边与该路由器相连。</p><p>当路由器收到一个数据包，其元数据中包含最终目的地信息时，路由器需要决定将数据包转发到哪个相邻的路由器或主机。数据包将被转发到的下一个中间路由器称为下一跳</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20251130181224.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20251130181224.png" alt="20251130181224" class="pic-middle"></a></p><p>例如，考虑以下网络。如果 R2 收到一个最终目的地为 B 的数据包，那么自然的下一跳是 R3。如果 R2 收到的数据包的最终目的地是 A，那么自然的下一跳就是 R1。对于每个可能的最终目的地，我们可以写下对应的下一跳，以便将数据包转发到更靠近该目的地的位置。这个结果称为<b>路由表</b>。</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20251130181243.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20251130181243.png" alt="20251130181243" class="pic-middle"></a></p><blockquote style="border-left-color: #0969da; background-color: #e8f3ff;"><div style="color: #0969da;"><img class="icon-note" loading="lazy" src="../../../img/note.svg" alt="[!NOTE]"> NOTE </div><p> 请注意，在目标地址到下一跳的映射中，一个下一跳可以被多次使用。例如，在 R2 的转发表中，发往 B 的数据包和发往 C 的数据包都会被转发到 R3。</p></blockquote><p>路由表可以理解为是一个键值对，如下图所示。一个从A发往B的数据包经过R2时，R2会查询它本地的路由表，发现对于目的地B的数据包应该发往R3路由器。在真实的物理世界中，路由器通常不会将目的地映射到下一跳，而是映射到<b>物理端口</b> ，每个物理端口对应一条链路。在物理世界中，你可以把这想象成路由器有多条出线，每条出线都连接到另一个路由器。路由器不会在转发表中记录相邻路由器，而是记录数据包应该通过哪条出线发送。<b>它反映了路由器实际上并不关心相邻路由器的身份。路由器唯一需要做的决定就是将数据包沿着其中一条线路发送出去，而不管这条线路连接的是哪个路由器</b></p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20251130180604.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20251130180604.png" alt="20251130180604" class="pic-middle"></a></p><h3 id="h3-6">路由与转发</h3><p>既然我们已经介绍了路由表的概念，我们就需要区分创建转发表的过程和使用转发表的过程。</p><p><b>路由(Routing)</b>是指路由器之间相互通信，以确定如何填充其转发表的过程，它是<b>创建转发表</b>的过程。</p><p><b>转发(Forwarding)</b>是指接收到数据包后，在表中查找其合适的下一跳，并将数据包发送到合适的邻居的过程，它是<b>使用转发表</b>的过程。</p><p>转发与路由并不相同。转发数据包时，路由器使用现有的转发表，而无需了解该表是如何生成的。它是一个本地过程。路由器转发数据包时，无需了解完整的网络拓扑结构。路由器也不关心数据包转发到下一跳后的去向。路由器只需要知道到达的数据包以及自身的转发表。</p><p>相比之下，路由是一个全局过程。为了填充转发表，我们需要了解一些关于网络全局拓扑结构的信息。</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20251130180015.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20251130180015.png" alt="20251130180015" class="pic-big"></a></p><h2 id="h2-7">路由算法</h2><p>到目前为止，我们将路由问题定义为：当路由器收到一个数据包时，路由器如何知道将数据包转发到哪里，才能最终到达目的地？</p><p>我们需要通过算法找到一组<b>路由状态</b>，路由状态可以理解为每个路由器用来转发其接收到的数据包的一组规则。我们希望找到一组有效的路由状态，考虑全局路由状态，它由所有路由器中的所有转发表的集合组成</p><blockquote style="border-left-color: #0969da; background-color: #e8f3ff;"><div style="color: #0969da;"><img class="icon-note" loading="lazy" src="../../../img/note.svg" alt="[!NOTE]"> NOTE </div><p> 仅仅查看局部路由状态（例如单个路由器的转发表）无法判断路由状态是否有效，因为它可能是错误的</p></blockquote><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20251202162925.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20251202162925.png" alt="20251202162925" class="pic-big"></a></p><p>然而找到这样一组有效的规则本质上是图计算中生成树相关的过程，例如下图A不符合，我们希望生成树中所有边都联通；下图B不符合，因为不希望数据包陷入环路</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20251202163414.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20251202163414.png" alt="20251202163414" class="pic-big"></a></p><p>然而找到这样一组路由状态还远远不够，目前仅能确保路由中不存在环路和死路。如果我们希望找到一组最佳的路由状态，即希望找到<b>能够使数据包沿成本最低的路径到达目的地的路由</b>的<b>最小成本路由</b>。</p><p>最小成本路由的计算相当复杂，因为链路实际上具有不同的成本。这些成本可能取决于链路建设成本、传播延迟、链路物理距离、可靠性、带宽等因素。假设有一条 400 Gbps 的链路，传播延迟为 20 毫秒；还有一条 10 Gbps 的链路，传播延迟为 5 毫秒，哪条链路的成本更低？这取决于我们优化的目标是带宽、传播延迟、两者兼顾，还是其他完全不同的目标</p><p>本文<b>我们暂时将成本量化为一个数字</b>，且我们假设成本是对称的。即从 A 到 B 的成本与从 B 到 A 的成本相同。</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20251202164132.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20251202164132.png" alt="20251202164132" class="pic-big"></a></p><p>路由算法分为三种，下面我们将分别介绍它们</p><ul><li>距离矢量路由</li></ul><ul><li>链路状态路由</li></ul><ul><li>路径矢量路由</li></ul><h3 id="h3-8">距离矢量协议</h3><p>距离矢量协议在互联网和 ARPANET（互联网的前身）上有着悠久的历史。典型的距离矢量协议是路由信息协议（<b>RIP</b>）</p><h3 id="h3-9">链路状态协议</h3><h2 id="h2-10">参考</h2><ul><li><a href="https://textbook.cs168.io/routing/" target="_blank">cs168 textbook</a></li></ul></div>
    <div id="dir-tree-placeholder"></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/dir_tree_toggle.js"></script><script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../net/ip","../../net/udp","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/clipboard.svg","../../../img/clipboard-check.svg");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script>
            <script src="https://giscus.app/client.js" data-repo="luzhixing12345/klinux" 
            data-repo-id="R_kgDOJIKiEw" data-category="Q&A" data-category-id="DIC_kwDOJIKiE84CgFwK" data-mapping="pathname" data-strict="0"
            data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom"
            data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async>
            </script>
            <script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>
<script>
    const ws = new WebSocket("ws://127.0.0.1:8765");
    ws.onmessage = (event) => {
        if (event.data === "reload") location.reload();
    };
</script>

</html>