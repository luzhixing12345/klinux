<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/c.css /><link rel='stylesheet' href=../../../css/diff.css /><link rel='stylesheet' href=../../../css/json.css /><link rel='stylesheet' href=../../../css/makefile.css /><link rel='stylesheet' href=../../../css/shell.css /><link rel='stylesheet' href=../../../css/txt.css /><link rel='stylesheet' href=../../../css/x86asm.css /><link rel='stylesheet' href=../../../css/yaml.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/klinux.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">poll</a><ul><li><a href="#h2-1">阻塞式I/O模型</a></li></ul><ul><li><a href="#h2-2">非阻塞式I/O模型</a></li></ul><ul><li><a href="#h2-3">IO复用模型</a><ul><li><a href="#h3-4">select</a></li></ul><ul><li><a href="#h3-5">poll</a></li></ul><ul><li><a href="#h3-6">epoll</a></li></ul></li></ul><ul><li><a href="#h2-7">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">poll</h1><p>在linux系统中,实际上所有的I/O设备都被抽象为了文件这个概念,一切皆文件,磁盘、网络数据、终端,甚至进程间通信工具管道pipe等都被当做文件对待.</p><p>在 Unix 和类 Unix 操作系统中,文件描述符(File descriptor,FD)是用于访问文件或者其他 I/O 资源的抽象句柄,例如:管道或者网络套接字.而不同的 I/O 模型会使用不同的方式操作文件描述符.</p><h2 id="h2-1">阻塞式I/O模型</h2><p>阻塞 I/O 是最常见的 I/O 模型,在默认情况下,当我们通过 read 或者 write 等系统调用读写文件或者网络时,应用程序会被阻塞. 进程/线程在从调用 recvfrom 开始到它返回的整段时间内是被阻塞的, 此时<b>进程阻塞挂起不消耗CPU资源</b>. 当 recvfrom成功返回后,应用进程/线程开始处理数据报.</p><p>如下图所示,当我们执行 read 系统调用时,应用程序会从用户态陷入内核态,内核会检查文件描述符是否可读;当文件描述符中存在数据时,操作系统内核会将准备好的数据拷贝给应用程序并交回控制权.</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240807120852.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240807120852.png" alt="20240807120852"></a></p><p>操作系统中多数的 I/O 操作都是如上所示的阻塞请求,一旦执行 I/O 操作,应用程序会陷入阻塞等待 I/O 操作的结束. 但是显然这种阻塞 IO 的方式只适用并发量小的网络应用开发,不适用并发量大的应用,因为<b>一个请求IO会阻塞进程</b>, 每个请求都分配一个处理进程(线程)去响应显然不合理</p><h2 id="h2-2">非阻塞式I/O模型</h2><p>当进程把一个文件描述符设置成非阻塞时,执行 read 和 write 等 I/O 操作会立刻返回.在 C 语言中,我们可以使用如下的方式将 fd 设置成非阻塞的</p><pre class="language-c"><code><span class="Token Keyword BaseType TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">flags</span><span class="Token Identifier DirectDeclaractor SPACE"> </span><span class="Token InitDeclarator ASSIGN">=</span><span class="Token InitDeclarator SPACE"> </span><span class="Token Identifier PrimaryExpression FunctionCall ID">fcntl</span><span class="Token PostfixExpression UnaryExpression BraceDepth-0 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">fd</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">F_GETFL</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">0</span><span class="Token PostfixExpression UnaryExpression BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Identifier PrimaryExpression FunctionCall ID">fcntl</span><span class="Token PostfixExpression UnaryExpression BraceDepth-0 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">fd</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">F_SETFL</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">flags</span><span class="Token Identifier PrimaryExpression SPACE"> </span><span class="Token BinaryOp ConditionalExpression PIPE">|</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">O_NONBLOCK</span><span class="Token PostfixExpression UnaryExpression BraceDepth-0 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span></code></pre><p>在上述代码中,最关键的就是系统调用 fcntl 和参数 <code>O_NONBLOCK</code>, fcntl 为我们提供了操作文件描述符的能力,我们可以通过它修改文件描述符的特性.当我们将文件描述符修改成非阻塞后,读写文件会经历以下流程:</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240807121230.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240807121230.png" alt="20240807121230"></a></p><p>当进程发起IO系统调用后,如果内核缓冲区没有数据,需要到IO设备中读取,进程返回 <code>EAGAIN</code> 错误而不会被阻塞;进程发起IO系统调用后,如果内核缓冲区有数据,内核才会把数据返回进程</p><p>应用程序会不断轮询调用 read 直到它的返回值大于 0,这时应用程序就可以对读取操作系统缓冲区中的数据并进行操作.</p><pre class="language-c"><code><span class="Token Keyword IterationStatement WHILE">while</span><span class="Token Keyword IterationStatement SPACE"> </span><span class="Token IterationStatement BraceDepth-0 LPAREN">(</span><span class="Token Constant PrimaryExpression NUMBER">1</span><span class="Token IterationStatement BraceDepth-0 RPAREN">)</span><span class="Token IterationStatement SPACE"> </span><span class="Token CompoundStatement IterationStatement BraceDepth-0 LCURLY_BRACE">{</span><span class="Token CompoundStatement IterationStatement LF">
</span><span class="Token CompoundStatement IterationStatement SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">ret</span><span class="Token Identifier DirectDeclaractor SPACE"> </span><span class="Token InitDeclarator ASSIGN">=</span><span class="Token InitDeclarator SPACE"> </span><span class="Token Identifier PrimaryExpression FunctionCall ID">read</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration SPACE">    </span><span class="Token Keyword SelectionStatement IF">if</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token SelectionStatement BraceDepth-1 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">ret</span><span class="Token Identifier PrimaryExpression SPACE"> </span><span class="Token BinaryOp ConditionalExpression NE">!=</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">EAGAIN</span><span class="Token SelectionStatement BraceDepth-1 RPAREN">)</span><span class="Token SelectionStatement SPACE"> </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 LCURLY_BRACE">{</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">        </span><span class="Token CompoundStatement SelectionStatement COMMENT">// do something</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">    </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 RCURLY_BRACE">}</span><span class="Token CompoundStatement SelectionStatement SPACE"> </span><span class="Token Keyword SelectionStatement ELSE">else</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 LCURLY_BRACE">{</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">        </span><span class="Token CompoundStatement SelectionStatement COMMENT">// do something else</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">    </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 RCURLY_BRACE">}</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement IterationStatement BraceDepth-0 RCURLY_BRACE">}</span></code></pre><p>但是很明显, 虽然进程使用非阻塞的 I/O 操作时,可以在等待过程中执行其他任务,提高 CPU 的利用率. 但是不断地轮询操作会消耗CPU的资源, 每次由 read 系统调用陷入内核态也会产生性能开销</p><h2 id="h2-3">IO复用模型</h2><p>大多数文件系统的默认IO操作都是缓存IO.在Linux的缓存IO机制中,操作系统会将IO的数据缓存在文件系统的页缓存(page cache).也就是说,数据会<b>先被拷贝到操作系统内核的缓冲区</b>中,然后才会从操作系统<b>内核的缓存区拷贝到应用程序的地址空间</b>中.这种做法的缺点就是,需要在应用程序地址空间和内核进行多次拷贝,这些拷贝动作所带来的CPU以及内存开销是非常大的.</p><p>至于为什么不能直接让磁盘控制器把数据送到应用程序的地址空间中呢?最简单的一个原因就是应用程序不能直接操作底层硬件.</p><p>总的来说,IO分两阶段:</p><ul><li>数据准备阶段, 此时从磁盘/网卡等外设将数据拷贝到内核空间</li></ul><ul><li>内核空间复制回用户进程缓冲区阶段</li></ul><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240807124300.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240807124300.png" alt="20240807124300"></a></p><p>目前支持I/O多路复用的系统调用有 <code>select,pselect,poll,epoll</code>.与多进程和多线程技术相比,I/O多路复用技术的最大优势是系统开销小,<b>系统不必创建进程/线程</b>,也不必维护这些进程/线程,从而大大减小了系统的开销.</p><p>I/O多路复用就是通过一种机制.「多路」: 指的是多个socket网络连接;「复用」: 指的是复用一个线程、使用<b>一个线程来检查多个文件描述符(Socket)的就绪状态</b></p><p>多路复用主要有三种技术:select,poll,epoll. epoll是最新的, 也是目前最好的多路复用技术;</p><p>select,poll,epoll本质上都是同步I/O,因为他们都需要在读写事件就绪后自己负责进行读写,也就是说这个读写过程是阻塞的,而异步I/O则无需自己负责进行读写,异步I/O的实现会负责把数据从内核拷贝到用户空间</p><h3 id="h3-4">select</h3><p>select 使用三个集合来表示希望监控的文件描述符:</p><ul><li><b>读集合</b> (<code>readfds</code>): 监控哪些文件描述符可以进行读取操作.</li></ul><ul><li><b>写集合</b> (<code>writefds</code>): 监控哪些文件描述符可以进行写入操作.</li></ul><ul><li><b>异常集合</b> (<code>exceptfds</code>): 监控哪些文件描述符有异常条件.</li></ul><pre class="language-c"><code><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType INT">int</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName ID">select</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">nfds</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword Typedefine TypeSpecifier TYPEDEF_ID">fd_set</span><span class="Token Keyword Typedefine TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor ID">readfds</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword Typedefine TypeSpecifier TYPEDEF_ID">fd_set</span><span class="Token Keyword Typedefine TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor ID">writefds</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword Typedefine TypeSpecifier TYPEDEF_ID">fd_set</span><span class="Token Keyword Typedefine TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor ID">exceptfds</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">timeval</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor ID">timeout</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span></code></pre><ul><li><code>nfds</code>: 最大文件描述符的值加一(即所有监控文件描述符的最大值 + 1).</li></ul><ul><li><code>readfds</code>: 监控读取的文件描述符集合.</li></ul><ul><li><code>writefds</code>: 监控写入的文件描述符集合.</li></ul><ul><li><code>exceptfds</code>: 监控异常条件的文件描述符集合.</li></ul><ul><li><code>timeout</code>: 等待的最大时间,单位是秒和微秒.如果 <code>timeout</code> 为 <code>NULL</code>,<code>select</code> 将无限期等待,直到至少有一个文件描述符准备好.</li></ul><p><code>select</code> 返回准备好的文件描述符的数量,或者在发生错误时返回 -1. 可以通过检查 <code>readfds</code>、<code>writefds</code> 和 <code>exceptfds</code> 来确定哪些文件描述符就绪.</p><p>其基本原理如下图所示</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/dddf.gif"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/dddf.gif" alt="dddf"></a></p><p>select 主要有如下三个问题</p><ol start="1"><li>每次调用select,都需要把被监控的fds集合从用户态空间拷贝到内核态空间,高并发场景下这样的拷贝会使得消耗的资源是很大的</li></ol><ol start="2"><li>能监听端口的数量有限,单个进程所能打开的最大连接数由 <code>FD_SETSIZE</code> 宏定义, 默认为 1024(通过 ulilmit -n 查看), 最大数量可以查看 <code>/proc/sys/fs/file-max</code>, 该数值可以调整<pre class="language-shell"><code><span class="Token VARIANT">$</span><span class="Token SPACE"> </span><span class="Token Program ID">ulimit</span><span class="Token SPACE"> </span><span class="Token OPTION">-n</span><span class="Token LF">
</span><span class="Token NUMBER">1024</span><span class="Token LF">
</span><span class="Token VARIANT">$</span><span class="Token SPACE"> </span><span class="Token Program ID">cat</span><span class="Token SPACE"> </span><span class="Token PATH">/proc/sys/fs/file-max</span><span class="Token LF">
</span><span class="Token NUMBER">1609892</span></code></pre><blockquote><p>这个数量来说除了超大型项目基本够用, 但是效率会很低</p></blockquote></li></ol><ol start="3"><li>被监控的fds集合中,<b>只要有一个有数据可读,整个socket集合就会被遍历一次</b>, 调用sk的poll函数收集可读事<p>我们不知道事件来的时候,有多少个被监控的socket有数据可读了,于是,只能挨个遍历每个socket来收集可读事件了</p></li></ol><p>其中针对select遗留的三个问题中, 问题 2 是fd限制问题,问题 1 和 3 则是性能问题</p><p>select 的文件描述符集合大小受到 <code>FD_SETSIZE</code> 的限制,通常在大多数系统上这个值默认是 1024.这意味着,如果你需要监控超过 1024 个文件描述符,select 将无法满足需求.</p><pre class="language-c"><code><span class="Token HASH">#</span><span class="Token Keyword Preprocess ControlLine DEFINE">define</span><span class="Token Keyword Preprocess ControlLine SPACE"> </span><span class="Token Identifier MacroDefine ControlLine MacroDefine ID">FD_SETSIZE</span><span class="Token PPtoken SPACE"> </span><span class="Token PPtoken NUMBER">1024</span></code></pre><p>需要在编译时定义一个更大的 FD_SETSIZE 来增加这个限制,但这需要重新编译应用程序,并且不能动态调整</p><h3 id="h3-5">poll</h3><p><code>poll</code> 是一种 I/O 多路复用机制,类似于 <code>select</code>,但更适合处理大量文件描述符.在 Linux 系统中,<code>poll</code> 使用一个 <code>pollfd</code> 结构数组来监控多个文件描述符的状态.</p><p><code>pollfd</code> 结构包含三个成员:</p><pre class="language-c"><code><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">pollfd</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Structure BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Structure LF">
</span><span class="Token Structure SPACE">   </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE">   </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">fd</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration SPACE">         </span><span class="Token StructDeclaration COMMENT">/* file descriptor */</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">   </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SHORT">short</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">events</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration SPACE">     </span><span class="Token StructDeclaration COMMENT">/* requested events */</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">   </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SHORT">short</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">revents</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration SPACE">    </span><span class="Token StructDeclaration COMMENT">/* returned events */</span><span class="Token StructDeclaration LF">
</span><span class="Token Structure BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Declaration SEMI">;</span></code></pre><ul><li><code>fd</code>: 需要监控的文件描述符.</li></ul><ul><li><code>events</code>: 监控的事件类型.</li></ul><ul><li><code>revents</code>: 实际发生的事件类型.</li></ul><pre class="language-c"><code><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType INT">int</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName ID">poll</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">pollfd</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor ID">fds</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword Typedefine TypeSpecifier TYPEDEF_ID">nfds_t</span><span class="Token Keyword Typedefine TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">nfds</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">timeout</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span></code></pre><ul><li><code>fds</code>: 指向 <code>pollfd</code> 结构数组的指针.</li></ul><ul><li><code>nfds</code>: 数组中的文件描述符数量.</li></ul><ul><li><code>timeout</code>: 超时时间,单位是毫秒.负值表示无限期等待,0 表示立即返回.</li></ul><p><code>poll</code> 返回准备好的文件描述符的数量,或者在发生错误时返回 -1. 可以通过检查 <code>revents</code> 字段来确定哪些文件描述符就绪以及发生了哪些事件. 例如我们可以写一个简单的例子来监听来自 TCP socket 和 STDIN 两个 fd 的输入情况</p><blockquote><p>示例代码见 libc 仓库的 <a href="https://github.com/luzhixing12345/libc/blob/main/examples/socket/poll.c" target="_blank">poll.c</a> <a href="https://github.com/luzhixing12345/libc/blob/main/examples/socket/client.c" target="_blank">client.c</a></p></blockquote><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/wmklerjkl.gif"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/wmklerjkl.gif" alt="wmklerjkl"></a></p><h3 id="h3-6">epoll</h3><p><code>epoll</code> 的设计目的是解决 <code>select</code> 和 <code>poll</code> 在大规模文件描述符管理中的性能瓶颈.其核心思想是将事件与文件描述符关联,并在内核中维护一个事件表,当文件描述符的状态发生变化时,通过事件通知机制告知用户态进程.</p><p><code>epoll</code> 的关键特性包括:</p><ol start="1"><li><b>事件驱动</b>: <code>epoll</code> 使用事件通知机制,当文件描述符的状态发生变化时,内核会将其标记为就绪.</li></ol><ol start="2"><li><b>边缘触发和水平触发</b>: <code>epoll</code> 支持两种触发模式,边缘触发(Edge Triggered, ET)和水平触发(Level Triggered, LT).</li></ol><ol start="3"><li><b>高效的事件管理</b>: 内核仅在文件描述符状态变化时通知用户态,因此在处理大量文件描述符时性能优越.</li></ol><p><code>epoll</code> 的主要 API 包括以下几个函数:</p><ol start="1"><li><code>epoll_create1</code>:<pre class="language-c"><code><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType INT">int</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName ID">epoll_create1</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">flags</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span></code></pre><p>创建一个 <code>epoll</code> 实例,返回一个 <code>epoll</code> 文件描述符.<code>flags</code> 可以是 <code>EPOLL_CLOEXEC</code>,表示在执行 <code>exec</code> 时关闭文件描述符.</p></li></ol><ol start="2"><li><code>epoll_ctl</code>:<pre class="language-c"><code><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType INT">int</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName ID">epoll_ctl</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">epfd</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">op</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">fd</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">epoll_event</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor ID">event</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span></code></pre><p>控制 <code>epoll</code> 实例上的文件描述符监控.参数解释:</p><ul><li><code>epfd</code>: 由 <code>epoll_create1</code> 返回的 <code>epoll</code> 文件描述符.</li></ul><ul><li><code>op</code>: 操作类型,可以是 <code>EPOLL_CTL_ADD</code>(添加)、<code>EPOLL_CTL_MOD</code>(修改)或 <code>EPOLL_CTL_DEL</code>(删除).</li></ul><ul><li><code>fd</code>: 需要操作的文件描述符.</li></ul><ul><li><code>event</code>: 指向 <code>epoll_event</code> 结构体的指针,用于描述需要监控的事件.</li></ul></li></ol><ol start="3"><li><code>epoll_wait</code>:<pre class="language-c"><code><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType INT">int</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName ID">epoll_wait</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">epfd</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">epoll_event</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor ID">events</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">maxevents</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">timeout</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span></code></pre><p>等待事件发生.参数解释:</p><ul><li><code>epfd</code>: 由 <code>epoll_create1</code> 返回的 <code>epoll</code> 文件描述符.</li></ul><ul><li><code>events</code>: 用于返回就绪事件的数组.</li></ul><ul><li><code>maxevents</code>: <code>events</code> 数组的大小.</li></ul><ul><li><code>timeout</code>: 等待的超时时间(毫秒),-1 表示无限期等待.</li></ul></li></ol><p>示例代码见 <a href="https://github.com/luzhixing12345/libc/blob/main/examples/socket/epoll.c" target="_blank">epoll.c</a></p><p>主要步骤包括</p><ol start="4"><li><b>创建监听套接字</b>: 创建一个 TCP 套接字并绑定到指定端口.</li></ol><ol start="5"><li><b>创建 <code>epoll</code> 实例</b>: 使用 <code>epoll_create1</code> 创建一个 <code>epoll</code> 实例.</li></ol><ol start="6"><li><b>添加文件描述符到 <code>epoll</code> 实例</b>: 使用 <code>epoll_ctl</code> 将监听套接字和标准输入添加到 <code>epoll</code> 实例中.</li></ol><ol start="7"><li><b>等待和处理事件</b>: 使用 <code>epoll_wait</code> 等待事件发生,并根据不同的文件描述符和事件类型进行处理.</li></ol><h2 id="h2-7">参考</h2><ul><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/" target="_blank">网络轮询器</a></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/367591714" target="_blank">IO多路复用_深入浅出理解select、poll、epoll的实现</a></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../快速开始/编译内核" >快速开始</a><ul><li><a href="../../快速开始/编译内核" >编译内核</a></li></ul><ul><li><a href="../../快速开始/调试内核" >调试内核</a></li></ul><ul><li><a href="../../快速开始/开发环境搭建" >开发环境搭建</a></li></ul><ul><li><a href="../../快速开始/制作linux发行版" >制作linux发行版</a></li></ul><ul><li><a href="../../快速开始/邮件订阅" >邮件订阅</a></li></ul><ul><li><a href="../../快速开始/git" >git</a></li></ul></li></ul><ul><li><a href="../../mm/物理内存探测" >mm</a><ul><li><a href="../../mm/物理内存探测" >物理内存探测</a></li></ul><ul><li><a href="../../mm/虚拟地址转换" >虚拟地址转换</a></li></ul><ul><li><a href="../../mm/进程内存布局" >进程内存布局</a></li></ul><ul><li><a href="../../mm/页表" >页表</a></li></ul><ul><li><a href="../../mm/numa" >numa</a></li></ul><ul><li><a href="../../mm/vma" >vma</a></li></ul><ul><li><a href="../../mm/zone" >zone</a></li></ul><ul><li><a href="../../mm/buddy" >buddy</a></li></ul><ul><li><a href="../../mm/slab" >slab</a></li></ul><ul><li><a href="../../mm/compaction" >compaction</a></li></ul><ul><li><a href="../../mm/tier-mm" >tier-mm</a></li></ul><ul><li><a href="../../mm/migration" >migration</a></li></ul><ul><li><a href="../../mm/mm_struct" >mm_struct</a></li></ul><ul><li><a href="../../mm/mmio" >mmio</a></li></ul><ul><li><a href="../../mm/LRU" >LRU</a></li></ul><ul><li><a href="../../mm/MGLRU" >MGLRU</a></li></ul></li></ul><ul><li><a href="../../runtime/ELF文件格式" >runtime</a><ul><li><a href="../../runtime/ELF文件格式" >ELF文件格式</a></li></ul><ul><li><a href="../../runtime/符号表" >符号表</a></li></ul><ul><li><a href="../../runtime/静态链接" >静态链接</a></li></ul><ul><li><a href="../../runtime/装载" >装载</a></li></ul><ul><li><a href="../../runtime/动态链接" >动态链接</a></li></ul><ul><li><a href="../../runtime/库与运行库" >库与运行库</a></li></ul><ul><li><a href="../../runtime/execve" >execve</a></li></ul><ul><li><a href="../../runtime/vsdo" >vsdo</a></li></ul></li></ul><ul><li><a href="../../kernel/init" >kernel</a><ul><li><a href="../../kernel/init" >init</a></li></ul><ul><li><a href="../../kernel/atomic" >atomic</a></li></ul><ul><li><a href="../../kernel/rcu" >rcu</a></li></ul><ul><li><a href="../../kernel/workqueue" >workqueue</a></li></ul><ul><li><a href="../../kernel/lock" >lock</a></li></ul><ul><li><a href="../../kernel/syscall" >syscall</a></li></ul><ul><li><a href="../../kernel/poll" >poll</a></li></ul></li></ul><ul><li><a href="../../arch/cpu" >arch</a><ul><li><a href="../../arch/cpu" >cpu</a></li></ul><ul><li><a href="../../arch/cache" >cache</a></li></ul><ul><li><a href="../../arch/multicore" >multicore</a></li></ul><ul><li><a href="../../arch/cache-coherence" >cache-coherence</a></li></ul><ul><li><a href="../../arch/memory-coherence" >memory-coherence</a></li></ul><ul><li><a href="../../arch/io" >io</a></li></ul><ul><li><a href="../../arch/bus" >bus</a></li></ul><ul><li><a href="../../arch/interrupt" >interrupt</a></li></ul></li></ul><ul><li><a href="../../proc/schedule" >proc</a><ul><li><a href="../../proc/schedule" >schedule</a></li></ul><ul><li><a href="../../proc/nice" >nice</a></li></ul><ul><li><a href="../../proc/manage" >manage</a></li></ul><ul><li><a href="../../proc/signal" >signal</a></li></ul><ul><li><a href="../../proc/cgroup" >cgroup</a></li></ul><ul><li><a href="../../proc/task_struct" >task_struct</a></li></ul><ul><li><a href="../../proc/rb-tree" >rb-tree</a></li></ul></li></ul><ul><li><a href="../../net/net-arch" >net</a><ul><li><a href="../../net/net-arch" >net-arch</a></li></ul><ul><li><a href="../../net/ip" >ip</a></li></ul><ul><li><a href="../../net/route" >route</a></li></ul><ul><li><a href="../../net/udp" >udp</a></li></ul><ul><li><a href="../../net/tcp" >tcp</a></li></ul><ul><li><a href="../../net/tools" >tools</a></li></ul></li></ul><ul><li><a href="../../fs/storage" >fs</a><ul><li><a href="../../fs/storage" >storage</a></li></ul><ul><li><a href="../../fs/filesystem" >filesystem</a></li></ul><ul><li><a href="../../fs/fd" >fd</a></li></ul><ul><li><a href="../../fs/inode" >inode</a></li></ul><ul><li><a href="../../fs/directory" >directory</a></li></ul><ul><li><a href="../../fs/disk-layout" >disk-layout</a></li></ul><ul><li><a href="../../fs/mount" >mount</a></li></ul><ul><li><a href="../../fs/vfs" >vfs</a></li></ul><ul><li><a href="../../fs/ext4" >ext4</a></li></ul><ul><li><a href="../../fs/fuse" >fuse</a></li></ul><ul><li><a href="../../fs/distribute-fs" >distribute-fs</a></li></ul></li></ul><ul><li><a href="../../device/disk" >device</a><ul><li><a href="../../device/disk" >disk</a></li></ul><ul><li><a href="../../device/ssd" >ssd</a></li></ul><ul><li><a href="../../device/driver" >driver</a></li></ul><ul><li><a href="../../device/io_uring" >io_uring</a></li></ul><ul><li><a href="../../device/pcie" >pcie</a></li></ul></li></ul><ul><li><a href="../../others/safety" >others</a><ul><li><a href="../../others/safety" >safety</a></li></ul><ul><li><a href="../../others/Q&A" >Q&A</a></li></ul><ul><li><a href="../../others/kernel-code" >kernel-code</a></li></ul></li></ul><ul><li><a href="../../cve/dirtycow" >cve</a><ul><li><a href="../../cve/dirtycow" >dirtycow</a></li></ul><ul><li><a href="../../cve/dirtypipe" >dirtypipe</a></li></ul><ul><li><a href="../../cve/sudo" >sudo</a></li></ul><ul><li><a href="../../cve/meltdown" >meltdown</a></li></ul><ul><li><a href="../../cve/smashex" >smashex</a></li></ul></li></ul><ul><li><a href="../../perf/perf" >perf</a><ul><li><a href="../../perf/perf" >perf</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../kernel/syscall","../../arch/cpu","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script>
            <script src="https://giscus.app/client.js" data-repo="luzhixing12345/klinux" 
            data-repo-id="R_kgDOJIKiEw" data-category="Q&A" data-category-id="DIC_kwDOJIKiE84CgFwK" data-mapping="pathname" data-strict="0"
            data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom"
            data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async>
            </script>
            <script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>