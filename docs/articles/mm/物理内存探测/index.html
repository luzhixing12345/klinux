<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/c.css /><link rel='stylesheet' href=../../../css/diff.css /><link rel='stylesheet' href=../../../css/json.css /><link rel='stylesheet' href=../../../css/makefile.css /><link rel='stylesheet' href=../../../css/shell.css /><link rel='stylesheet' href=../../../css/txt.css /><link rel='stylesheet' href=../../../css/x86asm.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/klinux.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">物理布局探测</a><ul><li><a href="#h2-1">获取设备总内存</a></li></ul><ul><li><a href="#h2-2">memblock</a></li></ul><ul><li><a href="#h2-3">总结</a></li></ul><ul><li><a href="#h2-4">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">物理布局探测</h1><p>内存管理是 Linux 非常重要也非常复杂的一个环节, 本节我们从最基本的物理内存布局探测, 到 memblock NUMA slab 等复杂的内存管理方案做一些深入的分析</p><p>对于一个操作系统, 在启动之初有两个非常关键的问题</p><ul><li>操作系统怎样获取设备总内存大小?</li></ul><ul><li>设备的所有内存,操作系统都可以使用吗?</li></ul><h2 id="h2-1">获取设备总内存</h2><p><b>内存总大小等信息作为设备的关键信息,应该在硬件启动初期就由CPU获得并存储,操作系统只需要通过CPU的相关协定读取即可,这个协定就是BIOS中断</b></p><p>在x86芯片中,探测物理内存布局用的BIOS中断向量是0x15,<b>根据ax寄存器值的不同,有三种常见的方式:0xe820,0x801和0x88.</b></p><pre class="language-c"><code><span class="Token COMMENT">// arch/x86/boot/main.c</span><span class="Token LF">
</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType VOID">void</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName FunctionName ID">main</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token DirectDeclaractor Declarator SPACE"> </span><span class="Token CompoundStatement Function BraceDepth-0 LCURLY_BRACE">{</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function SPACE">    </span><span class="Token CompoundStatement Function COMMENT">// ...</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function SPACE">    </span><span class="Token CompoundStatement Function COMMENT">/* Detect memory layout */</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">detect_memory</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token ExpressionStatement COMMENT">// ...</span><span class="Token ExpressionStatement LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 RCURLY_BRACE">}</span></code></pre><p>detect_memory 中依次执行三个 BIOS 中断向 CPU 尝试获取物理内存布局, 这三个函数内部通过 <code>boot_params</code> 将内存的信息带出来</p><blockquote><p>boot_params 由 boot.h 引入, <code>extern struct boot_params boot_params</code></p><p>struct boot_params 定义很长, 位于 arch/x86/include/uapi/asm/bootparam.h</p></blockquote><pre class="language-c"><code><span class="Token COMMENT">// arch/x86/boot/memory.c</span><span class="Token LF">
</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType VOID">void</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName FunctionName ID">detect_memory</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier VOID">void</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token DirectDeclaractor Declarator SPACE"> </span><span class="Token CompoundStatement Function BraceDepth-0 LCURLY_BRACE">{</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">detect_memory_e820</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement SPACE"> </span><span class="Token ExpressionStatement COMMENT">/* 使用e820 BIOS中断获取物理内存布局 */</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">detect_memory_e801</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement SPACE"> </span><span class="Token ExpressionStatement COMMENT">/* 使用e801 BIOS中断获取物理内存布局 */</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">detect_memory_88</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement SPACE"> </span><span class="Token ExpressionStatement COMMENT">/* 使用88 BIOS中断获取物理内存布局 */</span><span class="Token ExpressionStatement LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 RCURLY_BRACE">}</span></code></pre><p>其中 e820 需要设置 AX 向量号为 <code>0xe820</code>,</p><pre class="language-c"><code><span class="Token COMMENT">// arch/x86/boot/memory.c</span><span class="Token LF">
</span><span class="Token HASH">#</span><span class="Token Keyword Preprocess ControlLine DEFINE">define</span><span class="Token Keyword Preprocess ControlLine SPACE"> </span><span class="Token Identifier MacroDefine ControlLine MacroDefine ID">SMAP</span><span class="Token PPtoken SPACE">    </span><span class="Token PPtoken NUMBER">0x534d4150</span><span class="Token PPtoken SPACE">  </span><span class="Token PPtoken COMMENT">/* ASCII &quot;SMAP&quot; */</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token COMMENT">// Input:</span><span class="Token LF">
</span><span class="Token COMMENT">// AX = E820h</span><span class="Token LF">
</span><span class="Token COMMENT">// EAX = 0000E820h</span><span class="Token LF">
</span><span class="Token COMMENT">// EDX = 534D4150h (&#x27;SMAP&#x27;)</span><span class="Token LF">
</span><span class="Token COMMENT">// EBX = continuation value or 00000000h to start at beginning of map</span><span class="Token LF">
</span><span class="Token COMMENT">// ECX = size of buffer for result, in bytes (should be &gt;= 20 bytes)</span><span class="Token LF">
</span><span class="Token COMMENT">// ES:DI -&gt; buffer for result (see #00581)</span><span class="Token LF">
</span><span class="Token COMMENT">// int 0x15</span><span class="Token LF">
</span><span class="Token Keyword StorageType FunctionReturnType STATIC">static</span><span class="Token Keyword StorageType FunctionReturnType SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType VOID">void</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName FunctionName ID">detect_memory_e820</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier VOID">void</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token DirectDeclaractor Declarator LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 LCURLY_BRACE">{</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">count</span><span class="Token Identifier DirectDeclaractor SPACE"> </span><span class="Token InitDeclarator ASSIGN">=</span><span class="Token InitDeclarator SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">0</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration SPACE">    </span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">biosregs</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">ireg</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">oreg</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration SPACE">    </span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">boot_e820_entry</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor ID">desc</span><span class="Token Identifier DirectDeclaractor SPACE"> </span><span class="Token InitDeclarator ASSIGN">=</span><span class="Token InitDeclarator SPACE"> </span><span class="Token Identifier PrimaryExpression ID">boot_params</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">e820_table</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration SPACE">    </span><span class="Token Keyword StorageType STATIC">static</span><span class="Token Keyword StorageType SPACE"> </span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">boot_e820_entry</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">buf</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration SPACE"> </span><span class="Token Declaration COMMENT">/* static so it is zeroed */</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Declaration SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">initregs</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ax</span><span class="Token Identifier SPACE">  </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">0xe820</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">cx</span><span class="Token Identifier SPACE">  </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Keyword UnaryExpression SIZEOF">sizeof</span><span class="Token UnaryExpression CastExpression BraceDepth-1 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">buf</span><span class="Token UnaryExpression CastExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">edx</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token MacroDefine Identifier MacroDefine PrimaryExpression ID">SMAP</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">di</span><span class="Token Identifier SPACE">  </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token CastExpression ConditionalExpression BraceDepth-1 LPAREN">(</span><span class="Token Keyword Typedefine TypeSpecifier TYPEDEF_ID">size_t</span><span class="Token CastExpression ConditionalExpression BraceDepth-1 RPAREN">)</span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">buf</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token ExpressionStatement COMMENT">/*
     * Note: at least one BIOS is known which assumes that the
     * buffer pointed to by one e820 call is the same one as
     * the previous call, and only changes modified fields.  Therefore,
     * we use a temporary buffer and copy the results entry by entry.
     *
     * This routine deliberately does not try to account for
     * ACPI 3+ extended attributes.  This is because there are
     * BIOSes in the field which report zero for the valid bit for
     * all ranges, and we don&#x27;t currently make any use of the
     * other attribute bits.  Revisit this if we see the extended
     * attribute bits deployed in a meaningful way in the future.
     */</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token ExpressionStatement COMMENT">// Ouput:</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token ExpressionStatement COMMENT">// CF clear if successful</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token ExpressionStatement COMMENT">// EAX = 534D4150h (&#x27;SMAP&#x27;)</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token ExpressionStatement COMMENT">// ES:DI buffer filled</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token ExpressionStatement COMMENT">// EBX = next offset from which to copy or 00000000h if all done</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token ExpressionStatement COMMENT">// ECX = actual length returned in bytes</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token ExpressionStatement COMMENT">// CF set on error</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token ExpressionStatement COMMENT">// AH = error code (86h) (see #00496 at INT 15/AH=80h)</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Keyword IterationStatement DO">do</span><span class="Token Keyword IterationStatement SPACE"> </span><span class="Token CompoundStatement IterationStatement BraceDepth-1 LCURLY_BRACE">{</span><span class="Token CompoundStatement IterationStatement LF">
</span><span class="Token CompoundStatement IterationStatement SPACE">        </span><span class="Token Identifier PrimaryExpression FunctionCall ID">intcall</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 LPAREN">(</span><span class="Token Constant PrimaryExpression NUMBER">0x15</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">        </span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ebx</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ebx</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement SPACE"> </span><span class="Token ExpressionStatement COMMENT">/* for next iteration... */</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">        </span><span class="Token ExpressionStatement COMMENT">/* BIOSes which terminate the chain with CF = 1 as opposed
           to %ebx = 0 don&#x27;t always report the SMAP signature on
           the final, failing, probe. */</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">        </span><span class="Token Keyword SelectionStatement IF">if</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token SelectionStatement BraceDepth-2 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">eflags</span><span class="Token Identifier SPACE"> </span><span class="Token BinaryOp ConditionalExpression AMPERSAND">&amp;</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">X86_EFLAGS_CF</span><span class="Token SelectionStatement BraceDepth-2 RPAREN">)</span><span class="Token SelectionStatement LF">
</span><span class="Token SelectionStatement SPACE">            </span><span class="Token Keyword JumpStatement BREAK">break</span><span class="Token JumpStatement SelectionStatement SEMI">;</span><span class="Token JumpStatement SelectionStatement LF">
</span><span class="Token JumpStatement SelectionStatement LF">
</span><span class="Token JumpStatement SelectionStatement SPACE">        </span><span class="Token JumpStatement SelectionStatement COMMENT">/* Some BIOSes stop returning SMAP in the middle of
           the search loop.  We don&#x27;t know exactly how the BIOS
           screwed up the map at that point, we might have a
           partial map, the full map, or complete garbage, so
           just return failure. */</span><span class="Token JumpStatement SelectionStatement LF">
</span><span class="Token JumpStatement SelectionStatement SPACE">        </span><span class="Token Keyword SelectionStatement IF">if</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token SelectionStatement BraceDepth-2 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">eax</span><span class="Token Identifier SPACE"> </span><span class="Token BinaryOp ConditionalExpression NE">!=</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token MacroDefine Identifier MacroDefine PrimaryExpression ID">SMAP</span><span class="Token SelectionStatement BraceDepth-2 RPAREN">)</span><span class="Token SelectionStatement SPACE"> </span><span class="Token CompoundStatement SelectionStatement BraceDepth-2 LCURLY_BRACE">{</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">            </span><span class="Token Identifier PrimaryExpression ID">count</span><span class="Token Identifier PrimaryExpression SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">0</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">            </span><span class="Token Keyword JumpStatement BREAK">break</span><span class="Token JumpStatement SEMI">;</span><span class="Token JumpStatement LF">
</span><span class="Token JumpStatement SPACE">        </span><span class="Token CompoundStatement SelectionStatement BraceDepth-2 RCURLY_BRACE">}</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">        </span><span class="Token UnaryOp UnaryExpression POINTER">*</span><span class="Token Identifier PrimaryExpression ID">desc</span><span class="Token PostfixExpression UnaryExpression INC">++</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">buf</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">        </span><span class="Token Identifier PrimaryExpression ID">count</span><span class="Token PostfixExpression UnaryExpression INC">++</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token CompoundStatement IterationStatement BraceDepth-1 RCURLY_BRACE">}</span><span class="Token CompoundStatement IterationStatement SPACE"> </span><span class="Token Keyword IterationStatement WHILE">while</span><span class="Token Keyword IterationStatement SPACE"> </span><span class="Token IterationStatement BraceDepth-1 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ebx</span><span class="Token Identifier SPACE"> </span><span class="Token BinaryOp ConditionalExpression AND">&amp;&amp;</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">count</span><span class="Token Identifier PrimaryExpression SPACE"> </span><span class="Token BinaryOp LT">&lt;</span><span class="Token BinaryOp SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">ARRAY_SIZE</span><span class="Token BraceDepth-2 LPAREN">(</span><span class="Token Identifier ID">boot_params</span><span class="Token PPtoken DOT">.</span><span class="Token Identifier ID">e820_table</span><span class="Token BraceDepth-2 RPAREN">)</span><span class="Token IterationStatement BraceDepth-1 RPAREN">)</span><span class="Token IterationStatement SEMI">;</span><span class="Token IterationStatement LF">
</span><span class="Token IterationStatement LF">
</span><span class="Token IterationStatement SPACE">    </span><span class="Token Identifier PrimaryExpression ID">boot_params</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">e820_entries</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">count</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 RCURLY_BRACE">}</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function LF">
</span><span class="Token Keyword StorageType FunctionReturnType STATIC">static</span><span class="Token Keyword StorageType FunctionReturnType SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType VOID">void</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName FunctionName ID">detect_memory_e801</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier VOID">void</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token DirectDeclaractor Declarator LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 LCURLY_BRACE">{</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function SPACE">    </span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">biosregs</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">ireg</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">oreg</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Declaration SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">initregs</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ax</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">0xe801</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">intcall</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token Constant PrimaryExpression NUMBER">0x15</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Keyword SelectionStatement IF">if</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token SelectionStatement BraceDepth-1 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">eflags</span><span class="Token Identifier SPACE"> </span><span class="Token BinaryOp ConditionalExpression AMPERSAND">&amp;</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token MacroDefine Identifier MacroDefine PrimaryExpression ID">X86_EFLAGS_CF</span><span class="Token SelectionStatement BraceDepth-1 RPAREN">)</span><span class="Token SelectionStatement LF">
</span><span class="Token SelectionStatement SPACE">        </span><span class="Token Keyword JumpStatement RETURN">return</span><span class="Token JumpStatement SelectionStatement SEMI">;</span><span class="Token JumpStatement SelectionStatement LF">
</span><span class="Token JumpStatement SelectionStatement LF">
</span><span class="Token JumpStatement SelectionStatement SPACE">    </span><span class="Token JumpStatement SelectionStatement COMMENT">/* Do we really need to do this? */</span><span class="Token JumpStatement SelectionStatement LF">
</span><span class="Token JumpStatement SelectionStatement SPACE">    </span><span class="Token Keyword SelectionStatement IF">if</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token SelectionStatement BraceDepth-1 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">cx</span><span class="Token Identifier SPACE"> </span><span class="Token BinaryOp ConditionalExpression OR">||</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">dx</span><span class="Token SelectionStatement BraceDepth-1 RPAREN">)</span><span class="Token SelectionStatement SPACE"> </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 LCURLY_BRACE">{</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">        </span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ax</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">cx</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">        </span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">bx</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">dx</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 RCURLY_BRACE">}</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">    </span><span class="Token Keyword SelectionStatement IF">if</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token SelectionStatement BraceDepth-1 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ax</span><span class="Token Identifier SPACE"> </span><span class="Token BinaryOp ConditionalExpression GT">&gt;</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">15</span><span class="Token BinaryOp MUL">*</span><span class="Token Constant PrimaryExpression NUMBER">1024</span><span class="Token SelectionStatement BraceDepth-1 RPAREN">)</span><span class="Token SelectionStatement SPACE"> </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 LCURLY_BRACE">{</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">        </span><span class="Token Keyword JumpStatement RETURN">return</span><span class="Token JumpStatement SEMI">;</span><span class="Token JumpStatement SPACE"> </span><span class="Token JumpStatement COMMENT">/* Bogus! */</span><span class="Token JumpStatement LF">
</span><span class="Token JumpStatement SPACE">    </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 RCURLY_BRACE">}</span><span class="Token CompoundStatement SelectionStatement SPACE"> </span><span class="Token Keyword SelectionStatement ELSE">else</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token Keyword SelectionStatement IF">if</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token SelectionStatement SelectionStatement BraceDepth-1 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ax</span><span class="Token Identifier SPACE"> </span><span class="Token BinaryOp ConditionalExpression EQ">==</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">15</span><span class="Token BinaryOp MUL">*</span><span class="Token Constant PrimaryExpression NUMBER">1024</span><span class="Token SelectionStatement SelectionStatement BraceDepth-1 RPAREN">)</span><span class="Token SelectionStatement SelectionStatement SPACE"> </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 LCURLY_BRACE">{</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">        </span><span class="Token Identifier PrimaryExpression ID">boot_params</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">alt_mem_k</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token PrimaryExpression PostfixExpression BraceDepth-2 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">bx</span><span class="Token Identifier SPACE"> </span><span class="Token BinaryOp ConditionalExpression SHL">&lt;&lt;</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">6</span><span class="Token PrimaryExpression PostfixExpression BraceDepth-2 RPAREN">)</span><span class="Token PrimaryExpression PostfixExpression SPACE"> </span><span class="Token BinaryOp ConditionalExpression PLUS">+</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ax</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 RCURLY_BRACE">}</span><span class="Token CompoundStatement SelectionStatement SPACE"> </span><span class="Token Keyword SelectionStatement ELSE">else</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 LCURLY_BRACE">{</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">        </span><span class="Token CompoundStatement SelectionStatement COMMENT">/*
         * This ignores memory above 16MB if we have a memory
         * hole there.  If someone actually finds a machine
         * with a memory hole at 16MB and no support for
         * 0E820h they should probably generate a fake e820
         * map.
         */</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">        </span><span class="Token Identifier PrimaryExpression ID">boot_params</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">alt_mem_k</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ax</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 RCURLY_BRACE">}</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 RCURLY_BRACE">}</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function LF">
</span><span class="Token Keyword StorageType FunctionReturnType STATIC">static</span><span class="Token Keyword StorageType FunctionReturnType SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType VOID">void</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName FunctionName ID">detect_memory_88</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier VOID">void</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token DirectDeclaractor Declarator LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 LCURLY_BRACE">{</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function SPACE">    </span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">biosregs</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">ireg</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">oreg</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Declaration SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">initregs</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ah</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">0x88</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">intcall</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token Constant PrimaryExpression NUMBER">0x15</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression ID">boot_params</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">screen_info</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ext_mem_k</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ax</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 RCURLY_BRACE">}</span></code></pre><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20230628161738.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230628161738.png" alt="20230628161738"></a></p><ul><li>操作系统怎样获取设备总内存大小?<p>答:通过BIOS 0x15中断,常见有E820,E801和E88子中断号.</p></li></ul><ul><li>设备的所有内存,操作系统都可以使用吗?<p>答:不是的,只有内存类型为usable的才能被操作系统所使用.</p></li></ul><h2 id="h2-2">memblock</h2><p>memblock 子系统主要用于引导过程中的物理内存管理,特别是在早期的启动阶段,当内核尚未完全初始化和建立内存管理器时.一旦内核初始化完成,memblock 子系统的功能通常会被更高级的内存管理机制所取代,如 buddy allocator(伙伴系统)或 slab allocator(SLAB 系统)</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20230628182631.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230628182631.png" alt="20230628182631"></a></p><p>memblock 的功能主要包括</p><ul><li>内存块的描述:memblock 维护了一个物理内存块的列表,每个内存块由起始地址和大小来描述.通过这些描述信息,内核可以了解系统中可用的物理内存块的位置和大小.</li></ul><ul><li>内存块的分配和释放:memblock 提供了函数来动态分配和释放物理内存块.内核可以使用这些函数来管理物理内存资源,例如在启动过程中分配页表,初始化内核堆栈等.</li></ul><ul><li>物理内存的管理:memblock 子系统还提供了一些函数来管理物理内存的属性和映射关系,例如设置内存块的属性(例如可读写,可执行等),查询内存块是否被保留等.</li></ul><pre class="language-c"><code><span class="Token COMMENT">/**
 * struct memblock - memblock allocator metadata
 * @bottom_up: is bottom up direction? 用于判断记录的内存是否从底部往顶部增长
 * @current_limit: physical address of the current allocation limit 当前内存管理器管理的物理地址上限
 * @memory: usable memory regions 操作系统可用内存,即E820探测物理布局时,flags为usable的内存区域
 * @reserved: reserved memory regions 在boot阶段保留的内存,包括E820探测物理布局时,flags为reserved的内存区域,boot阶段分配出去的内存区域
 */</span><span class="Token LF">
</span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">memblock</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Structure BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Structure LF">
</span><span class="Token Structure SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier BOOL">bool</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">bottom_up</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration SPACE">  </span><span class="Token StructDeclaration COMMENT">/* is bottom up direction? */</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">phys_addr_t</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">current_limit</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword StructureType Structure TypeSpecifier TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier TypeSpecifier ID">memblock_type</span><span class="Token Identifier Structure StructureClass TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">memory</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword StructureType Structure TypeSpecifier TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier TypeSpecifier ID">memblock_type</span><span class="Token Identifier Structure StructureClass TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">reserved</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token Structure BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Declaration SEMI">;</span></code></pre><pre class="language-c"><code><span class="Token COMMENT">/**
 * struct memblock_type - collection of memory regions of certain type
 * @cnt: number of regions 记录的内存区域(memblock_region)的数量
 * @max: size of the allocated array 最多能使用的内存区域数,当预留的内存区域不足时,管理器会扩展
 * @total_size: size of all regions 所有内存区域的内存之和
 * @regions: array of regions 内存区域数组,每一项代表usable或保留的内存区域
 * @name: the memory type symbolic name 内存管理器类型的名称,例如&quot;memory&quot;,&quot;reserved&quot;等
 */</span><span class="Token LF">
</span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">memblock_type</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Structure BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Structure LF">
</span><span class="Token Structure SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier UNSIGNED">unsigned</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier LONG">long</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">cnt</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier UNSIGNED">unsigned</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier LONG">long</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">max</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">phys_addr_t</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">total_size</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword StructureType Structure TypeSpecifier TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier TypeSpecifier ID">memblock_region</span><span class="Token Identifier Structure StructureClass TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">regions</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier CHAR">char</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">name</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token Structure BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Declaration SEMI">;</span></code></pre><pre class="language-c"><code><span class="Token COMMENT">/**
 * struct memblock_region - represents a memory region
 * @base: base address of the region 内存区域的起始地址,类型为u64或u32,表示64位/32位架构的支持最大地址长度
 * @size: size of the region 内存区域的大小
 * @flags: memory region attributes 内存区域的类型表示,有四种类型:MEMBLOCK_NONE(普通内存),MEMBLOCK_HOTPLUG(可热拔插内存),MEMBLOCK_MIRROR(镜像内存),MEMBLOCK_NOMAP(非内核直接映射内存),相同类型的相邻内存,条件合适时可以被合并
 * @nid: NUMA node id 暂时略去与NUMA相关的内容
 */</span><span class="Token LF">
</span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">memblock_region</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Structure BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Structure LF">
</span><span class="Token Structure SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">phys_addr_t</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">base</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">phys_addr_t</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">size</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword EnumSpecifier TypeSpecifier TypeSpecifier ENUM">enum</span><span class="Token Keyword EnumSpecifier TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier EnumSpecifier EnumID TypeSpecifier TypeSpecifier ID">memblock_flags</span><span class="Token Identifier EnumSpecifier EnumID TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">flags</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token HASH">#</span><span class="Token Keyword Preprocess IfGroup IFDEF">ifdef</span><span class="Token Keyword Preprocess IfGroup SPACE"> </span><span class="Token Identifier MacroDefine IfGroup MacroDefine ID">CONFIG_NUMA</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">nid</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token HASH">#</span><span class="Token Keyword Preprocess EndifLine ENDIF">endif</span><span class="Token LF">
</span><span class="Token Structure BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Declaration COMMENT">/**
 * enum memblock_flags - definition of memory region attributes
 * @MEMBLOCK_NONE: no special request
 * @MEMBLOCK_HOTPLUG: memory region indicated in the firmware-provided memory
 * map during early boot as hot(un)pluggable system RAM (e.g., memory range
 * that might get hotunplugged later). With &quot;movable_node&quot; set on the kernel
 * commandline, try keeping this memory region hotunpluggable. Does not apply
 * to memblocks added (&quot;hotplugged&quot;) after early boot.
 * @MEMBLOCK_MIRROR: mirrored region
 * @MEMBLOCK_NOMAP: don&#x27;t add to kernel direct mapping and treat as
 * reserved in the memory map; refer to memblock_mark_nomap() description
 * for further details
 * @MEMBLOCK_DRIVER_MANAGED: memory region that is always detected and added
 * via a driver, and never indicated in the firmware-provided memory map as
 * system RAM. This corresponds to IORESOURCE_SYSRAM_DRIVER_MANAGED in the
 * kernel resource tree.
 */</span><span class="Token Declaration LF">
</span><span class="Token Keyword EnumSpecifier TypeSpecifier ENUM">enum</span><span class="Token Keyword EnumSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier EnumID EnumSpecifier EnumID TypeSpecifier ID">memblock_flags</span><span class="Token Identifier EnumID EnumSpecifier EnumID TypeSpecifier SPACE"> </span><span class="Token EnumSpecifier BraceDepth-0 LCURLY_BRACE">{</span><span class="Token EnumSpecifier LF">
</span><span class="Token EnumSpecifier SPACE">    </span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier ID">MEMBLOCK_NONE</span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier SPACE">       </span><span class="Token Enumerator ASSIGN">=</span><span class="Token Enumerator SPACE"> </span><span class="Token Constant PrimaryExpression TypeSpecifier NUMBER">0x0</span><span class="Token EnumSpecifier COMMA">,</span><span class="Token EnumSpecifier SPACE">  </span><span class="Token EnumSpecifier COMMENT">/* No special request */</span><span class="Token EnumSpecifier LF">
</span><span class="Token EnumSpecifier SPACE">    </span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier ID">MEMBLOCK_HOTPLUG</span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier SPACE">    </span><span class="Token Enumerator ASSIGN">=</span><span class="Token Enumerator SPACE"> </span><span class="Token Constant PrimaryExpression TypeSpecifier NUMBER">0x1</span><span class="Token EnumSpecifier COMMA">,</span><span class="Token EnumSpecifier SPACE">  </span><span class="Token EnumSpecifier COMMENT">/* hotpluggable region */</span><span class="Token EnumSpecifier LF">
</span><span class="Token EnumSpecifier SPACE">    </span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier ID">MEMBLOCK_MIRROR</span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier SPACE">     </span><span class="Token Enumerator ASSIGN">=</span><span class="Token Enumerator SPACE"> </span><span class="Token Constant PrimaryExpression TypeSpecifier NUMBER">0x2</span><span class="Token EnumSpecifier COMMA">,</span><span class="Token EnumSpecifier SPACE">  </span><span class="Token EnumSpecifier COMMENT">/* mirrored region */</span><span class="Token EnumSpecifier LF">
</span><span class="Token EnumSpecifier SPACE">    </span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier ID">MEMBLOCK_NOMAP</span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier SPACE">      </span><span class="Token Enumerator ASSIGN">=</span><span class="Token Enumerator SPACE"> </span><span class="Token Constant PrimaryExpression TypeSpecifier NUMBER">0x4</span><span class="Token EnumSpecifier COMMA">,</span><span class="Token EnumSpecifier SPACE">  </span><span class="Token EnumSpecifier COMMENT">/* don&#x27;t add to kernel direct mapping */</span><span class="Token EnumSpecifier LF">
</span><span class="Token EnumSpecifier SPACE">    </span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier ID">MEMBLOCK_DRIVER_MANAGED</span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier SPACE"> </span><span class="Token Enumerator ASSIGN">=</span><span class="Token Enumerator SPACE"> </span><span class="Token Constant PrimaryExpression TypeSpecifier NUMBER">0x8</span><span class="Token EnumSpecifier COMMA">,</span><span class="Token EnumSpecifier SPACE">  </span><span class="Token EnumSpecifier COMMENT">/* always detected via a driver */</span><span class="Token EnumSpecifier LF">
</span><span class="Token EnumSpecifier BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Declaration SEMI">;</span></code></pre><h2 id="h2-3">总结</h2><p>操作系统通过BIOS 0x15中断,常见有E820、E801和E88子中断号获取设备总内存大小, 内存类型为usable的才能被操作系统所使用</p><p>memblock 子系统主要用于引导过程中的物理内存管理</p><h2 id="h2-4">参考</h2><ul><li><a href="https://www.zhihu.com/column/c_1444822980567805952" target="_blank">深入理解Linux内存管理 专栏</a></li></ul><ul><li><a href="https://www.zhihu.com/column/c_1543333099974721536" target="_blank">Linux内存管理 专栏</a></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../快速开始/编译内核" >快速开始</a><ul><li><a href="../../快速开始/编译内核" >编译内核</a></li></ul><ul><li><a href="../../快速开始/调试内核" >调试内核</a></li></ul><ul><li><a href="../../快速开始/开发环境搭建" >开发环境搭建</a></li></ul><ul><li><a href="../../快速开始/制作linux发行版" >制作linux发行版</a></li></ul><ul><li><a href="../../快速开始/邮件订阅" >邮件订阅</a></li></ul><ul><li><a href="../../快速开始/git" >git</a></li></ul></li></ul><ul><li><a href="../../mm/物理内存探测" >mm</a><ul><li><a href="../../mm/物理内存探测" >物理内存探测</a></li></ul><ul><li><a href="../../mm/虚拟地址转换" >虚拟地址转换</a></li></ul><ul><li><a href="../../mm/进程内存布局" >进程内存布局</a></li></ul><ul><li><a href="../../mm/页表" >页表</a></li></ul><ul><li><a href="../../mm/numa" >numa</a></li></ul><ul><li><a href="../../mm/vma" >vma</a></li></ul><ul><li><a href="../../mm/zone" >zone</a></li></ul><ul><li><a href="../../mm/buddy" >buddy</a></li></ul><ul><li><a href="../../mm/slab" >slab</a></li></ul><ul><li><a href="../../mm/compaction" >compaction</a></li></ul><ul><li><a href="../../mm/分层内存" >分层内存</a></li></ul><ul><li><a href="../../mm/migration" >migration</a></li></ul><ul><li><a href="../../mm/mm_struct" >mm_struct</a></li></ul><ul><li><a href="../../mm/mmio" >mmio</a></li></ul><ul><li><a href="../../mm/MGLRU" >MGLRU</a></li></ul></li></ul><ul><li><a href="../../runtime/ELF文件格式" >runtime</a><ul><li><a href="../../runtime/ELF文件格式" >ELF文件格式</a></li></ul><ul><li><a href="../../runtime/符号表" >符号表</a></li></ul><ul><li><a href="../../runtime/静态链接" >静态链接</a></li></ul><ul><li><a href="../../runtime/装载" >装载</a></li></ul><ul><li><a href="../../runtime/动态链接" >动态链接</a></li></ul><ul><li><a href="../../runtime/库与运行库" >库与运行库</a></li></ul><ul><li><a href="../../runtime/execve" >execve</a></li></ul><ul><li><a href="../../runtime/vsdo" >vsdo</a></li></ul></li></ul><ul><li><a href="../../kernel/init" >kernel</a><ul><li><a href="../../kernel/init" >init</a></li></ul><ul><li><a href="../../kernel/atomic" >atomic</a></li></ul><ul><li><a href="../../kernel/rcu" >rcu</a></li></ul><ul><li><a href="../../kernel/workqueue" >workqueue</a></li></ul><ul><li><a href="../../kernel/lock" >lock</a></li></ul><ul><li><a href="../../kernel/syscall" >syscall</a></li></ul><ul><li><a href="../../kernel/poll" >poll</a></li></ul></li></ul><ul><li><a href="../../arch/cpu" >arch</a><ul><li><a href="../../arch/cpu" >cpu</a></li></ul><ul><li><a href="../../arch/cache" >cache</a></li></ul><ul><li><a href="../../arch/multicore" >multicore</a></li></ul><ul><li><a href="../../arch/缓存一致性" >缓存一致性</a></li></ul><ul><li><a href="../../arch/内存一致性" >内存一致性</a></li></ul><ul><li><a href="../../arch/io" >io</a></li></ul><ul><li><a href="../../arch/bus" >bus</a></li></ul><ul><li><a href="../../arch/interrupt" >interrupt</a></li></ul></li></ul><ul><li><a href="../../proc/schedule" >proc</a><ul><li><a href="../../proc/schedule" >schedule</a></li></ul><ul><li><a href="../../proc/nice" >nice</a></li></ul><ul><li><a href="../../proc/manage" >manage</a></li></ul><ul><li><a href="../../proc/signal" >signal</a></li></ul><ul><li><a href="../../proc/cgroup" >cgroup</a></li></ul><ul><li><a href="../../proc/task_struct" >task_struct</a></li></ul><ul><li><a href="../../proc/rb-tree" >rb-tree</a></li></ul></li></ul><ul><li><a href="../../net/net-arch" >net</a><ul><li><a href="../../net/net-arch" >net-arch</a></li></ul><ul><li><a href="../../net/ip" >ip</a></li></ul><ul><li><a href="../../net/route" >route</a></li></ul><ul><li><a href="../../net/udp" >udp</a></li></ul><ul><li><a href="../../net/tcp" >tcp</a></li></ul><ul><li><a href="../../net/tools" >tools</a></li></ul></li></ul><ul><li><a href="../../fs/storage" >fs</a><ul><li><a href="../../fs/storage" >storage</a></li></ul><ul><li><a href="../../fs/filesystem" >filesystem</a></li></ul><ul><li><a href="../../fs/fd" >fd</a></li></ul><ul><li><a href="../../fs/inode" >inode</a></li></ul><ul><li><a href="../../fs/directory" >directory</a></li></ul><ul><li><a href="../../fs/disk-layout" >disk-layout</a></li></ul><ul><li><a href="../../fs/mount" >mount</a></li></ul><ul><li><a href="../../fs/vfs" >vfs</a></li></ul><ul><li><a href="../../fs/ext4" >ext4</a></li></ul><ul><li><a href="../../fs/fuse" >fuse</a></li></ul><ul><li><a href="../../fs/distribute-fs" >distribute-fs</a></li></ul></li></ul><ul><li><a href="../../device/disk" >device</a><ul><li><a href="../../device/disk" >disk</a></li></ul><ul><li><a href="../../device/ssd" >ssd</a></li></ul><ul><li><a href="../../device/driver" >driver</a></li></ul><ul><li><a href="../../device/io_uring" >io_uring</a></li></ul><ul><li><a href="../../device/pcie" >pcie</a></li></ul></li></ul><ul><li><a href="../../others/safety" >others</a><ul><li><a href="../../others/safety" >safety</a></li></ul><ul><li><a href="../../others/Q&A" >Q&A</a></li></ul></li></ul><ul><li><a href="../../cve/dirtycow" >cve</a><ul><li><a href="../../cve/dirtycow" >dirtycow</a></li></ul><ul><li><a href="../../cve/dirtypipe" >dirtypipe</a></li></ul><ul><li><a href="../../cve/sudo" >sudo</a></li></ul><ul><li><a href="../../cve/meltdown" >meltdown</a></li></ul><ul><li><a href="../../cve/smashex" >smashex</a></li></ul></li></ul><ul><li><a href="../../perf/perf" >perf</a><ul><li><a href="../../perf/perf" >perf</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../快速开始/git","../../mm/虚拟地址转换","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script>
            <script src="https://giscus.app/client.js" data-repo="luzhixing12345/klinux" 
            data-repo-id="R_kgDOJIKiEw" data-category="Q&A" data-category-id="DIC_kwDOJIKiE84CgFwK" data-mapping="pathname" data-strict="0"
            data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom"
            data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async>
            </script>
            <script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>