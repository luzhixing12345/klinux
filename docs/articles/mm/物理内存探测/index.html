<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/c.css /><link rel='stylesheet' href=../../../css/diff.css /><link rel='stylesheet' href=../../../css/json.css /><link rel='stylesheet' href=../../../css/makefile.css /><link rel='stylesheet' href=../../../css/shell.css /><link rel='stylesheet' href=../../../css/txt.css /><link rel='stylesheet' href=../../../css/x86asm.css /><link rel='stylesheet' href=../../../css/yaml.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/klinux.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">物理布局探测</a><ul><li><a href="#h2-1">获取设备总内存</a><ul><li><a href="#h3-2">E820</a></li></ul><ul><li><a href="#h3-3">E801</a></li></ul><ul><li><a href="#h3-4">88</a></li></ul></li></ul><ul><li><a href="#h2-5">探测结果</a></li></ul><ul><li><a href="#h2-6">memblock</a></li></ul><ul><li><a href="#h2-7">总结</a></li></ul><ul><li><a href="#h2-8">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">物理布局探测</h1><p>Linux 的内存管理是操作系统核心功能之一,负责高效、安全地分配和回收物理内存资源,同时为应用程序提供抽象的虚拟内存空间.其复杂性源于现代计算机系统的多样化需求、硬件架构的差异以及性能优化的权衡. 涵盖了诸如:</p><ol start="1"><li><b>虚拟内存与物理内存的映射</b><ul><li><b>虚拟内存</b>:每个进程拥有独立的虚拟地址空间(通常为4GB或更大),通过页表(Page Table)映射到物理内存.这种抽象隔离了进程,防止非法访问.</li></ul><ul><li><b>分页机制</b>:物理内存被划分为固定大小的页(通常4KB),由MMU(内存管理单元)负责虚拟地址到物理地址的转换.</li></ul></li></ol><ol start="2"><li><b>内存分配策略</b><ul><li><b>伙伴系统(Buddy System)</b>:管理物理页的分配与释放,通过合并相邻空闲页减少外部碎片.</li></ul><ul><li><b>Slab分配器</b>:针对小内存对象(如内核数据结构)优化,减少内部碎片,提高分配速度.</li></ul></li></ol><ol start="3"><li><b>内存回收与交换</b><ul><li><b>页面缓存(Page Cache)</b>:将磁盘文件数据缓存在内存中,加速I/O操作.</li></ul><ul><li><b>交换空间(Swap)</b>:当物理内存不足时,将不活跃的页面换出到磁盘(通过<code>kswapd</code>守护进程).</li></ul><ul><li><b>OOM Killer</b>:在内存耗尽时,选择&quot;最不重要&quot;的进程终止以释放内存.</li></ul></li></ol><ol start="4"><li><b>进程地址空间管理</b><ul><li><b>用户空间</b>:包含代码段、堆、栈、共享库等,通过<code>mmap</code>动态扩展.</li></ul><ul><li><b>内核空间</b>:直接映射物理内存(ZONE_DMA、ZONE_NORMAL等区域),处理中断和内核线程.</li></ul></li></ol><ol start="5"><li><b>NUMA支持</b><ul><li>针对多处理器架构,优先在本地内存节点分配内存,减少跨节点访问延迟.</li></ul></li></ol><p>等等方面的问题, 本节我们从最基本的物理内存布局探测入手, 在本系列中逐步分析这些内容</p><hr><p>对于一个操作系统, 在启动之初有两个非常关键的问题</p><ul><li>操作系统怎样获取设备总内存大小?</li></ul><ul><li>设备的所有内存,操作系统都可以使用吗?</li></ul><h2 id="h2-1">获取设备总内存</h2><p>内存在硬件上的表现为内存条, 以及内存条上的内存颗粒. 从软件角度来看可以理解为是一大块连续的数组, 每个数组元素占 1 字节. <b>内存总大小等信息作为设备的关键信息,应该在硬件启动初期就由CPU获得并存储,操作系统只需要通过CPU的相关协定读取即可,这个协定就是BIOS中断</b></p><p>在x86芯片中,探测物理内存布局用的<a href="https://en.wikipedia.org/wiki/BIOS_interrupt_call" target="_blank">BIOS中断</a>向量是0x15,<b>根据ax寄存器值的不同</b>,有三种常见的方式:0xE820,0xE801和0x88.</p><p>其中,0xE820 是主探测接口,0xE801、0x88 作为 0xE820 接口的补充.</p><pre class="language-c"><code><span class="Token COMMENT">// arch/x86/boot/main.c</span><span class="Token LF">
</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType VOID">void</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName FunctionName ID">main</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token DirectDeclaractor Declarator SPACE"> </span><span class="Token CompoundStatement Function BraceDepth-0 LCURLY_BRACE">{</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function SPACE">    </span><span class="Token CompoundStatement Function COMMENT">// ...</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function SPACE">    </span><span class="Token CompoundStatement Function COMMENT">/* Detect memory layout */</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">detect_memory</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token ExpressionStatement COMMENT">// ...</span><span class="Token ExpressionStatement LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 RCURLY_BRACE">}</span></code></pre><p>在 detect_memory() 函数中,依次调用了 detect_memory_e820() ,detect_memory_e801() 以及 detect_memory_88() 函数,每个函数对应着上文介绍的一种接口协议</p><pre class="language-c"><code><span class="Token COMMENT">// arch/x86/boot/memory.c</span><span class="Token LF">
</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType VOID">void</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName FunctionName ID">detect_memory</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier VOID">void</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token DirectDeclaractor Declarator SPACE"> </span><span class="Token CompoundStatement Function BraceDepth-0 LCURLY_BRACE">{</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">detect_memory_e820</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement SPACE"> </span><span class="Token ExpressionStatement COMMENT">/* 使用e820 BIOS中断获取物理内存布局 */</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">detect_memory_e801</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement SPACE"> </span><span class="Token ExpressionStatement COMMENT">/* 使用e801 BIOS中断获取物理内存布局 */</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">detect_memory_88</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement SPACE"> </span><span class="Token ExpressionStatement COMMENT">/* 使用88 BIOS中断获取物理内存布局 */</span><span class="Token ExpressionStatement LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 RCURLY_BRACE">}</span></code></pre><h3 id="h3-2">E820</h3><p>前文提到三种探测方式的区别在于<b>根据 AX 寄存器值的不同</b>.其中 e820 需要设置 AX 向量号为 <code>0xe820</code>,</p><blockquote><p><a href="http://www.uruk.org/orig-grub/mem64mb.html" target="_blank">uruk mem64mb</a></p></blockquote><p>该接口返回已安装的内存映射以及为 BIOS 保留的物理内存区域.每次调用该 API,<b>只会返回一段物理内存的信息</b>,信息中会指示内存类型.为了获取完整的内存映射,<b>需要多次调用该接口</b>.</p><p>该接口通过寄存器传参,共有 5 个参数:</p><table><tr><th>寄存器</th><th>描述</th></tr><tr><td style="text-align:left">                <b>EAX</b></td><td style="text-align:left">                功能码,值为 <code>E820</code>.</td></tr><tr><td style="text-align:left">                <b>EBX</b></td><td style="text-align:left">                <b>首次调用时,必须设置为 0.当调用后,EBX 中包含下次运行的物理地址,如果该值为 0,说明完成探测.</b></td></tr><tr><td style="text-align:left">                <b>ES:DI</b></td><td style="text-align:left">                Buffer 指针,BIOS 会将探测结果填充到指针指向的 Buffer 中.</td></tr><tr><td style="text-align:left">                <b>ECX</b></td><td style="text-align:left">                以字节为单位的 Buffer 大小,最小为 20 字节.</td></tr><tr><td style="text-align:left">                <b>EDX</b></td><td style="text-align:left">                签名,ASCII 码 <code>&quot;SMAP&quot;</code>,用来验证调用者.</td></tr></table><p>接口的输出结果,也保存在 5 个寄存器中:</p><table><tr><th>寄存器</th><th>描述</th></tr><tr><td style="text-align:left">                <b>CF</b></td><td style="text-align:left">                状态寄存器 <code>EFLAGS</code> 的 <code>CF</code> 标志位,用来指示请求是否出错.当 <code>CF</code> 为 0 时,指示未发生错误.</td></tr><tr><td style="text-align:left">                <b>EAX</b></td><td style="text-align:left">                签名,ASCII 码 <code>&quot;SMAP&quot;</code>.</td></tr><tr><td style="text-align:left">                <b>ES:DI</b></td><td style="text-align:left">                Buffer 指针,与输入一致.</td></tr><tr><td style="text-align:left">                <b>ECX</b></td><td style="text-align:left">                <b>Buffer 大小,BIOS 返回数据的大小.</b></td></tr><tr><td style="text-align:left">                <b>EBX</b></td><td style="text-align:left">                <b>指示是否需要继续查询.当该值为 0 时,表示已查询到最后一段内存.</b></td></tr></table><blockquote style="border-left-color: #0969da; background-color: #e8f3ff;"><p><div style="color: #0969da;"><img class="icon-note" loading="lazy" src="../../../img/note.svg" alt="[!NOTE]"> NOTE </div> 简而言之, 参数需要传入一个 buffer, BIOS内存探测的结果会保存在 buffer 中(ecx)</p><p>需要连续调用, 直到 ebx == 0</p></blockquote><p>我们来结合这部分的代码看一下</p><pre class="language-c"><code><span class="Token COMMENT">// arch/x86/boot/memory.c</span><span class="Token LF">
</span><span class="Token HASH">#</span><span class="Token Keyword Preprocess ControlLine DEFINE">define</span><span class="Token Keyword Preprocess ControlLine SPACE"> </span><span class="Token Identifier MacroDefine ControlLine MacroDefine ID">SMAP</span><span class="Token PPtoken SPACE">    </span><span class="Token PPtoken NUMBER">0x534d4150</span><span class="Token PPtoken SPACE">  </span><span class="Token PPtoken COMMENT">/* ASCII &quot;SMAP&quot; */</span><span class="Token LF">
</span><span class="Token LF">
</span><span class="Token COMMENT">// Input:</span><span class="Token LF">
</span><span class="Token COMMENT">// AX = E820h</span><span class="Token LF">
</span><span class="Token COMMENT">// EAX = 0000E820h</span><span class="Token LF">
</span><span class="Token COMMENT">// EDX = 534D4150h (&#x27;SMAP&#x27;)</span><span class="Token LF">
</span><span class="Token COMMENT">// EBX = continuation value or 00000000h to start at beginning of map</span><span class="Token LF">
</span><span class="Token COMMENT">// ECX = size of buffer for result, in bytes (should be &gt;= 20 bytes)</span><span class="Token LF">
</span><span class="Token COMMENT">// ES:DI -&gt; buffer for result (see #00581)</span><span class="Token LF">
</span><span class="Token COMMENT">// int 0x15</span><span class="Token LF">
</span><span class="Token Keyword StorageType FunctionReturnType STATIC">static</span><span class="Token Keyword StorageType FunctionReturnType SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType VOID">void</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName FunctionName ID">detect_memory_e820</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier VOID">void</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token DirectDeclaractor Declarator LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 LCURLY_BRACE">{</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">count</span><span class="Token Identifier DirectDeclaractor SPACE"> </span><span class="Token InitDeclarator ASSIGN">=</span><span class="Token InitDeclarator SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">0</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration SPACE">    </span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">biosregs</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">ireg</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">oreg</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration SPACE">    </span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">boot_e820_entry</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor ID">desc</span><span class="Token Identifier DirectDeclaractor SPACE"> </span><span class="Token InitDeclarator ASSIGN">=</span><span class="Token InitDeclarator SPACE"> </span><span class="Token Identifier PrimaryExpression ID">boot_params</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">e820_table</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration SPACE">    </span><span class="Token Keyword StorageType STATIC">static</span><span class="Token Keyword StorageType SPACE"> </span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">boot_e820_entry</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">buf</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration SPACE"> </span><span class="Token Declaration COMMENT">/* static so it is zeroed */</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Declaration HighlightLine SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall HighlightLine ID">initregs</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 HighlightLine LPAREN">(</span><span class="Token UnaryOp UnaryExpression HighlightLine AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression HighlightLine ID">ireg</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 HighlightLine RPAREN">)</span><span class="Token ExpressionStatement HighlightLine SEMI">;</span><span class="Token ExpressionStatement HighlightLine LF">
</span><span class="Token ExpressionStatement HighlightLine SPACE">    </span><span class="Token Identifier PrimaryExpression HighlightLine ID">ireg</span><span class="Token PostfixExpression UnaryExpression HighlightLine DOT">.</span><span class="Token Identifier HighlightLine ID">ax</span><span class="Token Identifier HighlightLine SPACE">  </span><span class="Token AssignOp AssignmentExpression HighlightLine ASSIGN">=</span><span class="Token AssignOp AssignmentExpression HighlightLine SPACE"> </span><span class="Token Constant PrimaryExpression HighlightLine NUMBER">0xe820</span><span class="Token ExpressionStatement HighlightLine SEMI">;</span><span class="Token ExpressionStatement HighlightLine LF">
</span><span class="Token ExpressionStatement HighlightLine SPACE">    </span><span class="Token Identifier PrimaryExpression HighlightLine ID">ireg</span><span class="Token PostfixExpression UnaryExpression HighlightLine DOT">.</span><span class="Token Identifier HighlightLine ID">cx</span><span class="Token Identifier HighlightLine SPACE">  </span><span class="Token AssignOp AssignmentExpression HighlightLine ASSIGN">=</span><span class="Token AssignOp AssignmentExpression HighlightLine SPACE"> </span><span class="Token Keyword UnaryExpression HighlightLine SIZEOF">sizeof</span><span class="Token UnaryExpression CastExpression BraceDepth-1 HighlightLine LPAREN">(</span><span class="Token Identifier PrimaryExpression HighlightLine ID">buf</span><span class="Token UnaryExpression CastExpression BraceDepth-1 HighlightLine RPAREN">)</span><span class="Token ExpressionStatement HighlightLine SEMI">;</span><span class="Token ExpressionStatement HighlightLine LF">
</span><span class="Token ExpressionStatement HighlightLine SPACE">    </span><span class="Token Identifier PrimaryExpression HighlightLine ID">ireg</span><span class="Token PostfixExpression UnaryExpression HighlightLine DOT">.</span><span class="Token Identifier HighlightLine ID">edx</span><span class="Token Identifier HighlightLine SPACE"> </span><span class="Token AssignOp AssignmentExpression HighlightLine ASSIGN">=</span><span class="Token AssignOp AssignmentExpression HighlightLine SPACE"> </span><span class="Token MacroDefine Identifier MacroDefine PrimaryExpression HighlightLine ID">SMAP</span><span class="Token ExpressionStatement HighlightLine SEMI">;</span><span class="Token ExpressionStatement HighlightLine LF">
</span><span class="Token ExpressionStatement HighlightLine SPACE">    </span><span class="Token Identifier PrimaryExpression HighlightLine ID">ireg</span><span class="Token PostfixExpression UnaryExpression HighlightLine DOT">.</span><span class="Token Identifier HighlightLine ID">di</span><span class="Token Identifier HighlightLine SPACE">  </span><span class="Token AssignOp AssignmentExpression HighlightLine ASSIGN">=</span><span class="Token AssignOp AssignmentExpression HighlightLine SPACE"> </span><span class="Token CastExpression ConditionalExpression BraceDepth-1 HighlightLine LPAREN">(</span><span class="Token Keyword Typedefine TypeSpecifier HighlightLine TYPEDEF_ID">size_t</span><span class="Token CastExpression ConditionalExpression BraceDepth-1 HighlightLine RPAREN">)</span><span class="Token UnaryOp UnaryExpression HighlightLine AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression HighlightLine ID">buf</span><span class="Token ExpressionStatement HighlightLine SEMI">;</span><span class="Token ExpressionStatement HighlightLine LF">
</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Keyword IterationStatement DO">do</span><span class="Token Keyword IterationStatement SPACE"> </span><span class="Token CompoundStatement IterationStatement BraceDepth-1 LCURLY_BRACE">{</span><span class="Token CompoundStatement IterationStatement LF">
</span><span class="Token CompoundStatement IterationStatement SPACE">        </span><span class="Token Identifier PrimaryExpression FunctionCall ID">intcall</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 LPAREN">(</span><span class="Token Constant PrimaryExpression NUMBER">0x15</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">        </span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ebx</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ebx</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement SPACE"> </span><span class="Token ExpressionStatement COMMENT">/* for next iteration... */</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">        </span><span class="Token Keyword SelectionStatement IF">if</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token SelectionStatement BraceDepth-2 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">eflags</span><span class="Token Identifier SPACE"> </span><span class="Token BinaryOp ConditionalExpression AMPERSAND">&amp;</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">X86_EFLAGS_CF</span><span class="Token SelectionStatement BraceDepth-2 RPAREN">)</span><span class="Token SelectionStatement LF">
</span><span class="Token SelectionStatement SPACE">            </span><span class="Token Keyword JumpStatement BREAK">break</span><span class="Token JumpStatement SelectionStatement SEMI">;</span><span class="Token JumpStatement SelectionStatement LF">
</span><span class="Token JumpStatement SelectionStatement LF">
</span><span class="Token JumpStatement SelectionStatement SPACE">        </span><span class="Token Keyword SelectionStatement IF">if</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token SelectionStatement BraceDepth-2 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">eax</span><span class="Token Identifier SPACE"> </span><span class="Token BinaryOp ConditionalExpression NE">!=</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token MacroDefine Identifier MacroDefine PrimaryExpression ID">SMAP</span><span class="Token SelectionStatement BraceDepth-2 RPAREN">)</span><span class="Token SelectionStatement SPACE"> </span><span class="Token CompoundStatement SelectionStatement BraceDepth-2 LCURLY_BRACE">{</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">            </span><span class="Token Identifier PrimaryExpression ID">count</span><span class="Token Identifier PrimaryExpression SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">0</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">            </span><span class="Token Keyword JumpStatement BREAK">break</span><span class="Token JumpStatement SEMI">;</span><span class="Token JumpStatement LF">
</span><span class="Token JumpStatement SPACE">        </span><span class="Token CompoundStatement SelectionStatement BraceDepth-2 RCURLY_BRACE">}</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">        </span><span class="Token UnaryOp UnaryExpression POINTER">*</span><span class="Token Identifier PrimaryExpression ID">desc</span><span class="Token PostfixExpression UnaryExpression INC">++</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">buf</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">        </span><span class="Token Identifier PrimaryExpression ID">count</span><span class="Token PostfixExpression UnaryExpression INC">++</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement HighlightLine SPACE">    </span><span class="Token CompoundStatement IterationStatement BraceDepth-1 HighlightLine RCURLY_BRACE">}</span><span class="Token CompoundStatement IterationStatement HighlightLine SPACE"> </span><span class="Token Keyword IterationStatement HighlightLine WHILE">while</span><span class="Token Keyword IterationStatement HighlightLine SPACE"> </span><span class="Token IterationStatement BraceDepth-1 HighlightLine LPAREN">(</span><span class="Token Identifier PrimaryExpression HighlightLine ID">ireg</span><span class="Token PostfixExpression UnaryExpression HighlightLine DOT">.</span><span class="Token Identifier HighlightLine ID">ebx</span><span class="Token Identifier HighlightLine SPACE"> </span><span class="Token BinaryOp ConditionalExpression HighlightLine AND">&amp;&amp;</span><span class="Token BinaryOp ConditionalExpression HighlightLine SPACE"> </span><span class="Token Identifier PrimaryExpression HighlightLine ID">count</span><span class="Token Identifier PrimaryExpression HighlightLine SPACE"> </span><span class="Token BinaryOp HighlightLine LT">&lt;</span><span class="Token BinaryOp HighlightLine SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression HighlightLine ID">ARRAY_SIZE</span><span class="Token BraceDepth-2 HighlightLine LPAREN">(</span><span class="Token Identifier HighlightLine ID">boot_params</span><span class="Token PPtoken HighlightLine DOT">.</span><span class="Token Identifier HighlightLine ID">e820_table</span><span class="Token BraceDepth-2 HighlightLine RPAREN">)</span><span class="Token IterationStatement BraceDepth-1 HighlightLine RPAREN">)</span><span class="Token IterationStatement HighlightLine SEMI">;</span><span class="Token IterationStatement HighlightLine LF">
</span><span class="Token IterationStatement LF">
</span><span class="Token IterationStatement SPACE">    </span><span class="Token Identifier PrimaryExpression ID">boot_params</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">e820_entries</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">count</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 RCURLY_BRACE">}</span></code></pre><p>初始化阶段将参数 ireg 的 ax 设置为 <code>e820</code> 标记这是一个 BIOS E820 的中断. 并将结果保存在 buf 中, edx 设置为 ASCII 的 &quot;SMAP&quot;</p><p>调用 intcall 0x15 获取结果, 循环调用直到 ireg.ebx 的值为 0, 或者超过 e820_table 的数组大小</p><h3 id="h3-3">E801</h3><p>相比E820中断,E801的输出和输出就简单了不少, 输入只需要传入一个 AX 值</p><table><tr><th>寄存器</th><th>描述</th></tr><tr><td style="text-align:left">                <b>AX</b></td><td style="text-align:left">                功能码,值为 <code>E801</code>.</td></tr></table><p>接口的输出结果,也保存在 5 个寄存器中:</p><table><tr><th>寄存器</th><th>描述</th></tr><tr><td style="text-align:left">                <b>CF</b></td><td style="text-align:left">                状态寄存器 <code>EFLAGS</code> 的 <code>CF</code> 标志位,用来指示请求是否出错.当 <code>CF</code> 为 0 时,指示未发生错误.</td></tr><tr><td style="text-align:left">                <b>AX</b></td><td style="text-align:left">                在 1MB 到 16 MB 之间的内存,以 KB 为单位.最大为 0x3C00,即 15 MB 内存.</td></tr><tr><td style="text-align:left">                <b>BX</b></td><td style="text-align:left">                在 16 MB 到 4 GB 之间的内存,以 64 KB 为单位</td></tr><tr><td style="text-align:left">                <b>CX</b></td><td style="text-align:left">                同AX</td></tr><tr><td style="text-align:left">                <b>DX</b></td><td style="text-align:left">                同BX</td></tr></table><p>为什么 AX 的最大值是 0x3C00 ?这是由于历史原因导致的.在 80286 时代,ISA 总线由 8 位扩展到了 24 位,24 位的地址线最大寻址空间为 16M,而15 MB ~ 16 MB 的空间要用于 ISA 设备的内存映射,不能自由使用,这段内存也被称为 &quot;ISA Memory Hole&quot;</p><pre class="language-c"><code><span class="Token Keyword StorageType FunctionReturnType STATIC">static</span><span class="Token Keyword StorageType FunctionReturnType SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType VOID">void</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName FunctionName ID">detect_memory_e801</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier VOID">void</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token DirectDeclaractor Declarator LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 LCURLY_BRACE">{</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function SPACE">    </span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">biosregs</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">ireg</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">oreg</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Declaration SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">initregs</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ax</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">0xe801</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">intcall</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token Constant PrimaryExpression NUMBER">0x15</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Keyword SelectionStatement IF">if</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token SelectionStatement BraceDepth-1 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">eflags</span><span class="Token Identifier SPACE"> </span><span class="Token BinaryOp ConditionalExpression AMPERSAND">&amp;</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">X86_EFLAGS_CF</span><span class="Token SelectionStatement BraceDepth-1 RPAREN">)</span><span class="Token SelectionStatement LF">
</span><span class="Token SelectionStatement SPACE">        </span><span class="Token Keyword JumpStatement RETURN">return</span><span class="Token JumpStatement SelectionStatement SEMI">;</span><span class="Token JumpStatement SelectionStatement LF">
</span><span class="Token JumpStatement SelectionStatement LF">
</span><span class="Token JumpStatement SelectionStatement HighlightLine SPACE">    </span><span class="Token JumpStatement SelectionStatement HighlightLine COMMENT">/* Do we really need to do this? */</span><span class="Token JumpStatement SelectionStatement HighlightLine LF">
</span><span class="Token JumpStatement SelectionStatement HighlightLine SPACE">    </span><span class="Token Keyword SelectionStatement HighlightLine IF">if</span><span class="Token Keyword SelectionStatement HighlightLine SPACE"> </span><span class="Token SelectionStatement BraceDepth-1 HighlightLine LPAREN">(</span><span class="Token Identifier PrimaryExpression HighlightLine ID">oreg</span><span class="Token PostfixExpression UnaryExpression HighlightLine DOT">.</span><span class="Token Identifier HighlightLine ID">cx</span><span class="Token Identifier HighlightLine SPACE"> </span><span class="Token BinaryOp ConditionalExpression HighlightLine OR">||</span><span class="Token BinaryOp ConditionalExpression HighlightLine SPACE"> </span><span class="Token Identifier PrimaryExpression HighlightLine ID">oreg</span><span class="Token PostfixExpression UnaryExpression HighlightLine DOT">.</span><span class="Token Identifier HighlightLine ID">dx</span><span class="Token SelectionStatement BraceDepth-1 HighlightLine RPAREN">)</span><span class="Token SelectionStatement HighlightLine SPACE"> </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 HighlightLine LCURLY_BRACE">{</span><span class="Token CompoundStatement SelectionStatement HighlightLine LF">
</span><span class="Token CompoundStatement SelectionStatement HighlightLine SPACE">        </span><span class="Token Identifier PrimaryExpression HighlightLine ID">oreg</span><span class="Token PostfixExpression UnaryExpression HighlightLine DOT">.</span><span class="Token Identifier HighlightLine ID">ax</span><span class="Token Identifier HighlightLine SPACE"> </span><span class="Token AssignOp AssignmentExpression HighlightLine ASSIGN">=</span><span class="Token AssignOp AssignmentExpression HighlightLine SPACE"> </span><span class="Token Identifier PrimaryExpression HighlightLine ID">oreg</span><span class="Token PostfixExpression UnaryExpression HighlightLine DOT">.</span><span class="Token Identifier HighlightLine ID">cx</span><span class="Token ExpressionStatement HighlightLine SEMI">;</span><span class="Token ExpressionStatement HighlightLine LF">
</span><span class="Token ExpressionStatement HighlightLine SPACE">        </span><span class="Token Identifier PrimaryExpression HighlightLine ID">oreg</span><span class="Token PostfixExpression UnaryExpression HighlightLine DOT">.</span><span class="Token Identifier HighlightLine ID">bx</span><span class="Token Identifier HighlightLine SPACE"> </span><span class="Token AssignOp AssignmentExpression HighlightLine ASSIGN">=</span><span class="Token AssignOp AssignmentExpression HighlightLine SPACE"> </span><span class="Token Identifier PrimaryExpression HighlightLine ID">oreg</span><span class="Token PostfixExpression UnaryExpression HighlightLine DOT">.</span><span class="Token Identifier HighlightLine ID">dx</span><span class="Token ExpressionStatement HighlightLine SEMI">;</span><span class="Token ExpressionStatement HighlightLine LF">
</span><span class="Token ExpressionStatement HighlightLine SPACE">    </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 HighlightLine RCURLY_BRACE">}</span><span class="Token CompoundStatement SelectionStatement HighlightLine LF">
</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">    </span><span class="Token Keyword SelectionStatement IF">if</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token SelectionStatement BraceDepth-1 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ax</span><span class="Token Identifier SPACE"> </span><span class="Token BinaryOp ConditionalExpression GT">&gt;</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">15</span><span class="Token BinaryOp MUL">*</span><span class="Token Constant PrimaryExpression NUMBER">1024</span><span class="Token SelectionStatement BraceDepth-1 RPAREN">)</span><span class="Token SelectionStatement SPACE"> </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 LCURLY_BRACE">{</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">        </span><span class="Token Keyword JumpStatement RETURN">return</span><span class="Token JumpStatement SEMI">;</span><span class="Token JumpStatement SPACE"> </span><span class="Token JumpStatement COMMENT">/* Bogus! */</span><span class="Token JumpStatement LF">
</span><span class="Token JumpStatement SPACE">    </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 RCURLY_BRACE">}</span><span class="Token CompoundStatement SelectionStatement SPACE"> </span><span class="Token Keyword SelectionStatement ELSE">else</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token Keyword SelectionStatement IF">if</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token SelectionStatement SelectionStatement BraceDepth-1 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ax</span><span class="Token Identifier SPACE"> </span><span class="Token BinaryOp ConditionalExpression EQ">==</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">15</span><span class="Token BinaryOp MUL">*</span><span class="Token Constant PrimaryExpression NUMBER">1024</span><span class="Token SelectionStatement SelectionStatement BraceDepth-1 RPAREN">)</span><span class="Token SelectionStatement SelectionStatement SPACE"> </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 LCURLY_BRACE">{</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">        </span><span class="Token Identifier PrimaryExpression ID">boot_params</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">alt_mem_k</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token PrimaryExpression PostfixExpression BraceDepth-2 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">bx</span><span class="Token Identifier SPACE"> </span><span class="Token BinaryOp ConditionalExpression SHL">&lt;&lt;</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">6</span><span class="Token PrimaryExpression PostfixExpression BraceDepth-2 RPAREN">)</span><span class="Token PrimaryExpression PostfixExpression SPACE"> </span><span class="Token BinaryOp ConditionalExpression PLUS">+</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ax</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 RCURLY_BRACE">}</span><span class="Token CompoundStatement SelectionStatement SPACE"> </span><span class="Token Keyword SelectionStatement ELSE">else</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 LCURLY_BRACE">{</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">        </span><span class="Token CompoundStatement SelectionStatement COMMENT">/*
         * This ignores memory above 16MB if we have a memory
         * hole there.  If someone actually finds a machine
         * with a memory hole at 16MB and no support for
         * 0E820h they should probably generate a fake e820
         * map.
         */</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">        </span><span class="Token Identifier PrimaryExpression ID">boot_params</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">alt_mem_k</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ax</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 RCURLY_BRACE">}</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 RCURLY_BRACE">}</span></code></pre><blockquote><p>代码中有一段很有意思的注释(高亮部分), 这里的两个字段 cx 和 dx 的设计可能是由于历史原因</p></blockquote><p>由于 ax 的最大值为 15MB,如果大于 15MB,说明出错了,返回 -1;如果 ax 等于 15MB,说明内存大于 16MB,需要计算 bx 寄存器中的内存.由于 bx 中的内存单位为 64KB,所以左移 6 位转换成 KB,再加上 ax 的值,就得到以 KB 为单位的总内存大小,并将结果保存到 boot_params.alt_mem_k 中;如果 ax 小于 15 MB,说明内存不超过 16 MB,ax 的值就是内存总大小.</p><h3 id="h3-4">88</h3><p>相比E820,E88中断可以说非常简单了. 输入只有 AH</p><table><tr><th>寄存器</th><th>描述</th></tr><tr><td style="text-align:left">                <b>AH</b></td><td style="text-align:left">                功能码,值为 <code>88</code>.</td></tr></table><p>输出只需要读取 AX 即可</p><table><tr><th>寄存器</th><th>描述</th></tr><tr><td style="text-align:left">                <b>CF</b></td><td style="text-align:left">                状态寄存器 <code>EFLAGS</code> 的 <code>CF</code> 标志位,用来指示请求是否出错.当 <code>CF</code> 为 0 时,指示未发生错误.</td></tr><tr><td style="text-align:left">                <b>AX</b></td><td style="text-align:left">                &gt;1MB, 以KB为单位</td></tr></table><p>这是一个比较原始的接口. 该接口返回 1 MB 以上的连续内存值,但是由于返回的是 16 位值(以 KB 为单位),因此其能返回的最大值会略低于 64 MB.也就是说,该接口会返回 1MB ~ 64 MB 之间的内存</p><pre class="language-c"><code><span class="Token Keyword StorageType FunctionReturnType STATIC">static</span><span class="Token Keyword StorageType FunctionReturnType SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType VOID">void</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName FunctionName ID">detect_memory_88</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier VOID">void</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token DirectDeclaractor Declarator LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 LCURLY_BRACE">{</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function SPACE">    </span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">biosregs</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">ireg</span><span class="Token COMMA">,</span><span class="Token SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">oreg</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Declaration SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">initregs</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ah</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">0x88</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">intcall</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 LPAREN">(</span><span class="Token Constant PrimaryExpression NUMBER">0x15</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">ireg</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token UnaryOp UnaryExpression AMPERSAND">&amp;</span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression BraceDepth-1 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token Identifier PrimaryExpression ID">boot_params</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">screen_info</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ext_mem_k</span><span class="Token Identifier SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">oreg</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">ax</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 RCURLY_BRACE">}</span></code></pre><p>0x88 接口探测的是 1MB ~ 64 MB 之间的内存.探测完成后,将结果保存到 boot_params.screen_info.ext_mem_k 中</p><h2 id="h2-5">探测结果</h2><p>对比上面三种内存探测方式, 可以看到 e820 探测结果最为重要, 几乎涵盖了系统使用到的大部分内存, 其中 buf 对于的结构体字段如下, 分别对应起始地址, 大小和内存类型</p><pre class="language-c"><code><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">boot_e820_entry</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Structure BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Structure LF">
</span><span class="Token Structure SPACE">    </span><span class="Token MacroDefine Identifier MacroDefine MacroInvocation TypeSpecifier ID">__u64</span><span class="Token Identifier MacroDefine MacroInvocation TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">addr</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token MacroDefine MacroDefine Identifier MacroDefine MacroInvocation TypeSpecifier ID">__u64</span><span class="Token Identifier MacroDefine MacroInvocation TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">size</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token MacroDefine Identifier MacroDefine MacroInvocation TypeSpecifier ID">__u32</span><span class="Token Identifier MacroDefine MacroInvocation TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">type</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token Structure BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Structure SPACE"> </span><span class="Token GNU_C_Assembly Structure _ATTRIBUTE">__attribute__</span><span class="Token GNU_C_Assembly Structure BraceDepth-0 LPAREN">(</span><span class="Token PrimaryExpression PostfixExpression BraceDepth-1 LPAREN">(</span><span class="Token Identifier PrimaryExpression TypeSpecifier ID">packed</span><span class="Token PrimaryExpression PostfixExpression BraceDepth-1 RPAREN">)</span><span class="Token GNU_C_Assembly Structure BraceDepth-0 RPAREN">)</span><span class="Token Declaration SEMI">;</span></code></pre><p>其中内存类型包括以下几种:</p><ul><li>Type 1: Usable (normal) RAM</li></ul><ul><li>Type 2: Reserved - unusable</li></ul><ul><li>Type 3: ACPI reclaimable memory</li></ul><ul><li>Type 4: ACPI NVS memory</li></ul><ul><li>Type 5: Area containing bad memory</li></ul><blockquote><p>其中,ACPI reclaimable memory(ACPI 可回收内存)中保存着 ACPI 表(ACPI tables),当 ACPI 表使用完成后,这部分内存就是可用的,所以被称为可回收内存.在分配物理内存时,内存类型 2、4、5(Reserved,ACPI Non-Volatile-Sleeping,bad )不应被分配.</p><p>由于该接口返回的是未排序的内存列表,可能包含不可用的或重叠的内存区域,所以需要对该列表进行后期处理.</p></blockquote><p>你可以在启动时看到对应的内存区间检测输出结果</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20230628161738.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230628161738.png" alt="20230628161738"></a></p><p>就是在检测后由下面的函数负责输出</p><pre class="language-c"><code><span class="Token Keyword StorageType FunctionReturnType STATIC">static</span><span class="Token Keyword StorageType FunctionReturnType SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType VOID">void</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token MacroDefine Keyword Typedefine TypeSpecifier FunctionReturnType TYPEDEF_ID">__init</span><span class="Token Keyword Typedefine TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName FunctionName ID">e820_print_type</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token Keyword EnumSpecifier TypeSpecifier ENUM">enum</span><span class="Token Keyword EnumSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier EnumSpecifier EnumID TypeSpecifier ID">e820_type</span><span class="Token Identifier EnumSpecifier EnumID TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">type</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token DirectDeclaractor Declarator LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 LCURLY_BRACE">{</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function SPACE">    </span><span class="Token Keyword SelectionStatement SWITCH">switch</span><span class="Token Keyword SelectionStatement SPACE"> </span><span class="Token SelectionStatement BraceDepth-1 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">type</span><span class="Token SelectionStatement BraceDepth-1 RPAREN">)</span><span class="Token SelectionStatement SPACE"> </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 LCURLY_BRACE">{</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement SelectionStatement SPACE">    </span><span class="Token Keyword LabeledStatement CASE">case</span><span class="Token Keyword LabeledStatement SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">E820_TYPE_RAM</span><span class="Token LabeledStatement COLON">:</span><span class="Token LabeledStatement SPACE">     </span><span class="Token LabeledStatement COMMENT">/* Fall through: */</span><span class="Token LabeledStatement LF">
</span><span class="Token LabeledStatement SPACE">    </span><span class="Token Keyword LabeledStatement CASE">case</span><span class="Token Keyword LabeledStatement SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">E820_TYPE_RESERVED_KERN</span><span class="Token LabeledStatement LabeledStatement COLON">:</span><span class="Token LabeledStatement LabeledStatement SPACE">   </span><span class="Token Identifier PrimaryExpression FunctionCall ID">pr_cont</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;usable&quot;</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 RPAREN">)</span><span class="Token ExpressionStatement LabeledStatement SEMI">;</span><span class="Token ExpressionStatement LabeledStatement SPACE">          </span><span class="Token Keyword JumpStatement BREAK">break</span><span class="Token JumpStatement SEMI">;</span><span class="Token JumpStatement LF">
</span><span class="Token JumpStatement SPACE">    </span><span class="Token Keyword LabeledStatement CASE">case</span><span class="Token Keyword LabeledStatement SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">E820_TYPE_RESERVED</span><span class="Token LabeledStatement COLON">:</span><span class="Token LabeledStatement SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">pr_cont</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;reserved&quot;</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 RPAREN">)</span><span class="Token ExpressionStatement LabeledStatement SEMI">;</span><span class="Token ExpressionStatement LabeledStatement SPACE">            </span><span class="Token Keyword JumpStatement BREAK">break</span><span class="Token JumpStatement SEMI">;</span><span class="Token JumpStatement LF">
</span><span class="Token JumpStatement SPACE">    </span><span class="Token Keyword LabeledStatement CASE">case</span><span class="Token Keyword LabeledStatement SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">E820_TYPE_SOFT_RESERVED</span><span class="Token LabeledStatement COLON">:</span><span class="Token LabeledStatement SPACE">   </span><span class="Token Identifier PrimaryExpression FunctionCall ID">pr_cont</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;soft reserved&quot;</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 RPAREN">)</span><span class="Token ExpressionStatement LabeledStatement SEMI">;</span><span class="Token ExpressionStatement LabeledStatement SPACE">       </span><span class="Token Keyword JumpStatement BREAK">break</span><span class="Token JumpStatement SEMI">;</span><span class="Token JumpStatement LF">
</span><span class="Token JumpStatement SPACE">    </span><span class="Token Keyword LabeledStatement CASE">case</span><span class="Token Keyword LabeledStatement SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">E820_TYPE_ACPI</span><span class="Token LabeledStatement COLON">:</span><span class="Token LabeledStatement SPACE">        </span><span class="Token Identifier PrimaryExpression FunctionCall ID">pr_cont</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;ACPI data&quot;</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 RPAREN">)</span><span class="Token ExpressionStatement LabeledStatement SEMI">;</span><span class="Token ExpressionStatement LabeledStatement SPACE">           </span><span class="Token Keyword JumpStatement BREAK">break</span><span class="Token JumpStatement SEMI">;</span><span class="Token JumpStatement LF">
</span><span class="Token JumpStatement SPACE">    </span><span class="Token Keyword LabeledStatement CASE">case</span><span class="Token Keyword LabeledStatement SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">E820_TYPE_NVS</span><span class="Token LabeledStatement COLON">:</span><span class="Token LabeledStatement SPACE">     </span><span class="Token Identifier PrimaryExpression FunctionCall ID">pr_cont</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;ACPI NVS&quot;</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 RPAREN">)</span><span class="Token ExpressionStatement LabeledStatement SEMI">;</span><span class="Token ExpressionStatement LabeledStatement SPACE">            </span><span class="Token Keyword JumpStatement BREAK">break</span><span class="Token JumpStatement SEMI">;</span><span class="Token JumpStatement LF">
</span><span class="Token JumpStatement SPACE">    </span><span class="Token Keyword LabeledStatement CASE">case</span><span class="Token Keyword LabeledStatement SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">E820_TYPE_UNUSABLE</span><span class="Token LabeledStatement COLON">:</span><span class="Token LabeledStatement SPACE">    </span><span class="Token Identifier PrimaryExpression FunctionCall ID">pr_cont</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;unusable&quot;</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 RPAREN">)</span><span class="Token ExpressionStatement LabeledStatement SEMI">;</span><span class="Token ExpressionStatement LabeledStatement SPACE">            </span><span class="Token Keyword JumpStatement BREAK">break</span><span class="Token JumpStatement SEMI">;</span><span class="Token JumpStatement LF">
</span><span class="Token JumpStatement SPACE">    </span><span class="Token Keyword LabeledStatement CASE">case</span><span class="Token Keyword LabeledStatement SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">E820_TYPE_PMEM</span><span class="Token LabeledStatement COLON">:</span><span class="Token LabeledStatement SPACE">        </span><span class="Token LabeledStatement COMMENT">/* Fall through: */</span><span class="Token LabeledStatement LF">
</span><span class="Token LabeledStatement SPACE">    </span><span class="Token Keyword LabeledStatement CASE">case</span><span class="Token Keyword LabeledStatement SPACE"> </span><span class="Token Identifier MacroDefine PrimaryExpression ID">E820_TYPE_PRAM</span><span class="Token LabeledStatement LabeledStatement COLON">:</span><span class="Token LabeledStatement LabeledStatement SPACE">        </span><span class="Token Identifier PrimaryExpression FunctionCall ID">pr_cont</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;persistent (type </span><span class="Token Format String STRING">%u</span><span class="Token String STRING">)&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">type</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 RPAREN">)</span><span class="Token ExpressionStatement LabeledStatement SEMI">;</span><span class="Token ExpressionStatement LabeledStatement SPACE">  </span><span class="Token Keyword JumpStatement BREAK">break</span><span class="Token JumpStatement SEMI">;</span><span class="Token JumpStatement LF">
</span><span class="Token JumpStatement SPACE">    </span><span class="Token Keyword LabeledStatement DEFAULT">default</span><span class="Token LabeledStatement COLON">:</span><span class="Token LabeledStatement SPACE">            </span><span class="Token Identifier PrimaryExpression FunctionCall ID">pr_cont</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;type </span><span class="Token Format String STRING">%u</span><span class="Token String STRING">&quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">type</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 RPAREN">)</span><span class="Token ExpressionStatement LabeledStatement SEMI">;</span><span class="Token ExpressionStatement LabeledStatement SPACE">       </span><span class="Token Keyword JumpStatement BREAK">break</span><span class="Token JumpStatement SEMI">;</span><span class="Token JumpStatement LF">
</span><span class="Token JumpStatement SPACE">    </span><span class="Token CompoundStatement SelectionStatement BraceDepth-1 RCURLY_BRACE">}</span><span class="Token CompoundStatement SelectionStatement LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 RCURLY_BRACE">}</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function LF">
</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType VOID">void</span><span class="Token Keyword BaseType TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token MacroDefine MacroDefine Keyword Typedefine TypeSpecifier FunctionReturnType TYPEDEF_ID">__init</span><span class="Token Keyword Typedefine TypeSpecifier FunctionReturnType SPACE"> </span><span class="Token Identifier DirectDeclaractor FunctionName FunctionName ID">e820__print_table</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 LPAREN">(</span><span class="Token Keyword BaseType TypeSpecifier CHAR">char</span><span class="Token Keyword BaseType TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor ID">who</span><span class="Token DirectDeclaractor Declarator BraceDepth-0 RPAREN">)</span><span class="Token DirectDeclaractor Declarator LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 LCURLY_BRACE">{</span><span class="Token CompoundStatement Function LF">
</span><span class="Token CompoundStatement Function SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor ID">i</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Declaration SPACE">    </span><span class="Token Keyword IterationStatement FOR">for</span><span class="Token Keyword IterationStatement SPACE"> </span><span class="Token IterationStatement BraceDepth-1 LPAREN">(</span><span class="Token Identifier PrimaryExpression ID">i</span><span class="Token Identifier PrimaryExpression SPACE"> </span><span class="Token AssignOp AssignmentExpression ASSIGN">=</span><span class="Token AssignOp AssignmentExpression SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">0</span><span class="Token IterationStatement SEMI">;</span><span class="Token IterationStatement SPACE"> </span><span class="Token Identifier PrimaryExpression ID">i</span><span class="Token Identifier PrimaryExpression SPACE"> </span><span class="Token BinaryOp ConditionalExpression LT">&lt;</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">e820_table</span><span class="Token PostfixExpression UnaryExpression POINT">-&gt;</span><span class="Token Identifier ID">nr_entries</span><span class="Token IterationStatement SEMI">;</span><span class="Token IterationStatement SPACE"> </span><span class="Token Identifier PrimaryExpression ID">i</span><span class="Token PostfixExpression UnaryExpression INC">++</span><span class="Token IterationStatement BraceDepth-1 RPAREN">)</span><span class="Token IterationStatement SPACE"> </span><span class="Token CompoundStatement IterationStatement BraceDepth-1 LCURLY_BRACE">{</span><span class="Token CompoundStatement IterationStatement LF">
</span><span class="Token CompoundStatement IterationStatement SPACE">        </span><span class="Token Identifier PrimaryExpression FunctionCall ID">pr_info</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Format String STRING">%s</span><span class="Token String STRING">: [mem </span><span class="Token Format String STRING">%#018Lx</span><span class="Token String STRING">-</span><span class="Token Format String STRING">%#018Lx</span><span class="Token String STRING">] &quot;</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression LF">
</span><span class="Token PostfixExpression UnaryExpression SPACE">            </span><span class="Token Identifier PrimaryExpression ID">who</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression LF">
</span><span class="Token PostfixExpression UnaryExpression SPACE">            </span><span class="Token Identifier PrimaryExpression ID">e820_table</span><span class="Token PostfixExpression UnaryExpression POINT">-&gt;</span><span class="Token Identifier ID">entries</span><span class="Token PostfixExpression UnaryExpression BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token Identifier PrimaryExpression ID">i</span><span class="Token PostfixExpression UnaryExpression BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">addr</span><span class="Token PostfixExpression UnaryExpression COMMA">,</span><span class="Token PostfixExpression UnaryExpression LF">
</span><span class="Token PostfixExpression UnaryExpression SPACE">            </span><span class="Token Identifier PrimaryExpression ID">e820_table</span><span class="Token PostfixExpression UnaryExpression POINT">-&gt;</span><span class="Token Identifier ID">entries</span><span class="Token PostfixExpression UnaryExpression BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token Identifier PrimaryExpression ID">i</span><span class="Token PostfixExpression UnaryExpression BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">addr</span><span class="Token Identifier SPACE"> </span><span class="Token BinaryOp ConditionalExpression PLUS">+</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Identifier PrimaryExpression ID">e820_table</span><span class="Token PostfixExpression UnaryExpression POINT">-&gt;</span><span class="Token Identifier ID">entries</span><span class="Token PostfixExpression UnaryExpression BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token Identifier PrimaryExpression ID">i</span><span class="Token PostfixExpression UnaryExpression BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token PostfixExpression UnaryExpression DOT">.</span><span class="Token Identifier ID">size</span><span class="Token Identifier SPACE"> </span><span class="Token BinaryOp ConditionalExpression MINUS">-</span><span class="Token BinaryOp ConditionalExpression SPACE"> </span><span class="Token Constant PrimaryExpression NUMBER">1</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">        </span><span class="Token Identifier FunctionName PrimaryExpression ID">e820_print_type</span><span class="Token BraceDepth-2 LPAREN">(</span><span class="Token Identifier ID">e820_table</span><span class="Token PPtoken POINT">-&gt;</span><span class="Token Identifier ID">entries</span><span class="Token PPtoken BraceDepth-0 LSQUAR_PAREN">[</span><span class="Token Identifier ID">i</span><span class="Token PPtoken BraceDepth-0 RSQUAR_PAREN">]</span><span class="Token PPtoken DOT">.</span><span class="Token Identifier ID">type</span><span class="Token BraceDepth-2 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">        </span><span class="Token Identifier PrimaryExpression FunctionCall ID">pr_cont</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 LPAREN">(</span><span class="Token String STRING">&quot;</span><span class="Token Control String STRING">\n</span><span class="Token String STRING">&quot;</span><span class="Token PostfixExpression UnaryExpression BraceDepth-2 RPAREN">)</span><span class="Token ExpressionStatement SEMI">;</span><span class="Token ExpressionStatement LF">
</span><span class="Token ExpressionStatement SPACE">    </span><span class="Token CompoundStatement IterationStatement BraceDepth-1 RCURLY_BRACE">}</span><span class="Token CompoundStatement IterationStatement LF">
</span><span class="Token CompoundStatement Function BraceDepth-0 RCURLY_BRACE">}</span></code></pre><ul><li>操作系统怎样获取设备总内存大小?<p>答:通过BIOS 0x15中断,常见有E820,E801和E88子中断号.</p></li></ul><ul><li>设备的所有内存,操作系统都可以使用吗?<p>答:不是的,只有内存类型为usable的才能被操作系统所使用.</p></li></ul><h2 id="h2-6">memblock</h2><p>memblock 子系统主要用于引导过程中的物理内存管理, 在操作系统内核早期的启动阶段(即尚未进入 mm_core_init)时, 此时内核尚未完全初始化和建立内存管理器. 此时内核的主要工作只是简单的读取并处理一些系统硬件的信息. 一旦内核初始化完成,memblock 子系统的功能通常会被更高级的内存管理机制所取代,如 buddy allocator(伙伴系统)或 slab allocator(SLAB 系统)</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20230628182631.png"><img loading="lazy" src="https://raw.githubusercontent.com/learner-lu/picbed/master/20230628182631.png" alt="20230628182631"></a></p><p>memblock 的功能主要包括</p><ul><li>内存块的描述:memblock 维护了一个物理内存块的列表,每个内存块由起始地址和大小来描述.通过这些描述信息,内核可以了解系统中可用的物理内存块的位置和大小.</li></ul><ul><li>内存块的分配和释放:memblock 提供了函数来动态分配和释放物理内存块.内核可以使用这些函数来管理物理内存资源,例如在启动过程中分配页表,初始化内核堆栈等.</li></ul><ul><li>物理内存的管理:memblock 子系统还提供了一些函数来管理物理内存的属性和映射关系,例如设置内存块的属性(例如可读写,可执行等),查询内存块是否被保留等.</li></ul><pre class="language-c"><code><span class="Token COMMENT">/**
 * struct memblock - memblock allocator metadata
 * @bottom_up: is bottom up direction? 用于判断记录的内存是否从底部往顶部增长
 * @current_limit: physical address of the current allocation limit 当前内存管理器管理的物理地址上限
 * @memory: usable memory regions 操作系统可用内存,即E820探测物理布局时,flags为usable的内存区域
 * @reserved: reserved memory regions 在boot阶段保留的内存,包括E820探测物理布局时,flags为reserved的内存区域,boot阶段分配出去的内存区域
 */</span><span class="Token LF">
</span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">memblock</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Structure BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Structure LF">
</span><span class="Token Structure SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier BOOL">bool</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">bottom_up</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration SPACE">  </span><span class="Token StructDeclaration COMMENT">/* is bottom up direction? */</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">phys_addr_t</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">current_limit</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword StructureType Structure TypeSpecifier TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier TypeSpecifier ID">memblock_type</span><span class="Token Identifier Structure StructureClass TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">memory</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword StructureType Structure TypeSpecifier TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier TypeSpecifier ID">memblock_type</span><span class="Token Identifier Structure StructureClass TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">reserved</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token Structure BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Declaration SEMI">;</span></code></pre><pre class="language-c"><code><span class="Token COMMENT">/**
 * struct memblock_type - collection of memory regions of certain type
 * @cnt: number of regions 记录的内存区域(memblock_region)的数量
 * @max: size of the allocated array 最多能使用的内存区域数,当预留的内存区域不足时,管理器会扩展
 * @total_size: size of all regions 所有内存区域的内存之和
 * @regions: array of regions 内存区域数组,每一项代表usable或保留的内存区域
 * @name: the memory type symbolic name 内存管理器类型的名称,例如&quot;memory&quot;,&quot;reserved&quot;等
 */</span><span class="Token LF">
</span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">memblock_type</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Structure BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Structure LF">
</span><span class="Token Structure SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier UNSIGNED">unsigned</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier LONG">long</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">cnt</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier UNSIGNED">unsigned</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier LONG">long</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">max</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">phys_addr_t</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">total_size</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword StructureType Structure TypeSpecifier TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier TypeSpecifier ID">memblock_region</span><span class="Token Identifier Structure StructureClass TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">regions</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier CHAR">char</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Pointer Declarator POINTER">*</span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">name</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token Structure BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Declaration SEMI">;</span></code></pre><pre class="language-c"><code><span class="Token COMMENT">/**
 * struct memblock_region - represents a memory region
 * @base: base address of the region 内存区域的起始地址,类型为u64或u32,表示64位/32位架构的支持最大地址长度
 * @size: size of the region 内存区域的大小
 * @flags: memory region attributes 内存区域的类型表示,有四种类型:MEMBLOCK_NONE(普通内存),MEMBLOCK_HOTPLUG(可热拔插内存),MEMBLOCK_MIRROR(镜像内存),MEMBLOCK_NOMAP(非内核直接映射内存),相同类型的相邻内存,条件合适时可以被合并
 * @nid: NUMA node id 暂时略去与NUMA相关的内容
 */</span><span class="Token LF">
</span><span class="Token Keyword StructureType Structure TypeSpecifier STRUCT">struct</span><span class="Token Keyword StructureType Structure TypeSpecifier SPACE"> </span><span class="Token Identifier Structure StructureClass TypeSpecifier ID">memblock_region</span><span class="Token Identifier Structure StructureClass TypeSpecifier SPACE"> </span><span class="Token Structure BraceDepth-0 LCURLY_BRACE">{</span><span class="Token Structure LF">
</span><span class="Token Structure SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">phys_addr_t</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">base</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier TYPEDEF_ID">phys_addr_t</span><span class="Token Keyword Typedefine TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">size</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token StructDeclaration SPACE">    </span><span class="Token Keyword EnumSpecifier TypeSpecifier TypeSpecifier ENUM">enum</span><span class="Token Keyword EnumSpecifier TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier EnumSpecifier EnumID TypeSpecifier TypeSpecifier ID">memblock_flags</span><span class="Token Identifier EnumSpecifier EnumID TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">flags</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token HASH">#</span><span class="Token Keyword Preprocess IfGroup IFDEF">ifdef</span><span class="Token Keyword Preprocess IfGroup SPACE"> </span><span class="Token Identifier MacroDefine IfGroup MacroDefine ID">CONFIG_NUMA</span><span class="Token LF">
</span><span class="Token SPACE">    </span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier INT">int</span><span class="Token Keyword BaseType TypeSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier DirectDeclaractor TypeSpecifier ID">nid</span><span class="Token StructDeclaration SEMI">;</span><span class="Token StructDeclaration LF">
</span><span class="Token HASH">#</span><span class="Token Keyword Preprocess EndifLine ENDIF">endif</span><span class="Token LF">
</span><span class="Token Structure BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Declaration SEMI">;</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Declaration LF">
</span><span class="Token Declaration COMMENT">/**
 * enum memblock_flags - definition of memory region attributes
 * @MEMBLOCK_NONE: no special request
 * @MEMBLOCK_HOTPLUG: memory region indicated in the firmware-provided memory
 * map during early boot as hot(un)pluggable system RAM (e.g., memory range
 * that might get hotunplugged later). With &quot;movable_node&quot; set on the kernel
 * commandline, try keeping this memory region hotunpluggable. Does not apply
 * to memblocks added (&quot;hotplugged&quot;) after early boot.
 * @MEMBLOCK_MIRROR: mirrored region
 * @MEMBLOCK_NOMAP: don&#x27;t add to kernel direct mapping and treat as
 * reserved in the memory map; refer to memblock_mark_nomap() description
 * for further details
 * @MEMBLOCK_DRIVER_MANAGED: memory region that is always detected and added
 * via a driver, and never indicated in the firmware-provided memory map as
 * system RAM. This corresponds to IORESOURCE_SYSRAM_DRIVER_MANAGED in the
 * kernel resource tree.
 */</span><span class="Token Declaration LF">
</span><span class="Token Keyword EnumSpecifier TypeSpecifier ENUM">enum</span><span class="Token Keyword EnumSpecifier TypeSpecifier SPACE"> </span><span class="Token Identifier EnumID EnumSpecifier EnumID TypeSpecifier ID">memblock_flags</span><span class="Token Identifier EnumID EnumSpecifier EnumID TypeSpecifier SPACE"> </span><span class="Token EnumSpecifier BraceDepth-0 LCURLY_BRACE">{</span><span class="Token EnumSpecifier LF">
</span><span class="Token EnumSpecifier SPACE">    </span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier ID">MEMBLOCK_NONE</span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier SPACE">       </span><span class="Token Enumerator ASSIGN">=</span><span class="Token Enumerator SPACE"> </span><span class="Token Constant PrimaryExpression TypeSpecifier NUMBER">0x0</span><span class="Token EnumSpecifier COMMA">,</span><span class="Token EnumSpecifier SPACE">  </span><span class="Token EnumSpecifier COMMENT">/* No special request */</span><span class="Token EnumSpecifier LF">
</span><span class="Token EnumSpecifier SPACE">    </span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier ID">MEMBLOCK_HOTPLUG</span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier SPACE">    </span><span class="Token Enumerator ASSIGN">=</span><span class="Token Enumerator SPACE"> </span><span class="Token Constant PrimaryExpression TypeSpecifier NUMBER">0x1</span><span class="Token EnumSpecifier COMMA">,</span><span class="Token EnumSpecifier SPACE">  </span><span class="Token EnumSpecifier COMMENT">/* hotpluggable region */</span><span class="Token EnumSpecifier LF">
</span><span class="Token EnumSpecifier SPACE">    </span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier ID">MEMBLOCK_MIRROR</span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier SPACE">     </span><span class="Token Enumerator ASSIGN">=</span><span class="Token Enumerator SPACE"> </span><span class="Token Constant PrimaryExpression TypeSpecifier NUMBER">0x2</span><span class="Token EnumSpecifier COMMA">,</span><span class="Token EnumSpecifier SPACE">  </span><span class="Token EnumSpecifier COMMENT">/* mirrored region */</span><span class="Token EnumSpecifier LF">
</span><span class="Token EnumSpecifier SPACE">    </span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier ID">MEMBLOCK_NOMAP</span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier SPACE">      </span><span class="Token Enumerator ASSIGN">=</span><span class="Token Enumerator SPACE"> </span><span class="Token Constant PrimaryExpression TypeSpecifier NUMBER">0x4</span><span class="Token EnumSpecifier COMMA">,</span><span class="Token EnumSpecifier SPACE">  </span><span class="Token EnumSpecifier COMMENT">/* don&#x27;t add to kernel direct mapping */</span><span class="Token EnumSpecifier LF">
</span><span class="Token EnumSpecifier SPACE">    </span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier ID">MEMBLOCK_DRIVER_MANAGED</span><span class="Token Identifier MacroDefine Enumerator Enumerator TypeSpecifier SPACE"> </span><span class="Token Enumerator ASSIGN">=</span><span class="Token Enumerator SPACE"> </span><span class="Token Constant PrimaryExpression TypeSpecifier NUMBER">0x8</span><span class="Token EnumSpecifier COMMA">,</span><span class="Token EnumSpecifier SPACE">  </span><span class="Token EnumSpecifier COMMENT">/* always detected via a driver */</span><span class="Token EnumSpecifier LF">
</span><span class="Token EnumSpecifier BraceDepth-0 RCURLY_BRACE">}</span><span class="Token Declaration SEMI">;</span></code></pre><h2 id="h2-7">总结</h2><p>操作系统通过BIOS 0x15中断,常见有E820、E801和E88子中断号获取设备总内存大小, 内存类型为usable的才能被操作系统所使用</p><p>memblock 子系统主要用于引导过程中的物理内存管理</p><h2 id="h2-8">参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/674987474" target="_blank">Linux Kernel:物理内存布局探测</a></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/435020338" target="_blank">深入理解Linux内存管理(一)物理内存布局探测</a></li></ul><ul><li><a href="https://www.zhihu.com/column/c_1543333099974721536" target="_blank">Linux内存管理 专栏</a></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../快速开始/编译内核" >快速开始</a><ul><li><a href="../../快速开始/编译内核" >编译内核</a></li></ul><ul><li><a href="../../快速开始/调试内核" >调试内核</a></li></ul><ul><li><a href="../../快速开始/开发环境搭建" >开发环境搭建</a></li></ul><ul><li><a href="../../快速开始/调试技巧" >调试技巧</a></li></ul><ul><li><a href="../../快速开始/制作linux发行版" >制作linux发行版</a></li></ul><ul><li><a href="../../快速开始/邮件订阅" >邮件订阅</a></li></ul><ul><li><a href="../../快速开始/git" >git</a></li></ul></li></ul><ul><li><a href="../../mm/物理内存探测" >mm</a><ul><li><a href="../../mm/物理内存探测" >物理内存探测</a></li></ul><ul><li><a href="../../mm/虚拟地址转换" >虚拟地址转换</a></li></ul><ul><li><a href="../../mm/进程内存布局" >进程内存布局</a></li></ul><ul><li><a href="../../mm/页表" >页表</a></li></ul><ul><li><a href="../../mm/numa" >numa</a></li></ul><ul><li><a href="../../mm/vma" >vma</a></li></ul><ul><li><a href="../../mm/zone" >zone</a></li></ul><ul><li><a href="../../mm/buddy" >buddy</a></li></ul><ul><li><a href="../../mm/slab" >slab</a></li></ul><ul><li><a href="../../mm/compaction" >compaction</a></li></ul><ul><li><a href="../../mm/tier-mm" >tier-mm</a></li></ul><ul><li><a href="../../mm/migration" >migration</a></li></ul><ul><li><a href="../../mm/mm_struct" >mm_struct</a></li></ul><ul><li><a href="../../mm/mmio" >mmio</a></li></ul><ul><li><a href="../../mm/LRU" >LRU</a></li></ul><ul><li><a href="../../mm/MGLRU" >MGLRU</a></li></ul><ul><li><a href="../../mm/page" >page</a></li></ul><ul><li><a href="../../mm/folio" >folio</a></li></ul><ul><li><a href="../../mm/autonuma" >autonuma</a></li></ul><ul><li><a href="../../mm/kswapd" >kswapd</a></li></ul><ul><li><a href="../../mm/rmap" >rmap</a></li></ul><ul><li><a href="../../mm/ksm" >ksm</a></li></ul></li></ul><ul><li><a href="../../runtime/ELF文件格式" >runtime</a><ul><li><a href="../../runtime/ELF文件格式" >ELF文件格式</a></li></ul><ul><li><a href="../../runtime/符号表" >符号表</a></li></ul><ul><li><a href="../../runtime/静态链接" >静态链接</a></li></ul><ul><li><a href="../../runtime/装载" >装载</a></li></ul><ul><li><a href="../../runtime/动态链接" >动态链接</a></li></ul><ul><li><a href="../../runtime/库与运行库" >库与运行库</a></li></ul><ul><li><a href="../../runtime/execve" >execve</a></li></ul><ul><li><a href="../../runtime/vsdo" >vsdo</a></li></ul></li></ul><ul><li><a href="../../kernel/init" >kernel</a><ul><li><a href="../../kernel/init" >init</a></li></ul><ul><li><a href="../../kernel/atomic" >atomic</a></li></ul><ul><li><a href="../../kernel/rcu" >rcu</a></li></ul><ul><li><a href="../../kernel/workqueue" >workqueue</a></li></ul><ul><li><a href="../../kernel/lock" >lock</a></li></ul><ul><li><a href="../../kernel/syscall" >syscall</a></li></ul><ul><li><a href="../../kernel/poll" >poll</a></li></ul><ul><li><a href="../../kernel/module" >module</a></li></ul></li></ul><ul><li><a href="../../arch/cpu" >arch</a><ul><li><a href="../../arch/cpu" >cpu</a></li></ul><ul><li><a href="../../arch/cache" >cache</a></li></ul><ul><li><a href="../../arch/multicore" >multicore</a></li></ul><ul><li><a href="../../arch/cache-coherence" >cache-coherence</a></li></ul><ul><li><a href="../../arch/memory-coherence" >memory-coherence</a></li></ul><ul><li><a href="../../arch/io" >io</a></li></ul><ul><li><a href="../../arch/bus" >bus</a></li></ul><ul><li><a href="../../arch/interrupt" >interrupt</a></li></ul></li></ul><ul><li><a href="../../proc/schedule" >proc</a><ul><li><a href="../../proc/schedule" >schedule</a></li></ul><ul><li><a href="../../proc/nice" >nice</a></li></ul><ul><li><a href="../../proc/manage" >manage</a></li></ul><ul><li><a href="../../proc/signal" >signal</a></li></ul><ul><li><a href="../../proc/cgroup" >cgroup</a></li></ul><ul><li><a href="../../proc/task_struct" >task_struct</a></li></ul><ul><li><a href="../../proc/rb-tree" >rb-tree</a></li></ul><ul><li><a href="../../proc/fork" >fork</a></li></ul></li></ul><ul><li><a href="../../net/net-arch" >net</a><ul><li><a href="../../net/net-arch" >net-arch</a></li></ul><ul><li><a href="../../net/ip" >ip</a></li></ul><ul><li><a href="../../net/route" >route</a></li></ul><ul><li><a href="../../net/udp" >udp</a></li></ul><ul><li><a href="../../net/tcp" >tcp</a></li></ul><ul><li><a href="../../net/tools" >tools</a></li></ul></li></ul><ul><li><a href="../../fs/storage" >fs</a><ul><li><a href="../../fs/storage" >storage</a></li></ul><ul><li><a href="../../fs/filesystem" >filesystem</a></li></ul><ul><li><a href="../../fs/fd" >fd</a></li></ul><ul><li><a href="../../fs/inode" >inode</a></li></ul><ul><li><a href="../../fs/directory" >directory</a></li></ul><ul><li><a href="../../fs/disk-layout" >disk-layout</a></li></ul><ul><li><a href="../../fs/mount" >mount</a></li></ul><ul><li><a href="../../fs/vfs" >vfs</a></li></ul><ul><li><a href="../../fs/ext4" >ext4</a></li></ul><ul><li><a href="../../fs/fuse" >fuse</a></li></ul><ul><li><a href="../../fs/distribute-fs" >distribute-fs</a></li></ul></li></ul><ul><li><a href="../../device/disk" >device</a><ul><li><a href="../../device/disk" >disk</a></li></ul><ul><li><a href="../../device/ssd" >ssd</a></li></ul><ul><li><a href="../../device/driver" >driver</a></li></ul><ul><li><a href="../../device/io_uring" >io_uring</a></li></ul><ul><li><a href="../../device/pcie" >pcie</a></li></ul></li></ul><ul><li><a href="../../others/safety" >others</a><ul><li><a href="../../others/safety" >safety</a></li></ul><ul><li><a href="../../others/面试经验" >面试经验</a></li></ul><ul><li><a href="../../others/kernel-code" >kernel-code</a></li></ul></li></ul><ul><li><a href="../../cve/dirtycow" >cve</a><ul><li><a href="../../cve/dirtycow" >dirtycow</a></li></ul><ul><li><a href="../../cve/dirtypipe" >dirtypipe</a></li></ul><ul><li><a href="../../cve/sudo" >sudo</a></li></ul><ul><li><a href="../../cve/meltdown" >meltdown</a></li></ul><ul><li><a href="../../cve/smashex" >smashex</a></li></ul></li></ul><ul><li><a href="../../perf/perf" >perf</a><ul><li><a href="../../perf/perf" >perf</a></li></ul></li></ul><ul><li><a href="../../api/mm" >api</a><ul><li><a href="../../api/mm" >mm</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../快速开始/git","../../mm/虚拟地址转换","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/clipboard.svg","../../../img/clipboard-check.svg");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script>
            <script src="https://giscus.app/client.js" data-repo="luzhixing12345/klinux" 
            data-repo-id="R_kgDOJIKiEw" data-category="Q&A" data-category-id="DIC_kwDOJIKiE84CgFwK" data-mapping="pathname" data-strict="0"
            data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom"
            data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async>
            </script>
            <script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>