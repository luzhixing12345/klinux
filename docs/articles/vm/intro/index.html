<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/c.css /><link rel='stylesheet' href=../../../css/json.css /><link rel='stylesheet' href=../../../css/makefile.css /><link rel='stylesheet' href=../../../css/shell.css /><link rel='stylesheet' href=../../../css/txt.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/klinux.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">intro</a><ul><li><a href="#h2-1">系统虚拟化简史</a></li></ul><ul><li><a href="#h2-2">VMM 分类</a><ul><li><a href="#h3-3">完全虚拟化</a></li></ul><ul><li><a href="#h3-4">类虚拟化</a></li></ul></li></ul><ul><li><a href="#h2-5">虚拟机内存地址转换</a><ul><li><a href="#h3-6">软件页表虚拟化 shadow page</a></li></ul></li></ul><ul><li><a href="#h2-7">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">intro</h1><p>虚拟化技术正在成为系统软件中广泛存在的一层,它的普及可以从三个角度来看待.</p><ul><li>从硬件平台来讲,虚拟化技术被用于企业级服务器、桌面平台(例如台式计算机和笔记本式计算机)以及嵌入式系统中;</li></ul><ul><li>从用途来讲,虚拟化技术被用于系统资源管理、容错、软硬件维护、增强系统安全、提升性能和节能等领域;</li></ul><ul><li>从趋势来讲,虚拟化技术正在广泛地与其他技术结合,并且得到更多硬件上的支持,其性能损失不断降低,部分固化到硬件中.</li></ul><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240321110029.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240321110029.png" alt="20240321110029"></a></p><p>虚拟化技术的含义很广泛.<b>将任何一种形式的资源抽象成另一种形式的技术都是虚拟化</b>.在常用的操作系统中就存在某种意义上的&quot;虚拟化技术&quot;,例如虚拟内存空间和进程.如果把内存看作是一个设备,虚拟内存就是将物理内存虚拟成多个内存空间.虚拟内存的容量可以少于或多于物理内存; 进程的概念实际是对于物理硬件执行环境的一个抽象,每一个进程都享有一个完整的硬件执行环境,并且与其他进程相隔离.</p><p>相对于进程级的虚拟化,虚拟机是另外一个层面的虚拟化,即系统级虚拟化.与虚拟单个进程的执行环境所不同,系统级虚拟化所抽象的环境是整个计算机,其抽象出的环境称为虚拟机,包括CPU、内存和I/O.在每个虚拟机中都可以运行一个操作系统,在一台计算机上可以虚拟出多个虚拟机.</p><p>虚拟化(Virtualization)以各种形式存在已经有四十多年的时间了.它对于不同的人来说可能意味着不同的东西,这要取决于他们所从事工作领域的环境.有经验的程序员可能还记得,曾有一段时间他们担心是否有可用内存来存放自己的程序指令和数据,于是出现了<b>虚拟内存</b>.后来,为了更好地<b>时分共享</b>(Time-sharing)昂贵的大型机系统,出现了<b>虚拟服务器</b>.</p><p>然而,虚拟化技术的内涵远远不止于虚拟内存和虚拟服务器.目前各种设备都开始了虚拟化之旅, GPU虚拟化、网络虚拟化、微处理器虚拟化、文件虚拟化和存储虚拟化等技术,如果在一个更广泛的环境中或从更高级的抽象(如任务负载虚拟化和信息虚拟化)来思考虚拟化技术,虚拟化技术就变成了一个非常强大的概念,可以为最终用户、应用程序和企业提供很多优点.</p><p>抽象来说,<b>虚拟化是资源的逻辑表示</b>,它不受物理限制的约束.具体来说,虚拟化技术的实现形式是在系统中加人一个虚拟化层,虚拟化层将下层的资源抽象成另一形式的资源,提供给上层使用.<b>通过空间上的分割、时间上的分时以及模拟,虚拟化可以将一份资源抽象成多份</b>.反过来,虚拟化也可以将多份资源抽象成一份.总的来说,虚拟化可以用来统筹管理资源, 在物理设备资源之上提供一层更高的抽象</p><p><b>系统虚拟化</b>是虚拟化技术中的一种,其抽象的粒度是整个计算机.早在20世纪60年代这个名称就已经诞生,从这个程度上来说,这是一个和操作系统有着同样悠久历史的领域.在虚拟化技术发展的几十年历程中,它经历了数次大幅度的起落,人们不断被虚拟化技术潜在的功能所吸引,然后又因客观技术上的限制而放弃.但是,随着近年来处理器技术和性能的迅猛发展,虚拟化技术成熟的时机真正到来.尤其是硬件虚拟化技术的诞生(例如Intel VT和AMD SVM技术),极大地扩展了虚拟化技术的应用范围.本章先简单介绍一些常见的虚拟化概念,然后着重介绍系统虚拟化,包括它的发展历史、特点以及系统虚拟化会带来什么好处</p><h2 id="h2-1">系统虚拟化简史</h2><h2 id="h2-2">VMM 分类</h2><p>在一台物理机上可以模拟出多台虚拟机(Virtual Machine,简称VM),每个虚拟机中都可以运行一个操作系统(OS).提供虚拟化的平台被称为VMM(Virtual Machine Monitor),在其上运行的虚拟机被称为guest VM(客户机).根据VMM支持的虚拟机制的不同,guest VM的运行模式可分为完全虚拟化(Full Virtualization)和类虚拟化(Para Virtualization).</p><h3 id="h3-3">完全虚拟化</h3><p>如果一个基于硬件运行(native)的OS不需要修改任何代码就可以直接跑在VMM上,也就是guest OS根本感知不到自己运行在一个虚拟化环境中(可以说VMM是骗术高明的),这种就被称为&quot;完全虚拟化&quot;.在这种模式下,VMM需要正确处理guest所有可能的指令.</p><p>最简单直接的方法就是,VMM对guest运行过程中的<b>每一条指令都进行解释和执行</b>,模拟出这条指令执行的效果,这种方法既适用于和VMM相同体系结构的guest,也能用于模拟和VMM不同体系结构的guest(比如物理CPU是x86的,而guest是基于ARM的),其缺点也很明显,就是<b>性能太差</b>.</p><p>但是有一些指令是要操作特权资源的,比如修改虚拟机的运行模式或者下面物理机的状态,读写时钟或者中断寄存器,这些指令被称为<b>敏感指令</b>,确实不适合由guest直接来控制; 其他的一些非敏感指令是完全可以在物理CPU上直接执行并返回结果给guest的,VMM只需要截获并模拟guest对敏感指令的执行和对特权资源的访问就可以了,以intel的VT-x和AMD的AMD-V为代表的硬件辅助虚拟化技术,就可以帮助VMM高效地识别和截获这些敏感指令.</p><p>像x86这种CISC架构的系统,指令繁杂,其中一些指令是难以虚拟化的,如果使用完全虚拟化,就需要通过<b>二进制代码翻译</b>(binary translation),扫描并修改guest的二进制代码,将难以虚拟化的指令转换成支持虚拟化的指令(ABI级),就像打补丁一样.</p><blockquote><p>一个典型的例子是x86架构中的<a href="https://www.felixcloutier.com/x86/cpuid" target="_blank">CPUID</a>指令.CPUID指令用于查询处理器的特性和能力,它会返回关于CPU的型号、特性、缓存大小等信息.在虚拟化环境中,<b>直接执行CPUID指令可能会暴露宿主机的敏感信息</b>,或者返回与虚拟机配置不一致的信息.</p><p>为了解决这个问题,虚拟机监控器(VMM)或hypervisor通常会截获CPUID指令的执行,然后根据虚拟机的配置和策略来提供适当的响应.这个过程涉及到以下步骤:</p><ul><li>截获指令:当虚拟机尝试执行CPUID指令时,VMM截获该指令,防止它直接在宿主机的处理器上执行.</li></ul><ul><li>分析参数:VMM检查CPUID指令的输入参数,这些参数决定了CPUID将要返回的信息类型.</li></ul><ul><li>构造响应:VMM根据虚拟机的配置和需要隐藏的信息来构造一个合适的响应.例如,VMM可能会修改返回的CPU特性集合,以反映虚拟机的硬件限制或安全策略.</li></ul><ul><li>注入响应:VMM将构造好的响应注入到虚拟机的状态中,使得虚拟机认为CPUID指令已经执行,并得到了预期的结果.</li></ul></blockquote><h3 id="h3-4">类虚拟化</h3><p>类虚拟化是通过<b>在源代码级别修改指令</b>以回避虚拟化漏洞的方式来使VMM能够对物理资源实现虚拟化.</p><p>上面谈到x86存在一些难以虚拟化的指令,完全虚拟化通过二进制翻译技术在二进制代码级别上来避免虚拟化漏洞.类虚拟化采取的是另一种思路,即<b>修改操作系统内核的代码</b>(即API级),<b>使得操作系统内核完全避免这些难以虚拟化的指令</b>.操作系统通常会使用到处理器提供的全部功能,例如特权级别、地址空间和控制寄存器等.</p><p>类虚拟化首先需要解决的问题就是如何插人VMM.典型的做法是修改操作系统的处理器相关代码,让操作系统主动让出特权级别,而运行在次一级特权上.这样,当操作系统试图去执行特权指令时,保护异常被触发,从而提供截获点供VMM来模拟.既然内核代码已经需要修改,类虚拟化进一步可以被用于优化I/O.也就是说,类虚拟化不是去模拟真实世界中的设备,因为太多的寄存器模拟会降低性能.相反,类虚拟化可以自定义出高度优化的I/O协议.这种I/O协议完全基于事务,可以达到近似物理机的速度</p><hr><p>总的来说二者的区别如下:</p><p><b>完全虚拟化(Full Virtualization)</b></p><ul><li>硬件兼容性:完全虚拟化技术通过模拟硬件的方式来实现虚拟化,使得客户操作系统能够在与原始硬件几乎相同的虚拟环境中运行.这意味着它<b>可以支持广泛的操作系统</b>,包括那些没有经过修改或优化以在虚拟化环境中运行的系统.</li></ul><ul><li>性能开销:完全虚拟化通常会<b>引入一定的性能开销</b>,因为它需要通过软件来模拟硬件操作,包括处理虚拟机的系统调用和硬件中断.</li></ul><ul><li>二进制翻译:在处理那些难以虚拟化的指令时,完全虚拟化可能<b>需要使用二进制翻译技术来转换客户操作系统的代码</b>,以确保它们能够在虚拟化环境中正确执行.</li></ul><ul><li>硬件辅助:完全虚拟化可以<b>利用硬件辅助虚拟化技术</b>(如Intel VT-x和AMD-V)来提高性能和效率,但即使没有这些硬件支持,它也能够运行.</li></ul><p><b>类虚拟化(Para virtualization)</b></p><ul><li>操作系统修改:类虚拟化<b>要求客户操作系统进行修改</b>,以便它知道自己是在虚拟化环境中运行.这些修改使得操作系统能够通过一组明确定义的API与虚拟机监控器(VMM)进行交互.</li></ul><ul><li>性能优势:由于类虚拟化避免了模拟硬件的需要,并且客户操作系统能够直接与VMM通信,因此它可以提供比完全虚拟化<b>更低的性能开销</b>.</li></ul><ul><li>灵活性和可扩展性:类虚拟化提供了更高的灵活性和可扩展性,因为它允许VMM和客户操作系统紧密合作,共享资源和信息.</li></ul><ul><li>适用范围限制:类虚拟化的一个限制是它通常不支持未经修改的操作系统,这意味着<b>只有经过特殊修改的操作系统才能在类虚拟化环境中运行</b>.</li></ul><h2 id="h2-5">虚拟机内存地址转换</h2><p>在介绍虚拟化地址转换之前我们先来快速回顾一下操作系统中的地址转换过程, 这对理解虚拟机内存地址转换非常重要</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240321222310.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240321222310.png" alt="20240321222310"></a></p><p>一个标准 table walk 如上图所示, CR3 寄存器保存当前进程的根页表地址, linux 中采用 48 位虚拟地址, 4KB 的页面, 4 级页表, 使用虚拟地址[47:39],索引L1级页表,得到L2级页表的页基地址.使用[38:30]索引L2级页表,得到L2级页表的页基址, 最终在L4级页表得到实际物理页面地址,加上页内偏移,可以得到物理地址</p><blockquote><p>详细的内容参见 <a href="https://luzhixing12345.github.io/klinux/articles/mm/va-translate/" target="_blank">虚拟地址转换</a>, 这里不再赘述</p></blockquote><p>在Linux这种使用虚拟地址的OS中,虚拟地址经过page table转换可得到物理地址, 如下图所示</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240321234343.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240321234343.png" alt="20240321234343"></a></p><p>但是如果这个操作系统是运行在虚拟机上的, <b>客户端转换得到的物理地址依然只是一个中间的物理地址</b>(Intermediate Phyical Address - IPA),需要再经过 VMM/hypervisor 的转换,才能得到最终的物理地址(Host Phyical Address - HPA).</p><p>可见,如果使用VMM,并且guest VM中的程序使用虚拟地址(如果guest VM中运行的是不支持虚拟地址的RTOS,则在虚拟机层面不需要地址转换),那么就需要两次地址转换, 如下图所示</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240321234716.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240321234716.png" alt="20240321234716"></a></p><p>但是传统的IA32架构从硬件上只支持一次地址转换,即由CR3寄存器指向进程第一级页表的首地址,通过MMU查询进程的各级页表,获得物理地址.因此为了完成这种二级地址转换有两种实现方式, 软件页表虚拟化(shadow page)和硬件页表虚拟化(nested page)</p><hr><p>下文有一些单词的缩写会频繁使用, 这里统一做一下解释</p><p>其中 H 指主机 host, G 指客户端 guest, PA 指物理地址 physical address, VA 指虚拟地址 virtual address, PT 指页表 page table</p><p>因此我们讲的虚拟机内存地址转换其实是 <code>GVA -&gt; GPA -&gt; HPA</code> 的两次转换, 其中 <code>GVA -&gt; GPA</code> 由 guest OS 完成, 对于 OS 内部的进程页表我们称为 gPT(guest Page Table); <code>GPA -&gt; HPA</code> 则由 VMM 完成转换</p><h3 id="h3-6">软件页表虚拟化 shadow page</h3><h2 id="h2-7">参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/93289632" target="_blank">虚拟化技术系列</a></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/441287815" target="_blank">深入理解虚拟化</a></li></ul><ul><li>系统虚拟化 原理与实现</li></ul><ul><li>深度探索Linux系统虚拟化:原理与实现 (王柏生  谢广军)</li></ul><ul><li>NewBluePill深入理解硬件虚拟机 (于淼  戚正伟)</li></ul><ul><li><a href="https://www.vmware.com/content/dam/digitalmarketing/vmware/en/pdf/techpaper/VMware_paravirtualization.pdf" target="_blank">vmware VMware_paravirtualization.pdf</a></li></ul><ul><li><a href="https://blog.csdn.net/hit_shaoqi/article/details/121887459" target="_blank">memory virtualization: shadow page &amp; nest page</a></li></ul><ul><li><a href="https://blog.csdn.net/hx_op/article/details/103980411" target="_blank">内存虚拟化-shadow实现</a></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../快速开始/编译内核" >快速开始</a><ul><li><a href="../../快速开始/编译内核" >编译内核</a></li></ul><ul><li><a href="../../快速开始/调试内核" >调试内核</a></li></ul><ul><li><a href="../../快速开始/制作文件系统" >制作文件系统</a></li></ul><ul><li><a href="../../快速开始/制作linux发行版" >制作linux发行版</a></li></ul><ul><li><a href="../../快速开始/linux目录结构" >linux目录结构</a></li></ul><ul><li><a href="../../快速开始/邮件订阅" >邮件订阅</a></li></ul></li></ul><ul><li><a href="../../mm/物理布局探测" >mm</a><ul><li><a href="../../mm/物理布局探测" >物理布局探测</a></li></ul><ul><li><a href="../../mm/NUMA" >NUMA</a></li></ul><ul><li><a href="../../mm/buddy" >buddy</a></li></ul><ul><li><a href="../../mm/slab分配器" >slab分配器</a></li></ul><ul><li><a href="../../mm/memory compaction" >memory compaction</a></li></ul><ul><li><a href="../../mm/va-translate" >va-translate</a></li></ul></li></ul><ul><li><a href="../../vm/intro" >vm</a><ul><li><a href="../../vm/intro" >intro</a></li></ul></li></ul><ul><li><a href="../../runtime/proc" >runtime</a><ul><li><a href="../../runtime/proc" >proc</a></li></ul><ul><li><a href="../../runtime/vsdo" >vsdo</a></li></ul><ul><li><a href="../../runtime/elf_format" >elf_format</a></li></ul><ul><li><a href="../../runtime/elf_loader" >elf_loader</a></li></ul></li></ul><ul><li><a href="../../kernel/init" >kernel</a><ul><li><a href="../../kernel/init" >init</a></li></ul><ul><li><a href="../../kernel/interrupt" >interrupt</a></li></ul></li></ul><ul><li><a href="../../arch/cpu" >arch</a><ul><li><a href="../../arch/cpu" >cpu</a></li></ul><ul><li><a href="../../arch/cache" >cache</a></li></ul><ul><li><a href="../../arch/multicore" >multicore</a></li></ul><ul><li><a href="../../arch/cache-coherence" >cache-coherence</a></li></ul><ul><li><a href="../../arch/memory-coherence" >memory-coherence</a></li></ul><ul><li><a href="../../arch/bus" >bus</a></li></ul><ul><li><a href="../../arch/disk" >disk</a></li></ul></li></ul><ul><li><a href="../../fs/storage" >fs</a><ul><li><a href="../../fs/storage" >storage</a></li></ul></li></ul><ul><li><a href="../../proc/cpu" >proc</a><ul><li><a href="../../proc/cpu" >cpu</a></li></ul><ul><li><a href="../../proc/nice" >nice</a></li></ul></li></ul><ul><li><a href="../../device/init" >device</a><ul><li><a href="../../device/init" >init</a></li></ul></li></ul><ul><li><a href="../../others/safety" >others</a><ul><li><a href="../../others/safety" >safety</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../mm/va-translate","../../runtime/proc","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>